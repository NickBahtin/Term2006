program gprs_1;
//51 52 53 54 00 00 00 00 00 00 00 00 00 00 04 4A
//89.207.73.52 - Киров
//==============================================================================
//***Good idea!!!*** - флаг необходимости проверить в будущем и дореализовать
//http://www.ixbt.com/news/all/index.shtml?10/87/35
//  интегратор приборов серии КМ5 с поддержкой каналов MODEM,Ethernet,232
//  дата начала разработки 1.08.2008
//  программист Бахтин Н.А.
//  ПРЕДПОЛАГАЕМЫЕ ФУНКЦИИ:
//  (поддержка до 8 приборов КМ5)
// - IP хоста
// - номера приборов
// - расписание задач опроса
// - флаги состояния задач опроса
// - дампы наборов мгновенных значений
// - регистры уставок и флаги необходимости извещения вышестоящей инстанции о выходе параметров за пределы
// - кольцевой буфер архива часовых и суточных величин
// - интерфейс через RS232 - ModBus и через RS485 - КМ5
// - интерфейс через Ethernet - КМ5
// - интерфейс через MODEM модем - ГИС ТБН Энерго 2                   ggjb
//
//   ГРАФИК РЕАЛИЗАЦИИ:
//   функция                                                   срок               готово
// - запуск кристалла                                        2.08.2008          5.08.2008
// - драйвер к внешней памяти                                6.08.2008         14.08.2008
// - драйвер часов реального времени                         7.08.2008         18.08.2008
// - интерфейс RS232                                        11.08.2008         20.08.2008
// - разбивка пространства памяти FLASH                     12.08.2008         14.08.2008
// - интерфейс RS485 - КМ5                                  13..15 08.2008
// - организация системы задач опроса и хранения информации 18..21 08.2008
// - интерфейс Ethernet - КМ5 - (канальный уплотнитель)     22.08.2008
// - интерфейс MODEM                                         25..29 08.2008
// HT823GE06055 HC805-04723-pza8-j4rr-8tfe
// 213.85.145.70 pinsperto22 d:\distrib
//==============================================================================
                                                                                //
{
КСПД-5 197685726: Qisda_M33G MODEM_ONLINE[8h_5m_26s][1] 62.181.46.2:10003 "MTS-RUS" mts/mts/internet.mts.ru  I(1,0,0,48)K O(1,0,0,2)K 357,93руб "KSPD-5 V1.81zo from 01.07.09" 01.07.09_16:23:49 start=8h_stop=25h 14 0000
КСПД-5 197685726: KSPD:Not supported command:TBN	:
КСПД-5 197685726: KSPD:Not supported command:TBN	"
КСПД-5 197685726: KSPD:Not supported command:TBN	'
КСПД-5 197685726: KSPD:Not supported command:TBN	,
КСПД-5 197685726: KSPD:Not supported command:TBN	1)
КСПД-5 197685726: KSPD:Not supported command:TBN	63
КСПД-5 197685726: KSPD:Not supported command:TBN
КСПД-5 197685726: KSPD:Not supported command:TBN
КСПД-5 197685726: KSPD:Not supported command:TBN
КСПД-5 197685726: KSPD:Not supported command:TBN
КСПД-5 197685726: KSPD:Not supported command:TBN	*
КСПД-5 197685726: KSPD:Not supported command:TBN	5
КСПД-5 197685726: KSPD:Not supported command:TBN
КСПД-5 197685726: KSPD:Not supported command:TBN	$
КСПД-5 197685726: Qisda_M33G MODEM_ONLINE[9h_17m_46s][1] 62.181.46.2:10003 "MTS-RUS" mts/mts/internet.mts.ru  I(1,0,0,55)K O(1,0,0,3)K 357,92руб "KSPD-5 V1.81zo from 01.07.09" 01.07.09_17:37:57 start=8h_stop=25h 12 0000
--------типы поддерживаемых СМС-----------
tbn g mts mts internet.mts.ru 89.207.73.52 10003 165970019
+CMGR: "REC UNREAD","уцЬХ¦П]т:",,"08/11/06,11:14:26+18",208,64,0,8,"79168960220",145,132
050003AB030100740062006E002000670020006D007400730020006D0074007300200069006E007400650072006E00650074002E006D00740073002E00720075002000380039002E003200300037002E00370033002E003500320020003100300030003000330020003100360035003900370030003000310039000A00490050003A0020
tbn g gdata gdata internet 89.207.73.52 10003 226600821
tbn g gdata gdata internet 89.207.73.52 10003 267697674 0CAA
tbn g gdata gdata internet 62.181.46.2 10003 267697674 0C6D - конфигурация узла подключения MODEM c контрольной суммой
tbn g mts mts internet.mts.ru 62.181.46.2 10003 197685731 0DA3
tbn b *102#" +79195174042 - не реализовано
tbn r                     - посылка состояния на определенный
tbn r +79xxxxxxxxx        - посылка состояния на определенный номер +79xxxxxxxxx
                            после этого данный номер становится номером поумолчанию
tbn z startzone=08 stopzone=25
197685724 - подвал
197685731 - стенд в кабинете у шинелева

???
+CUSD: 0,"041204300448002004310430043B0430043D0441002000390033002E00340034044004430431002E0421043A04380434043A0430002000390039043F0440043E044600200432043D044304420440043800200441043504420438003A0438043D0444043E0020003000350039003000330032",72
Ваш баланс 93.44руб.Скидка 99проц внутри сети:инфо???
???
Баланс:192,53руб


+CUSD: 0,"041704300434043E043B04360435043D043D043E04410442044C003A002D0036002C00310031044004430431",72
Задолженность:-6,11руб

+CUSD: 0,"04110430043B0430043D0441003A00380038002C00380039044004430431",72
Задолженность:-146,39руб
0,"041704300434043E043B04360435043D043D043E04410442044C003A002D003100340036002C00330039044004430431",72
Баланс:88,89руб
+CUSD: 0,"4E61207363686574653A20313035342E3330207275622E20566573656C796520726F7A79677279736869206920736875746B6920766D6573746F206775646B6F7621205A766F6E69206E6120303737302C2076797A6F7620626573706C61746E796A21",15
Na schete: 1054.30 rub. Veselye rozygryshi i shutki vmesto gudkov! Zvoni na 0770, vyzov besplatnyj!
Ваш баланс -2.08руб. Звони 0756, разыграй друзей  1 апреля 17р
Service is temporary unavailable
<<AT+CGMR
>> 53 57 20 76 65 72 3A 20 31 2D 30 34 - (SW ver: 1-04)
}
//==========================================
//Ошибки зарезервированные КСПД5:
//==========================================
//1 - не найден модем
//2 - ошибка СИМ
//3 - не известен ID КСПД
//
//==========================================
//Номера индикации зарезервированные в КСПД
//==========================================
// 0. Чтение уровня сигнала при SW1=On SW2=Off
//    1..5 величина уровня сигнала
// 1. Инициализация
//    0. проверка наличия
//    1. Проверка ПИН
//    2. чтение заводских параметров модема
//    3. Чтение баланса
//    4. ожидание
// 2. 0. начальные настройки модема по GPRS
//    1. открытие GPRS сессии модемом
//    2. открытие TCP сокета модемом
//    3. регистрация на брокере модемом
// 3. 0. начальная инициализация EW-PORT
//    1. запись параметров в EW-PORT
//    2. открытие TCP сокета EW-PORT
//    3. регистрация на брокере EW-PORT
//--------------------------------------
//    On/OFF режим показывает, что осуществленно одно из 3х типов подключений
//    1. Модем - Брокер
//    2. EW-PORT - Брокер
//    3. MODEM CSD - внутренние порты
{$NOSHADOW}
{ $WG}                     {global Warnings off}

Device = mega2560, VCC=5;
{ $BOOTRST $1F000}         {Reset Jump to $1F000}

Import SysTick, RTclock, SerPort, SerPort2, SerPort3, SerPort4, I2Cport,
       TickTimer{,WatchDog};

From System Import LongWord, LongInt, Float;

From SysTick import SystemTime16;
{$DEFINE DBG}
{ $DEFINE OLDKWARZ}
Define
{$IFDEF OLDKWARZ}
  ProcClock      = 8000000;       {Hertz}
{$ELSE}
  ProcClock      = 7372800;       {Hertz}
{$ENDIF}
  SysTick        = 10;             {msec}
  StackSize      = $0200, iData;
  FrameSize      = $00C0, iData;
//  WatchDog    = 7;//2 сек

  //канальный уплотнитель - xport
  SerPort        = 38400, Stop1;   {Baud, StopBits|Parity}
                  //115200, Stop1;   {Baud, StopBits|Parity}
  //485 - опрос КМ5
  SerPort2       = 9600, Stop1;     {Baud, StopBits|Parity}
  //232 - сервис
  SerPort3       = 38400, Stop1;    {Baud, StopBits|Parity}
  //MODEM
  SerPort4       = 9600, Stop1;//57600, Stop2;    {Baud, StopBits|Parity}

  //часы реального времени
  I2Cport        = PortF;
  I2Cdat         = 2;
  I2Cclk         = 1;

  TickTimer      = Timer1;
  RTClock        = iData, DateTime;{Time, DateTime}
  RTCsource      = SysTick;


  //файловая система
uses FlashIO;


Implementation

// With this implementation we use only drive, track and sector
// information for addressing buffers and the drive.
// Other implementations can use only the parameters of the
// ReadSector and WriteSector command to handle the drives

// we use the two dataflash internal rw-Buffers for intermediate storage.
// buffer 0 becomes the buffer for directory operations.
//     the total directory size is "DiskA_BlockSize" of byte
//     so we can easily find out if an operation is for the
//     directory or for data area of the drive
// buffer 1 becomes the buffer for data transfer operations.
// with this organisation we reduce the read/write transfers
// to/from the dataflash's mainmemory. More speed, less power,
// and longer life of the dataflash

// because we set the sectors/track to 2 a track is of the same
// size as the dataflash internal buffer
// again it's no problem to find out whether we must write the
// temporary buffer to the flash's main memory and/or we have
// read the buffer from the flash's main memory
// at least when the track changes we mast read/write one of
// the two buffers

// to maintain both buffers we use the enumeration type variables
// BuffDirA_State and BuffDatA_State.

(*****************************************************)
(* Attention                                         *)
(* =========                                         *)
(* before shutting down the system do a FileSysReset *)
(* so all temporary buffers will be written to disk  *)
(* if not already done yet                           *)
(*****************************************************)


{--------------------------------------------------------------}

const
  WaitAfterLastByte:byte=7;//70-100мсек
  UBufCount:byte=19;
  UBufSize:integer=255;//,128;//512;//512;//255;//512;//,255;                      //размер буфера приема передачи 1.5К
  MaxRXReqest:string=',100';//максимальное количество байт в запросе из буфера
  MaxParam:byte=4;//максимальное значение обрабатываемых параметров
  cSYSTEM:string='KSPD:';
  Space20:string='                    ';
  Space10:string='          ';
  Space4:string='    ';
  Grandpwd:String='mabuka';
  cHCMdmTimeOut:String='HC:Step ';
  cSMWMdmTimeOut:String='SMW:Step ';
  CTRLZ:byte=$1A;
{ Type Declarations }
type
  //01 41 63 80 E4 09 10 00 00 02 39 72 01 00 04 00 E2 EE E9 20 20 E0 F0 F5 4E 6E E1 B6
(*
  заголовок пакета брокера
  THeaderPack=record
    NetAddr:byte;
    Cmd:byte;
    ID:longword;
    Len:word;
    Port:byte;
    Baud:byte;
  end;*)
    //биты регистра управления КСПД
  TTypeOfParam=(tpD,//дискретный
                tpA,//аналоговый
                tpI,//импульсный
                tpP,//протокол по каманде 123 КМ5 (номер - является номером параметра в ответе на запрос)
                tpFC,//управление потоком данных RS232 - FlowControl RS232
                tpU);//неизвестный

  TEvent=record
     NotifyMustSended:boolean;//необходимо послать уведомление
     AlarmData:longword;      //время захвата события - копируется nowCData
     State:byte;              // битовая структура - номера битов:
                              // 0-диапазон ниже минимального 1-больше максимального 2-неисправность датчика
     CurVal:integer;          //текущее значение
  end;
  
  TParam=record
            Active:boolean;     //активный
            Mode:byte;          //0 не посылать уведомления 1- посылать при минимумЕ 2- посылать преходе при максимуме 3- посылать при луюбом переходе
            TypeOfParam:TTypeOfParam;
            NumParam:byte;      //номер параметра (D=1..4 A=1..4 I=1..17 (см.команду 123 протокола КМ5))
            PredState,
            CurState:boolean;   //состояние датичка -предыдущее - текущее переход с предыдущего 0 в текущее 1 - увеличиваем интегратор
            lValue:longword;    //для счетчиков - НАКОПЛЕНИЕ ЗА ИНТЕРВАЛ ИЗМЕРЕНИЯ
            iDlit:byte;//длительность состояния в текущем положении
            iValue,iPredValue:integer;        //для расчета мгновенной скорости - сбрасывается раз в минуту
            PredVal:integer;    //предыдущее значение
            CurVal:integer;     //текущее значение
            MinVal:integer;     //аварийное значение перекрывающее параметр по минимуму
            MaxVal:integer;     //аварийное значение перекрывающее параметр по максимуму
            SMSMessage:boolean; //высылать ли нотификацию по СМС
            StrMsg:String[25];  //краткое описание параметра
            TelNum:string[12];  //номер телефона - по которому необходимо ообщить о событии
  end;


  TKSPDCONTROL=(
              kc_SMSEVENT,        //- имеется необработанное событие, нуждаюшееся в оповещении через СМС
              kc_BROKEVENT,       //- имеется необработанное событие, нуждаюшееся в оповещении через брокер
              kc_BROKER_SHEDULE_CONNECT,    //- брокер отверг подключение - следующее через час
              kc_SMSMUSTDEL,      //- необходимо удалить текущую СМС
              kc_SMS_CHECK,       //- необходимо проверить приходящие СМС
              kc_SMS_SEND,        //- необходимо послать СМС - ФЛАГ ВОЗНИКАЕТ ПРИ РАЗБОРЕ ПРИНЯТОЙ СМС
              kc_CSD_EN,          //- режим CSD разрешен
              kc_MCSQ_EN,         //- выделенный запрос уровня сигнала
              kc_MBROKER_EN,      //- режим клиента брокера через MODEM разрешен
              kc_MSERVER_EN,      //- режим сервера через модем разрешен
              kc_EBROKER_EN,      //- режим клиента брокера через EPORT разрешен
              kc_IGNOREOK,        //- игнорирование OK на уровне нотификации
              kc_MCR,             //- ожидается ответ от модема
              kc_ECR,             //- ожидается ответ от EPORT
              kc_RS232CR,         //- ожидается ответ от RS232
              kc_RS485CR);        //- ожидается ответ от RS485

  //биты флага состояния КСПД
  TKSPDSTATE=(ks_MPOWER,    //- подано питание на модем
              ks_MPRESENT,  //- модем в наличии
              ks_M33PRESENT,//- модем M33G в наличии
              ks_HASERROR,  //- есть ошибки
              ks_EPRESENT,  //- EPORT в наличии
              ks_ATCOMMAND,  //- модем в режиме АТ-команд
              ks_ECOMMAND,  //- EPORT в режиме команд
              ks_FPM,       //- в буфере модема есть неразобранный поакет
              ks_FPE,       //- в буфере Ethernet есть неразобранный пакет
              ks_CSD,       //- режим CSD активен
              ks_MBROKER,   //- режим клиента брокера через MODEM активен
              ks_MSERVER,   //- режим сервера через модем активен
              ks_EBROKER,   //- режим клиента брокера через EPORT активен
              ks_ESERVER,   //- режим сервера через EPORT активен
              ks_HARDWARECHECKED,//аппаратная часть проверена
              ks_ACCESS_EN);//- прибор разблокирован
              
  TKSPDERROR=(ke_BADPINCODE,  //ошибочный пинкод
              ke_BADGSMREG,   //нет сети
              ke_BADGPRSREG,  //ошибка регистрации в сети
              ke_BADBROKERREG,//ошибка регистрации на брокере
              ke_RESERV1,      //резерв
              ke_RESERV2,      //резерв
              ke_RESERV3,      //резерв
              ke_RESERV4,      //резерв
              ke_RESERV5,      //резерв
              ke_RESERV6,      //резерв
              ke_RESERV7,      //резерв
              ke_RESERV8,      //резерв
              ke_RESERV9,      //резерв
              ke_RESERV10,      //резерв
              ke_RESERV11,      //резерв
              ke_RESERV12);      //резерв
  TKSPDRESTORE=(kr_CONSOLE,      //порт с консолью
                kr_GMODEM,        //пинкод,APN,логин,пароль
                kr_BROKER,       //брокер,IP,порт,ID
                kr_EPORT,        //адрес сервера для подключения EPORT
                kr_HARDNUM,      //заводской номер КСПД
                kr_BALANCE,      //строка USSD запроса баланса
                kr_WRKTIM,//зона работы клиента брокера
                kr_ENCONSOLE,   //флаги активности консолей по портам
                kr_DESTRS232,    //порт назначения для RS232
                kr_DESTRS485,    //порт назначения для RS485
                kr_DESTETHER,    //порт назначения для EPORT
                kr_DESTMODEM,    //порт назначения для MODEM
                kr_BAUDRATE,     //скорость по RS232 и RS485
                kr_PASSWORD,     //пароль
                kr_SERVER,       //сервер
                kr_PARAM         //параметры
                 );

  TBitSetKSPDCONTROL=BitSet of TKSPDCONTROL;
  TBitSetKSPDSTATE=BitSet of TKSPDSTATE;
  TBitSetKSPDERROR=BitSet of TKSPDERROR;
  TBitSetKSPDRESTORE=BitSet of TKSPDRESTORE;

  TResultFunction=(rfWait,rfTranzit,rfNextStep,rfError);//в работе, переход далее, шаг по цепочке, ошибка
  tBufferState    = (bsEmpty, bsFilled, bsChanged);
  PLongword=pointer to longword;
  PFloat=pointer to Float;
  PWord= pointer to word;
  PInteger= pointer to integer;
  PByte=pointer to byte;
   //         -1        0     1      2         3      4
   TCOMMIDX=(ciMODEM,ci485,ci232,ciEthernet,ciV_CON,ciFree);
   TSpeedBaud=(sb2400,sb4800,sb9600,sb19200,sb38400,sb57600,sb115200);
   TSlotMode=(smFree,smClient,smInProgress,smServer);//режим подключения текущего слота
   TIOBuff=array[0..UBufSize-1] of byte;      //стандартный буфер обмена
   TSlot=record
         Active:boolean;      //значение по SO
         Mode:TSlotMode;      //текущее состояние слота по CN
         IP:longword;         //IP
         IPBody[@IP]:array[1..4] of byte;
         ModemHasData:boolean;//флаг того, что по данному слоту у модема есть данные
                              //далее слот при совобождении источника назначения должен
                              //переслать эти данные источнику назначения и выставить
                              //у источника номер занявшего его слота
         IDLECount:word;      //счетчик тишины - после превышения значения счетчика определенного порога
                              //необходимо послать пакет хотя б с 1 байтом для проверки соединения,
                              //либо закрыть соединение - значит надо ввести такую опцию
   end;

   TUBuff=record
        Owner:TCOMMIDX;
        BufNum:word;//номер пакета
//        FromOwner:boolean;//это от владельца или к владельцу
        State:byte;//состояние буферов приемк 0-совобден 1- пишется 2-заполнен
        Count:integer;//наполненность текущего буфера
        Buff:TIOBuff;       //Буфер приема сообщения
        ASlot:byte;       //номер слота 0..6 0-свободная передача, 1..5 - М2М 6-ATD
   end;
   TCOMM=record
        CurBufNum:word;//номер заполнения текущего буфера
        tmpUBuff:byte;//временная переменная для поиска свободного буфера
        LastUBuff:byte;//индекс последнего из известных буферов
        ResendUBuff:byte;//индекс пересылаемого буфера - буфера находящегося в обработке
        //
        // Входной и выходной буфер - порта COM2 - КМ5Net
        //
        Modify:boolean;                             //флаг модификации InputBuffWaitDelay
        Overflow:boolean;
        IncDec:word;                                //анализ потерь
        InputBuffWaitDelay:byte;                    //байт ожидания продолжения посылки
        //
        DestComm:TCOMMIDX;                          //куда назначается пакет
        Cmd:byte;                                   //$00 - чистый пакет
                                                    //$41,$42 выходной буфер необходимо передать в оплетке протокола обмена с брокером
        //дополнения
        HeaderPackage:array[0..9] of byte;              //заголовок пакета
        DefaultDestination:TCOMMIDX;          //куда я должен ответить по приходу ответа по данному каналу
        Destination:TCOMMIDX;              //куда я должен ответить по приходу ответа по данному каналу
        AnswerSlot:byte;                  //куда предстоит ответ - номер слота - 0 пункт назначения свободен
        IdleCounter:integer;             //счетчики простоя по каналам
        EnableConsole:boolean;                //куда я должен ответить по приходу ответа по данному каналу
        DefaultBaud:TSpeedBaud;           //скорость поумолчанию для канала
        Baud:TSpeedBaud;                      //с какой скоростью
   end;

{--------------------------------------------------------------}
{ Const Declarations }
const
   curVer:string='"KSPD-5 V2.05 from 19.04.10"';
   cAccessDenied:string='access denied!';
   cOk:string='OK';
   //1.22 - стабильная бета версия - старый формат транзитного пакета - с одним каналом MODEM - 485
   //1.23 - новый формат транзитного пакета
   //1.24 - переходим к структуре переменных
   //1.30 - ЗАРАбОТАЛ МЕхАНИЗМ ПОДКЛЮЧЕНИЯ У НОВОГО АЛГОРИТМА
   //1.31 - после приема эха TBN сбрасываем буфер приема
   //1.32 - начало подержки пашиных сервисов
   //1.33 - чистые имена модема
   //1.34 - поддержка ПИН кода
   //1.35 - поддержка ПИН кода - исправлена ошибка ПИН в кавычках
   //1.36 - исправлены функции изменения скорости
   //1.37 - добавлена команда 42
   //1.38 - в строку состояния добавлено состояние дискретных входов
   //     - исправлена функция CompateStr параметр с 11 до 15
   //1.39 - на 232 сыплется поток байт - причина не известна пока - организуем пока временной доступ
   //задается AT%CGAATT=1,0 механизм подключения к MODEM контенту
   //1.41 -  исправлена функция отработки сигнала
   //1.42 -  по ERROR PIN уходит в аут но WD не сбрасывается
   //1.43 -  шаговик модема ускорен
   //1.44 -  тестируем idle Ping
   //1.45 -  сброс буфера после ответа на регистрацию - TBN
   //1.47 -  убран watchdog=0 с шага инициализации
   //1.48 -  изменена логика по анализу ПИН кода
   //     -  переделки J1 J2
   //1.49 -  маскируется в старшей тетраде номера порта номер посылки
   //        исправлены тестовые команды RS485,Ethernet
   //1.50 -  ks_FPM in KSPDSTATE:=False в ModemCmd_M23
   //1.51 -  Новый вариант платы с 5 светодиодами мощности сигнала
   //1.52 -  SW_1 и SW_2 местами поменяны
   //1.53 -  AUTOREQ
   //1.54 -  фильтр на однобайтовые пакеты с Ethernet
   //1.55 -  УВЕЛИЧЕН РАЗМЕР БУФЕРА
   //1.56 -  добавлена команда HARDNUM
   //1.57 -  1 стоповый бит
   //1.57 -  делители на UART под кварц 7.3728
   //1.57 -  отказались от задержек
   //1.58 -  таймаут между байтами в приеме не более 100 мсек
   //        блокировка выходных пакетов
   //1.59 -  светодиоду поменяли местами
   //1.60 -  изменен порядок налализа ответа на DESTINFO змейка отключена при сервисе
   //        исправлена 42_2 при запросе состояния через tbn r
   //1.61 -  отключен повтор запросов - (на КАПОТНЕ)
   //1.62 -  выведены строки версии не зависимо от отладки
   //1.63 -  конфигурационная СМС с цифровой подписью
   //1.64 -  Зона расписаний начало - конец
   //1.65 -  в режиме  ожидания изменился индикатор моргания 2свет 5 темнота 1 свет 1 темнота
   //1.66 -  индикатор исправлен
   //1.67 -  WatchDog уменьшен до 3 - и убраны все mdelay>300 - заработал WD во всех режимах LedStapper
   //1.68 -  WD в норму - кварц под 7
   //1.69 -  синхронизация времени от брокера и отключение границ при сбросе времени
   //1.69a - изменены j1и j2
   //1.69b - AT$TIMEOUT=200 - был 100
   //1.69c - опрос сигнала при каждой проверке СМС и раз в час в период тишины проверка СМС и уровня сигнала
   //1.69d - в ETHERNET и RS485 командах        поддерживается ASCIIMOE
   //1.70  - поддержка баланса
   //1.70a - защитный буфер, статистика обмена
   //1.70b - изменена логика формирования по 42_2
   //1.71  - контрольные сумы системных областей флэш и ОЗУ
   //1.72  - переделка типа буфера вариант 1- пока в отстой - тяжелый обработчик
   //1.73  - переделка типа буфера вариант 2 - промежуточный
   //1.74  - переделка типа буфера - концептуальная
   //1.75  - увеличен размер буфер у Ethernet
   //1.76  - отображается источник перезапуска
   //1.77  - блокировка вывода более чем MAxBuff
   //1.77a - исправлен терминальный режим - ответ посылется в терминал не зависимо от режима отладки
   //1.78 -  после ответа сбрасывается Destination
   //        скорость восстанавливается на 232 только если идут запрсы по ciFree с 232
   //1.79 -  24.03.09 (отдана в производство) небольшая реорганизация процедур формирования выходного буфера
   //        и так по мелочам набралось
   //1.80 -  31.03.09 попытка реализации CSD
   //1.80b - 02.04.09 первая реализация CSD
   //1.80с - 04.04.09 порты назначения по умолчанию для свободного потока данных
   //1.80d - 08.04.09 ENABLECONSOLE V_CONSOLE
   //ETHERNET_DEST = [RS485,RS232,FREE]
   //RS485_DEST      =  [RS232,ETHER,FREE]
   //RS232_DEST      =  [RS485,ETHER,FREE]
   //MODEM_DEST      = [RS485,RS232,ETHER,FREE]
   //1.80e - 10.04.09 COmpareStr
   //----------------------------------------------------------------------------------------------------
   //Debug биты 0 - общие информационные сообщения, WARNINGи
   //Debug биты 1 - запросы на модем, ответы модема на команды запроса
   //Debug биты 2 - сообщения о входах в процедуры, ДОПОЛНИТЕЛЬНЫЕ СООБЩЕНИЯ
   //Debug биты 3 - содержимое СМС и содержимое СМС в HEX коде, а так же размеры копирования блоков
   //Debug биты 4 - обмен
   //Debug биты 5 - резерв
   //Debug биты 6 - резерв
   //Debug биты 7 - резерв
   //----------------------------------------------------------------------------------------------------
   //1.80f - 16.04.09 режим основной - резервный
   //1.80g - 18.04.09 работа с модемом в SERVICE
   //                 введены "answer" флаги
   //                 STARTTIME STOPTIME - сохраняются во флеш
   //1.80h - 20.04.09 первый вариант работы по основному и резервному каналам
   //                 переработаны функции:
   //                   ReassembleInputBuff_MODEM
   //                   DisassembleConsoleCmd
   //                   CheckDisconnection;
   //1.80i - 21.04.09 работа модема в режиме основной/резервный
   //                 переработаны функции:
   //                 DisassembleServicePackage(Dest:TCOMMIDX); - 42 команда для EW-PORT
   //                 DisasmFreeStream     - выход после распознавания команды консолью
   //                 ReassembleInputBuff_RS232;
   //                 ReassembleInputBuff_RS485;
   //                 добавлены паараметры
   //                 ECLIENTACTIVE
   //                 AnswerCOUNTERS с автоматическим сбросом флага запроса через минуту
   //1.80j - 22.04.09 переключение - основной/резервный - скорректирован возврат
   //                  реализована виртуальная консоль для брокера
   //        23.04.09 в рабочих режимах запись отладки выуодится на всопомгательных индикаторах уровня сигнала
   //                 снят запрет прерывания с блоков копирования в выходной буфер
   //                 ОТКАЗ ОТ AUTOREQ
   //                 PAUSE
   //1.80k - 24.04.09
   //                 исправлена функция DisasmFreeStream
   //                                    EthernetRewriteParam
   //                 контроль предыдущего состояния Sw1 и Sw2
   //                 предварительная инициализация таймеров
   //                 при наличии старых плат Internet c XPORT отключена логика инициализации - для совместимости
   //1.81a - 25.04.09
   //                 альфа версия с поддержкой М33
   //1.81b - 27.04.09
   //                 оптимизация алгоритма - пробный пуск с М33
   //1.81C - 01.05.09 реорганизация механизма ответов - проработка алгоритма
   //                 1. копирование в IOBuff из буферов перываний возможно только при IOBuffStep=0
   //                    в противном случае буфера прерываний так и остаются заполненными
   //                 2. При начале заполнения IOBuff переменная IOBuffStep переходит в 1, что
   //                    означает занятость выходного буфера и необходимость его передачи в пункт назначения
   //                 3. Передача IOBuff в пункт назначения производится только при условии нахождения переменной
   //                    Destination пункта назначения в состоянии Free, в противном случае IOBuffStep
   //                    остается на шаге 2, ожидание освобождения буфера приемника
   //1.81C - 02.05.09  макро реализация алгоритма
   //1.81C - 03.05.09  введен флаг IOBufToBroker
   //1.81C - 04.05.09  флаг IOBufToBroker переработан в Cmd
   //1.81D - 07.05.09
   //1.81E - 08.05.09
   //1.81F - 09.05.09 изменен разбор балансового сообщения
   //1.81G - 11.05.09 FreePort теперь не сбрасывает количество байт в буферах - для отработки команд нуно
   //                 Первая версия на М33 считывающая архив
   //1.81H - 12.05.09 исправлен ShowAnswer(dest:TCOMMIDX);
   //1.81J - 13.05.09 исправлен ReassembleInputBuff_MODEM - запрос на модем при терминальной работе
   //                 изменена логика подключения - ACTIV_S шаг 7 повтор на шаг 6
   //1.81K - 14.05.09 отключена отладка - бетаверсия 1.81
   //                 исправлен ModemCheckServiceMode - режим М23
   //                 ошибка открытия сокет - переподключается через 15 сек
   //                 IgnoreOk:=M33GModem;//для модема М33 игнорируем ответ в запросе баланса
   //                 добавлено в FreePort: Destination[Destination[BuffID]]:=ciFalse;
   //                 исправлен переход на запрос баланса только при отладке
   //                 исправлен контроль изменения джамперов OldSwitcher_2:=Switcher_2;
   //                 строки в виртуальной консоли дополняются пробелами
   //                 убрано Writln перед выводящимся параметром
   //1.81K - 15.05.09 отладочное сообщенеи во FreePort
   //1.81L - 18.05.09 поддержка еще одного варианта балансовой строки и команда BALANCESTR
   //1.81M - 19.05.09 проверка каждого шага активации соединения
   //1.81N - 20.05.09 новый алгоритм анализа строки баланса
   //1.81o - 22.05.09 исправлен на Ethernet канале анализ подключения ('TBN'...)
   //1.81p - 26.05.09 оптимизация механизма работы с модемом
   //                 изменена логика usACTIV_S шаг 8 - уход на проверку контента
   //                 изменена логика пинговки и проверки СМС отказались от ForceIO10Happened
   //1.81q - 27.05.09 изменена скорость работы с модемом и обработка вынесена в цикл 1/3 сек
   //1.81r - 27.05.09 скорость 57600 2 стопа и возвращаем в основной цикл обработку модемного буфера
   //                 изменена система индикации состояния КСПД
   //1.81s - 27.05.09 алгоритм обработки буферов изменени
   //1.81t - 27.05.09 пауза с отправкой буфера в м33
   //1.81u - 02.06.09 пинговка сервера раз в 4.5 минуты
   //                 MState:=usID2BROK;//1_81u
   //1.81v - 02.06.09 перенесен код в первый скоростной   таймер
   //        CheckIOBuff(ci485);
   //        CheckIOBuff(ci232);
   //        CheckIOBuff(ciEthernet);
   //        CheckIOBuff(ciV_CON);
   //        переработан шаг 17 MState:=usID2BROK;// - проверим соединение пинговкой
   //                              MWorkStepState:=0;
   //1.81vt - 10..11.06.09 тестовая версия
   //1.81vtd - 16.06.09 расширенная отладочная информация
   //1.81vtx1 - 17.06.09 реорганизация отладочной информации
   //1.81xa - 18.06.09 скорость с модемом снизил до 38400
   //1.81xc - 18.06.09 вернули скорость до 57600 и ввели Remain_Len
   //1.81xd - 18.06.09  добавлены команды M_STATE,M_STEP,E_STATE,E_STEP
   //1.81xe - 18.06.09  (if (not RequestDataFromM33) and Answer[ciModem] and (Destination[ciModem]<>ciFREE) then)
   //                    if (not RequestDataFromM33) and Answer[ciModem] then - было без ответа
   //1.81xf - 18.06.09  в сервисном режиме при тишине более 10 сек и Remain_Len<>0 запрос
   //1.81xg - 19.06.09  введена битовая трассировка BitMask EBitMask функций ChkIBuff скорость модема 9600
   //1.81xр - 19.06.09  скорость модема 19200
   //1.81xr - 22.06.09  скорость модема 9600 в RESTMDM не увеличиваем MWdog
   //1.81xs - 22.06.09  WD 8 секунд
   //1.81xt - 22.06.09  во всех while сброс WD
   //1.81xu - 22.06.09  таймаут на NWDW - 1 секунда
   //1.81xv - 22.06.09  MWDog инкрементируется только при MCR
   //1.81xw - 22.06.09  таймаут на NWDW - 2 секунды, уровень сигнала не гасится Led сообщениями
   //                    MainWork в секундный таймер скорость 38400
   //1.81xy - 22.06.09  MCR не сбрасываем при запросе, скорость 9600
   //1.81xz - 22.06.09  оптимизирован стек
   //1.81y -  23.06.09  пароль
   //1.81z -  24.06.09  DecodeM33Buff - анализ 'RING'
   //1.81za - 24.06.09  после 5кратный таймаута подаем повторно питание
   //1.81zb - 24.06.09  правка по 6 замечаниям...
   //                   1- ID2BROK/2 - долго ждет - если нет соединения
   //1.81zc - 25.06.09  вывод флагов по таймауту
   //1.81zD - 25.06.09  УБИРАЮ ФЛАГИ
   //1.81ze - 26.06.09
   //                   1- логический WDog на ожидание NWCN ***
   //                   2- пересмотрена система аппаратного WD ***
   //                   3- выборка из буфера запроса не более буфера приема
   //                   4- более строгая консоль
   //                   5- невозможность попадания в консоль ответов с приборов
   //                   6- анализ возможности отправки двух и более запросов на чтение буфера NWDR...
   //                   7- при тишине более 10 сек, отсутствии запросов и режиме SERVICE - запрашивать у модема что нибудь
   //1.81zg - 26.06.09  правка по 6 замечаниям...
   //1.81zh - 27.06.09  отказ от виртуальной консоли для отладочных сообщений
   //                   DEBUG биты
   //                    $01 - общие сообщения
   //                    $02 - модем
   //                    $04 - Ethernet
   //                    $08 - процедуры
   //                    $10 -RS485
   //                    $20 -RS232
   //                    $40 -V_CON
   //                    $80 -расширенная отладка - HEX пакеты
   //1.81zi - 27.06.09   косметические изменения в отладочной информации
   //1.81zj - 29.06.09   реакция на уведомление $NWCN: 1,0
   //1.81zh - 29.06.09   IMEI
   //1.81zk - 29.06.09   BUG in (j=ciModem)
   //                    if ((AnswerCOUNTERS[j]>240) and (j=ciModem)) or ((AnswerCOUNTERS[j]>2) and ((j<>ciModem))) then
   //1.81zl - 29.06.09   реорганизация inetcnfg - inetcnfg,modeminfo,crcflash
   //1.81zm - 29.06.09   FreePort(aFrom); на 16 шаг
   //1.81zn - 30.06.09   InitPorts после Pow_Off и GlobalModemTimeOutCount - не тестирована...
   //1.81z0 - 01.07.09   MainWork вызывается не чаще чем 1 раз в 100 мсек (условие посылки АТ-команд)
   //1.81z01 - 09.07.09   FindInBuff string[30] вместо 11
   //                    на 17 шаге FreePort(aFrom);
   //                    ModemCmd_M33_sendOnePackage(aFrom:TCOMMIDX);
   //                    ShortMsg
   //                    ForceM23
   //                    CompareStr - String[128]
   //1.81z02 - 09.07.09  i:integer локально
   //1.81z03 - 09.07.09  ID2BROKRepeat - счетчик попыток регистрации
   //1.81z04 - 09.07.09  ID2BROKRepeat - счетчик попыток регистрации
   //1.81zv -  10.07.09  CheckSocketRepeat - счетчик попыток NWCH
   //                    step10 ID2BROK - прочистка буфера
   //                    ATD*97# with M_TIMER delay
   //                    MCR := False убрано из Pow_On
   //                    аварийный режим в LightLed на ERRORSIM
   //1.81zw -  13.07.09  для версии прошивки 1.05 основным считаем ForceM23
   //1.81zx -  13.07.09  11 шаг для ACTIV_C - введен тольк изза того что модему QIZDA свойсвенна перезагрузка при борьбе с GPRSв M2M
   //1.82   -  14.07.09  релиз - от 1.81zx отличается шаг ID2BROK - исправлен анализ на RX и выбор шага 0,10
   //1.83   -  10.09.09  добавлены команды для тестирования механизма доступа к FLASH памяти
   //                    отключено сообщение "Not Supported Command"
   //                    версии модемов М33 1.04 и 1.03 не поддерживают ForceM23
   //                    проверка баланса раз в час
   //1.84   -  30.09.09  расширен функционал использования "сухих контактов"
   //       -  06.10.09  уменьшен буфер на 232,485, модем
   //       -  06.11.09  увеличено время действия флага ResentChange
   //       -  13.11.09  GETPASSWORD
   //       -  22.11.09  READPAGE,WRITEPAGE
   //       -  22.11.09  correct ReadPage
   //2.01   -  09.03.10  полная переработка идеологии буферизации, поддержка сервера
   //          10.03.10  упразднили Answer - сейчас все пересылки только согласно Destination
   //          11.03.10  отказ от IOBuffStep
   //          12.03.10  доработка CheckNotifycation (AT$NWSO=x,0..AT$NWTXT=x,60)
   //2.02      20.03.10  проработка HardwareChecked - переработка алгоритмики, ввод регистров KSPDCONTROL и KSPDSTATE
   //2.03      23.03.10  добавлены tpI,tpD,tpA
   //2.04      26.03.10  полная консоль
   //2.05      01.04.10  исправлено редактор PTYPE
   //                    добавлено FCLINE (FlowControlLine) для RS232
   //          08.04.10  переадресация и отправка буфера на одном шаге -убран костыль по 7F
   //          09.04.10  отказ от блокировки прерываний и флага FromOwner
   //          10.04.10  StackSize = $0300;FrameSize = $00C0 отключен сброс пароля по Idle
   //                    поправлен расчет КС с учетом новых параметров
   //                    скорость по Ethernet 38400
   //          11.04.10  буфера  по 512 байт
   //          19.04.10  буфера  по 255 байт - EndChartoModem




   h_tbl:array[0..22] of byte=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
            0,10,11,12,13,14,15);
   //TSlotMode=(smFree,smClient,smInProgress,smServer);//режим подключения текущего слота
   KSPDRESTOREName:array[TKSPDRESTORE] of String[6]=('GMODEM',        //пинкод,APN,логин,пароль
                                                     'BROKER',       //брокер,IP,порт,ID
                                                     'E_PORT',        //адрес сервера для подключения EPORT
                                                     'CONSOL',      //порт с консолью
                                                     'HARDNM',      //заводской номер КСПД
                                                     'STRBAL',      //строка USSD запроса баланса
                                                     'WRKTIM',   //зона работы клиента брокера
                                                     'ENCONS',   //флаги активности консолей по портам
                                                     'DRS232',    //порт назначения для RS232
                                                     'DRS485',    //порт назначения для RS485
                                                     'DETHER',    //порт назначения для EPORT
                                                     'DMODEM',    //порт назначения для MODEM
                                                     'B_RATE',     //скорость по RS232 и RS485
                                                     'PASWRD',     //пароль
                                                     'SERVER',     //сервер
                                                     'CPARAM');     //параметры)
   
   SlotModeName:array[TSlotMode] of String[6]=('Free  ','Client','Change','Server');
   SpeedNames:Array[TSpeedBaud] of String[5]=('2400 ','4800 ','9600 ','19200','38400','57600','115K ');
   SpeedWord:Array[TSpeedBaud] of word=(2400,4800,9600,19200,38400,57600,65500);
   //SpeedUBRR:Array[0..5] of byte=($CF,$67,$33,$19,$0C,$7);
   {$IFDEF OLDKWARZ}
   SpeedUBRR:Array[TSpeedBaud] of word=(207,103,51,25,12,8,3);
   {$ELSE}
   SpeedUBRR:Array[TSpeedBaud] of word=(191, 95,47,23,11,7,3);
   {$ENDIF}

   MaxCheckSMSCount:byte=3;
   //51 52 53 54 00 00 00 00 00 00 00 00 00 00 04 4A
   KMtestStrLen:byte=53;
   KMtestStr:string='RS485 51 52 53 54 00 00 000 00 00 00 00 00 00 04 4A';//53
   KMtestArr:array[1..16] of byte=($51,$52,$53,$54,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$04,$4A);
   cSpace:char=' ';
   cState:string='STATE';
   HexTable:array[0..15] of char=('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
   ParamTypeName:array[TTypeOfParam] of string[4]=('DISC','DS_T','IMPL','PKM5','FCLN','UNCN');
   BOOLNAME:array[0..1] of string[5]=('FALSE','TRUE ');
   FPNAME:array[ciMODEM..ciFREE] of string[8]=('[MDM_FP]','[485_FP]','[232_FP]','[ETH_FP]','[CON_FP]','[FRE_FP]');
   OWNERNAME:array[ciMODEM..ciFREE] of string[5]=('MODEM','RS485','RS232','ETHER','V_CON','FREE ');
    MessageBody:string='событие по параметру № x ';
    MessageTelNum :string='+70000000000';
   //---------------------------------------------------------------------------
   //                константы периода работы таймеров
   //---------------------------------------------------------------------------
   LedDelay : byte      =       20;       //Период обновления 5 раз в секунду
   StateSecondDelay : byte      =10;       //Период обновления 10 раз в секунду
   CheckImpulseDelay : byte      =20;       //Период обновления 10 раз в секунду
   OneMinuteDelay : word      = 6000;       //Период обновления 1 раз в минуту
   ThenMinuteDelay : word      = 60000;       //Период обновления 1 раз в 600сек = 10 мин
   FiveMinuteDelay : word      = 30000;       //Период обновления 1 раз в минуту
   HalfMinuteDelay : word     = 3000;       //Период обновления 2 раз в минуту
   TwnethSecDelay : word     = 2000;       //Период обновления 2 раз в минуту
   HalfHalfMinuteDelay : word = 1500;       //Период обновления 2 раз в минуту
   ThenSecDelay : word        = 1000;       //10 сек
   FiveSecDelay : word        = 500;       //10 сек
   ThreeSecDelay : word    = 300;       //Период обновления 3 секунды
   OneSecDelay : word      = 100;       //Период обновления 1 раз в секунду
   //---------------------------------------------------------------------------
   //                константы для работы с файловой системой
   //---------------------------------------------------------------------------
//   DirBuff       : byte    = 0;
//   DatBuff       : byte    = 1;
//   TrksBlock     : word    = DiskA_BlockSize div (SecTrk_A * 128);  // tracks per block
   //---------------------------------------------------------------------------
   //                константы для работы с COM портами
   //---------------------------------------------------------------------------

   InpBuffTimerDelay:byte     = 2;         //период проверки границы тишины входного пакета
   IOBuffTimerDelay:byte     =  5;         //период ответа границы тишины MainWork
   //---------------------------------------------------------------------------
   //                константы часов реального времени
   //---------------------------------------------------------------------------
   rtc        : byte      = %1101000;    // i2c address of ds1307..1338
   cBaseDate:longword=$259E9D80;
   mmm : array[1..12] of word = (0,31,59,90,120,151,181,212,243,273,304,334);
   UpperDayOfMonthDEC: array[0..12] of byte=(0,31,28,31,30,31,30,31,31,30,31,30,31);
   

{--------------------------------------------------------------}
{ Var Declarations }
{$EEPROM}
StructConst
  Stored_tmpArr:array[0..29] of byte=(1,2,3,4,5,6,7,8,9,0,
                                      1,2,3,4,5,6,7,8,9,0,
                                      1,2,3,4,5,6,7,8,9,0
                                        );              //защита - пустой массив
  Stored_PINCODE:string[4]='1234';
  Stored_Inet_AP:string[20]='internet.mts.ru     ';//точка подключения к интернет
  Stored_Inet_Login:string[10]='mts       ';//точка подключения к интернет
  Stored_Inet_Password:string[10]='mts       ';//точка подключения к интернет
  Stored_Inet_BROKER_IP:string[15]='xxx.xxx.xxx.xxx';//IP брокера
  Stored_Inet_BROKER_PORT:word=10003;                //порт брокера
  Stored_Inet_ID_HARDWARE:longword=0;                  //ID клиента
  Stored_TEL_NUM:string[12]=MessageTelNum;   //телефонный номер для отправки по умолчанию
  Stored_HARDNUM:longword=0;
  Stored_CUSD_BALANCE:string[5]='*100#';
  Stored_StartTimeZone:byte=8;                  //час начала подключения
  Stored_StopTimeZone:byte=25;                   //час окончания подключения
  StoredDefaultDestination:array[TCOMMIDX] of TCOMMIDX=(ciFree,ciFree,ciFree,ciFree,ciFree,ciFree);
  StoredEnableConsole:array[TCOMMIDX] of boolean=(False,False,True,False,True,False);  //куда я должен ответить по приходу ответа по данному каналу
  StoredDefaultBaud:array[ci485..ci232] of TSpeedBaud=(sb9600,sb38400);
  //куда я должен ответить по приходу ответа по данному каналу
  StoredDrySwitchersMask:byte=0;              //оставляем
  StoredDrySwitchersMode:byte=0;              //в резерве
  StoredV_CONSOLE:TCOMMIDX=ci232;
  //параметры пашиного контроллера
  Stored_Inet_REMOTE_IP:string[15]='xxx.xxx.xxx.xxx';//IP Ethernet в режиме не мастера - к примеру связь с КМД
  Stored_Inet_REMOTE_PORT:word=10001;                //порт Ethernet в режиме не мастера - к примеру связь с КМД
  Stored_Inet_LOCAL_IP:string[15]='xxx.xxx.xxx.xxx'; //собственный IP EPORT - если нет опции динамического получения IP
  Stored_Inet_MASK:string[15]='xxx.xxx.xxx.xxx';     //маска подсети
  Stored_Inet_GATEWAY:string[15]='xxx.xxx.xxx.xxx';     //маска подсети
  Stored_Inet_DYNAMIC_IP:boolean=False;              //
  Stored_SYSTEM_KS:word=$FFFF;                //контрольная сумма флеш
  StoredPwd:string[8]='12345678';             //пароль на конфигурирование
  Stored_Inet_SERVER_PORT:word=0;             //порт сервера 0-режим сервера не поддерживается
  //
  //по контролируемым параметрам
  //
  Stored_ActiveParam:array[1..MAxParam] of boolean=(False,False,False,False);
  Stored_ModeParam:array[1..MAxParam] of byte=(0,0,0,0);
  Stored_TypeOfParam:array[1..MAxParam] of TTypeOfParam=(tpD,tpD,tpD,tpD);
  Stored_NumOfParam:array[1..MAxParam] of byte=(1,2,3,4);
  Stored_MinParam:array[1..MAxParam] of integer=(0,0,0,0);
  Stored_MaxParam:array[1..MAxParam] of integer=(1,1,1,1);
  Stored_SMSMessageParam:array[1..MAxParam] of boolean=(False,False,False,False);
  Stored_StrMessageParam:array[1..MAxParam] of string[30]=(
           MessageBody,
           MessageBody,
           MessageBody,
           MessageBody);
  Stored_TelNumParam:array[1..MAxParam] of string[12]=(
           MessageTelNum,
           MessageTelNum,
           MessageTelNum,
           MessageTelNum);
  Stored_RTS_232:byte=0;//номер параметра сухого контакта дя управления потоком линии RS232
  Stored_KS:array[TKSPDRESTORE] of word=(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);//точки контрольных сумм параметров
//  Stored_SYSTEM_KS_ARR:Array[1..10] of word;
  

{$DATA}
var
   tmPX_E,tmpX_4,tmpX_2,tmpX_M:byte;   //tmPX
    //==========================================================================
    //               описание аппаратной части контроллера
    //==========================================================================
    //
    // Переключение прием передача RS485
    //
    Sw_485[@PortD, 4]          :bit;         //Бит переключения приемом передачей порта COM2
    //управление / состояние  адаптером Ethernet
    ETH_PRESENT[@PinD, 7]        :bit;         //бит состояния Ethernet
    ETH_CONTROL[@DDRD, 7]        :bit;         //бит состояния управления вводом выводом линии Ethernet
    SDCARD_PRESENT[@PinC, 2]     :bit;         //бит наличия SD карточки - необходимо подтянуть
    SDCARD_SELECT[@DDRC, 3]      :bit;         //бит выбора SD карту
    //
    // MMC
    //
    MMC_CS[@PortB, 6]          :bit;         //Бит управления сигналом CS
    MMC_WP[@PortB, 4]          :bit;         //Бит управления сигналом WP
    MMC_RST[@PortB, 5]         :bit;         //Бит управления сигналом RESET
    //
    // MODEM - модем
    //
    MODEM_RTC[@PortJ, 2]          :bit;         //Бит управления сигналом RTC MODEM модема
    MODEM_DTR[@PortJ, 5]          :bit;         //Бит управления сигналом DTR MODEM модема
    MODEM_IO13[@PortE, 4]         :bit;         //Бит управления сигналом JPIO13 MODEM модема
    MODEM_PWON[@PortE, 5]         :bit;         //Бит управления сигналом PWON MODEM модема
    MODEM_ROW4[@PortE, 7]         :bit;         //Бит управления сигналом ROW4 MODEM модема
    MODEM_IO10[@PinE, 6]          :bit;         //Бит состояния модема
    MODEM_IO11[@PinE, 3]          :bit;         //Бит управления IO11
    MODEM_CTS[@PinJ, 3]           :bit;
    MODEM_DSR[@PinJ, 4]           :bit;
    MODEM_RI[@PinJ, 6]            :bit;
    MODEM_DCD[@PinJ, 7]         :bit;
    //
    // Индикатор - светодиод красный
    //
    MessageLed[@PortG, 5]          :bit;         //Индикатор режима работы

    Led_1[@PortF, 4]        :bit;         //Бит управления светдиодами
    Led_2[@PortF, 5]        :bit;         //Бит управления светдиодами
    Led_3[@PortF, 6]        :bit;         //Бит управления светдиодами
    Led_4[@PortF, 7]        :bit;         //Бит управления светдиодами
    Led_5[@PortK, 0]        :bit;         //Бит управления светдиодами
    //
    // Сухие контакты
    //
    ISw_1[@PinC, 0]    :bit;          //Сухой Контакт 1  -входы
    ISw_2[@PinG, 1]    :bit;          //Сухой Контакт 4
    ISw_3[@PinG, 0]    :bit;          //Сухой Контакт 3
    ISw_4[@PinC, 1]    :bit;          //Сухой Контакт 2

    OSw_1[@PortC, 0]    :bit;          //Сухой Контакт 1 -выходы
    OSw_2[@PortG, 1]    :bit;          //Сухой Контакт 4
    OSw_3[@PortG, 0]    :bit;          //Сухой Контакт 3
    OSw_4[@PortC, 1]    :bit;          //Сухой Контакт 2

    DSw_1[@DDRC, 0]    :bit;          //Сухой Контакт 1 - направление
    DSw_2[@DDRG, 1]    :bit;          //Сухой Контакт 4
    DSw_3[@DDRG, 0]    :bit;          //Сухой Контакт 3
    DSw_4[@DDRC, 1]    :bit;          //Сухой Контакт 2
    
// в 69 версии   SW_1[@PinD, 6]    :bit;
//    SW_2[@PinD, 5]    :bit;
//с 1_69a
    SW_1[@PinD, 5]    :bit;
    SW_2[@PinD, 6]    :bit;
    XPORT1PRESENT  [@PinD, 7]    :bit;        //Присутствие +
    
{$IDATA}
var
    tmpCh2:string[2];                           //счетчик отправленных пакетов
    //
    // Переменные настроки режима связи MODEM
    //
    tmpArr:array[1..10] of byte;              //защита - пустой массив
    PINCODE:string[4];                        //ПИНКОД
    Inet_AP:string[20];//='internet.mts.ru ';//точка подключения к интернет
    Inet_Login:string[10];//='mts       ';   //точка подключения к интернет
    Inet_Password:string[10];//='mts       ';//точка подключения к интернет
    Inet_BROKER_IP:string[15];                //IP брокера
    Inet_BROKER_PORT:word;                    //Port брокера
    Inet_ID_HARDWARE:longword;                //ID клиента
    TMP_TEL_NUM:string[12];//='+79267687674'; //телефонный номер для отправки по умолчанию
    HARDNUM:longword;//=0;
    CUSD_BALANCE:string[5];
    StartTimeZone:byte;                       //час начала подключения
    StopTimeZone:byte;                        //час окончания подключения
    SYSTEM_KS:word;                           //контрольная сумма системной области c PINCODE до StopTimeZone
    V_CONSOLE:TCOMMIDX;                        //консоль по умолчанию
    CurXCOMM:TCOMMIDX;                        //текущий порт в операциях контроля буфера
    
    //параметры пашиного контроллера
    Inet_ETH_PRESENT:boolean;     //наличие платы EW-PORT
    Inet_REMOTE_IP:string[15];    //IP брокера
    tmp_Inet_REMOTE_IP:string[15];    //IP брокера
    Inet_REMOTE_PORT:word;        //Port брокера
    tmp_Inet_REMOTE_PORT:word;        //Port брокера
    Inet_LOCAL_IP:string[15];     //собственный IP EPORT - если нет опции динамического получения IP
    Inet_MASK:string[15];         //маска подсети
    Inet_GATEWAY:string[15];      //шлюз
    Inet_DYNAMIC_IP:boolean;      //динамический IP
    Inet_CLIENT_ACTIVE:boolean;   //запрос на активизацию
    Inet_CLIENT_STATE:boolean;    //активность клиента
    Inet_CLIENT_MUST_RECONNECTED:boolean;//ФЛАГ НЕОБХОДИМОСТИ ПЕРЕПОДКЛЮЧЕНИЯ К БРОКЕРУ
    Inet_CONNECT_STAGE_COUNT:byte;//счетчик времени ожидания подключения
    Inet_SERVER_PORT:word;        //номер порта сервера
    Inet_INTERNAL_IP:string[15];  //собственный IP модема выданный при активации GPRS контента в сети
    GPRSCONTENT_COUNT:byte;        //счетчик получения контента в течении часа
    GPRSCONTENT_ACTIVE:boolean;    //активность текущего контента


    
    FirstLedState:byte;                       //байт текущего режима работы
                                              //1-
    SecondLedState:byte;                      //1-инициа
    LightLedStep,LightLedCount:byte;          //вспомогательные переменные для индикации режимов работы
//---------------------------------------------------------------------
//Описание режимов подключения к брокеру
//---------------------------------------------------------------------
//                             StartTimeZone             StopTimeZone
//Режим                        Начало работы             Конец работы
//Работает с 6 до 19               6                          19
//Работает с 19 до 6              19                           6
//Работает круглые сутки          19                          19
//                                19                          29
//Не работает                     29                          29
//                                29                          19
//---------------------------------------------------------------------

    NowWorkStateTimeZone:boolean;             //текущее состояние по зоне подключения
    M_RepeatShiftCounter:word;                  //повтор подключения через x секунд
    E_RepeatShiftCounter:word;                  //повтор подключения через x секунд
    RepeatCounter:byte;                       //повтор подключения через x секунд
    DateTime_Val:STRING[17];                    //ТЕКУЩИЕ ДАТА И ВРЕМЯ
                                              //28.01.09_13:49:33



    //переменные временные - в которые разбирается СМС
    tmp_Inet_DYNAMIC_IP:boolean;
    tmp_Inet_AP:string[20];//='internet.mts.ru ';//точка подключения к интернет
    tmp_Inet_Login:string[10];//='mts       ';   //точка подключения к интернет
    tmp_Inet_Password:string[10];//='mts       ';//точка подключения к интернет
    tmp_Inet_BROKER_IP:string[15];                //IP брокера
    tmp_Inet_BROKER_PORT:word;                    //Port брокера
    tmp_Inet_ID_HARDWARE:longword;                //ID клиента
    CMCCRC:word;                                  //расчетная цифровая подпись

    BALANCE:string[15];                     //остаток на счете

    ID_HARDWARE [@Inet_ID_HARDWARE]:array[1..4] of byte;                //ID клиента
    ID_HARDNUM [@HARDNUM]:array[1..4] of byte;                //ID клиента
    OPERATOR:string[20];                      //оператор
    MODEM_NAME1:string[10];                   //имя модема 1
    MODEM_NAME2:string[10];                   //имя модема 2
    MODEM_REVIS:string[5];                   //имя модема 2
    MODEM_IMEI:string[15];                   //имя модема 2
    CSQ_VAL:string[2];                        //сигнал
    ParamState_VAL:string[MaxParam];          //параметры - состояние
    CSQ:byte;                                 //сигнал
    CSQMust_happened:boolean;                 //необходимо проверить сигнал
    IO10happened:boolean;
    // флаги активности различных
    SMSChecked:boolean;                       //СМС проверены
    GSMActive:boolean;                        //активность телефона в сетях GSM
    ContentActive:boolean;                    //активность контента
    GPRSActive:boolean;                       //активность MODEM сессии
    MWDog:word;                           //счетчик неответа от модема
    SocketActive:boolean;                     //активность сокетного соединения
    //будущие переключатели
    Switcher_1,OldSwitcher_1:boolean;                      //режим работы - в последующем джампер
    Switcher_2,OldSwitcher_2:boolean;                       //системный терминал зарегистрирован на 232 порт - в последующем джампер
    ERRORSIM:boolean;                         //ошибка СИМ
    ERRORSIMCount:byte;                       //счетчик заходов по еррорсим - если больше 1 то пин не вводится
    //
    DoublePack:boolean;                       //Двойной пакет Паши для КМ5
    ActualSpeed:array[1..2] of TSpeedBaud;          //текущая скорость обмена 0-2400, 1-4800, 2-9600 3-19200 4-38400 5-57600 6-115200
    PrevSpeed:array[1..2] of TSpeedBaud;            //предыдущая скорость скорость обмена 0-2400, 1-4800, 2-9600 3-19200 4-38400 5-57600 6-115200
                                      //по каналам 1 - RS85 2 - RS232

                                      
    //
    // входные буфера под каждый канал
    //
    //отладочная косоль
    //Ethernet буфер
    UBuff:array[0..UBufCount-1] of TUBuff;
    //буфера 485,232,modem
    XCOMM:array[ciMODEM..ciV_CON] of TCOMM;
    HandleMode:boolean;

    //
    // Входной и выходной буфер - порта COM2 - КМ5Net
    //
    ETimeOutVAlCount:byte;                            //счетчик количества неответов Ethernet - по нему судим о наличии последнего
    ModemIOBuffLastByte:byte;       //индекс последнего отправленного байта
    InputBuff_Console_CMD:string[20];                 //Буфер команды
    InputBuff_Console_Param1:string[128];             //Буфер параметра
    InputBuff_Console_LenParam1:byte;
    InputBuff_Console_Param2:string[128];             //Буфер параметра
    InputBuff_Console_LenParam2:byte;
    ModemTimeOut:byte;                                //время ожидания ответа от модема
    ModemTimeOutCount:byte;                           //счетчик таймаутов
    GlobalModemTimeOutCount:byte;                     //для перезагруза счетчик таймаутов
    EthernetTimeOut:byte;                             //время ожидания ответа из Ethernet
    EthernetTimeOutCount:byte;
    LedStep:byte;                                //время ожидания ответа от модема
    LedCounter:byte;                             //счетчик зажиганий
    LedStepper:byte;                             //счетчик зажиганий
    LedPauseCounter:byte;                           //счетчик паузы

    //
    // переменные для часов
    //
    PresetTime:boolean;
    NowCData:longword;                           //0004 2*2 - дата в числовом представлении как количество секунд с 1 января 1980 года
    DataBody:array[1..6] of byte;//95 register   //0008 2*3 - дата и время
    Second   [@DataBody[6]]:byte;
    Minute   [@DataBody[5]]:byte;
    Hour     [@DataBody[4]]:byte;
    Day      [@DataBody[3]]:byte;
    Month    [@DataBody[2]]:byte;
    Year     [@DataBody[1]]:byte;
    AVDB:array[1..6] of byte;
    tekSS   [@AVDB[6]]:byte;
    tekMM   [@AVDB[5]]:byte;
    tekH    [@AVDB[4]]:byte;
    tekD    [@AVDB[3]]:byte;
    tekM    [@AVDB[2]]:byte;
    tekY    [@AVDB[1]]:byte;
    DayOfWeek:byte;                               //день недели 0x1D1
    DayOfYear:word;                               //день года 0x1D3
    //
    // Временные переменные
    //
    BalanceStr:string[50];//строка
    tmpStr:string[8];
    tmpStr2:string[2];
    tmpStr16:string[16];
    CmdStr:string[255];
    ResStr:string[255];
    RSSNum:byte;//номер слота - откуда пришли данные в ResStrSlotNum
    UBRR0,UBRR1,UBRR2,UBRR3:integer;
    WritelnStr:string[128];//строка

    //
    // переменные состояния прибора
    //
    LastCheckBalance:word;//счетчик времени - на необходимость проверять СМС или баланс
    EthernetConnectCount:BYTE;//СЧЕТЧИК подключений к брокеру
    //---------------------------------------------------------------------------------
    // ШАГ В ТЕКУЩЕМ СТСОТЯНИИ
    // ДЛЯ КАЖДОЙ ПРОЦЕДУРЫ ОН БУДЕТ СОБСТВЕННЫЙ
    //---------------------------------------------------------------------------------
    HardwareCheckedStep:byte;
    SMSEngineMustWorkStep:byte;
    ServerMustWorkStep:byte;
    BrokerMustWorkStep:byte;
    

    TestReset:boolean;                         //источник вызывавший перезагруз процессора
    MTBNCount:byte;                             //счетчик 8байтовых ЭХО посылок
    ETBNCount:byte;                             //счетчик 8байтовых ЭХО посылок
    ONLINESEK:byte;                            //счетчик секунд в онлайн режиме
    ONLINEMIN:byte;                            //счетчик минут в онлайн режиме
    ONLINEhour:byte;                           //счетчик часов в онлайн режиме
    ONLINEDAYS:word;                           //счетчик суток
    RECONNCOUNT:word;                          //счетчик переподключений
    BadTime:boolean;                           //время сбитое
    IdleICQCount:byte;                         //счетчик тишины в сервисном режиме
                                               //если более часу тихо - активируем проверку уровня сигнала и СМС
    Timer1,SMSSendTimer,E_MinuteTimer,M_MinuteTimer,M2_MinuteTimer:SysTimer;
    checkIOTimer,CheckInpBuffTimer,HourTimer,StateTimer,CheckImpulseTimer,TimeOut: SysTimer8;
    // application related variables
    TestLedCounter   : byte;   //счетчик бегущих огней
    SMSSended        : boolean;
    CRC              : word;//контрольная сумма буфера
    SMSMustDeleted   :boolean;
    tmpLW            :longword;
    tmpLWBody[@tmpLW]:array[1..4] of byte;
    MasterModem      :boolean;   //флаг текущего активного устройства
    EnableCSD        :boolean;   //разрешение на сьем трубки (режим CSD)
    DEBUG            :byte;      //уровни отладки
    M33GSubVer       :byte;      //подверсия модема     1.04 = 4      1.10 = 10
    ActualPwd:string[8];//пароль на конфигурирование
    tmp_Pwd:string[8];//пароль на конфигурирование
    dropContent:boolean;//сбрасываем контент перед анализом
    x:TCOMMIDX;
    y:TSpeedBaud;
    good:boolean;
    ShortMsg:boolean;//короткие сообщения
    ForceM23:boolean;//жесткий М23
    ID2BROKRepeat:byte;//счетчик попыток регистрации
    CheckSocketRepeat:byte;//счетчик ожидания стабилизации сессии
    RecentChange:boolean;//флаг еще теплого обмена
    //
    //   переменные для работы с флеш
    //
    j:byte;
    ActualTypeOfSensors:array[0..3] of byte;    //0-дискрет 1-DS18B20
    ActualValueOfSensors:array[0..3] of integer;
    ActualTypeOfArhives:array[0..9] of byte;    //0-нет 1-общесистемный
    FPNUM:word;//0..4095
    FPADDR:word;//0..512
    FPCount:word;//0..512
    //
    //   0 слот инициализиируем для прозрачных запросов
    //   1..5 в зависимости от режима (клиент/сервер)
    //
    SLOT:array[0..6] of TSlot;  //текущий режим подключения слотов 0 - чистый поток 1..5 м2м потоки 6
    SuperVisorStep:byte;        //шаги супервизора
    i:byte;                     //переменная для цикла
    //
    KSPDCONTROL:TBitSetKSPDCONTROL;   //      - регистр управления
    wKSPDCONTROL[@KSPDCONTROL]:word;
    
    KSPDSTATE:TBitSetKSPDSTATE;//        - регистр состояния
    wKSPDSTATE[@KSPDSTATE]:word;
    
    KSPDERROR:TBitSetKSPDERROR;
    wKSPDERROR[@KSPDERROR]:word;

    KSPDRESTORE:TBitSetKSPDRESTORE;
    wKSPDRESTORE[@KSPDRESTORE]:word;

    TimeCounterErrorKSPD:word;//время нахождения КСПД в режиме критических ошибок

    //контроллируемые параметры
    PARAMS:array[1..MAxParam] of TParam;     //описание параметров
    SMSEvent:array[1..MAxParam] of TEvent;  //защелчки для отработки события
    BROKEvent:array[1..MAxParam] of TEvent; //защелчки для отработки события
    RTS_232:byte;                           //номер параметра 0-отсутствует 1..4 номер сухого контакта
    CheckParamTickCount:byte;                //счетчик секунд- необходим для получения усредненных значений
    temp:array[1..MaxParam] of word;                               //переменная для чтения температуры
    I2HStr:String[4];//строка для преобразования int в Hex
    B2HStr:String[2];//строка для преобразования byte в Hex

procedure MyIntToHex(AInt:integer);
begin
   I2HStr[0]:=char(4);
   I2HStr[1]:=HexTable[(Hi(AInt) shr 4)];
   I2HStr[2]:=HexTable[(Hi(AInt) and $0F)];
   I2HStr[3]:=HexTable[(Lo(AInt) shr 4)];
   I2HStr[4]:=HexTable[(Lo(AInt) and $0F)];
end;

procedure MyByteToHex(AByte:byte);
begin
   B2HStr[0]:=char(2);
   B2HStr[1]:=HexTable[(AByte shr 4)];
   B2HStr[2]:=HexTable[(AByte and $0F)];
end;


{--------------------------FlowControl---------------------------------}
procedure SetRTS(AValue:boolean);
begin
   case RTS_232 of
   1:
     DSw_1:=False;OSw_1:=True;//включаем подтягивающий резистор
     if ISw_1 then//проверяем значение на входе - если 0 - КЗ- ничего не делаем
        DSw_1:=True;  //на выход
        OSw_1:=AValue;//устанавливаем значение
         lo(temp[1]):=ord(AValue);
     endif;
   |
   2:
     DSw_2:=False;OSw_2:=True;//включаем подтягивающий резистор
     if ISw_2 then//проверяем значение на входе - если 0 - КЗ- ничего не делаем
        DSw_2:=True;  //на выход
        OSw_2:=AValue;//устанавливаем значение
        lo(temp[2]):=ord(AValue);
     endif;
   |
   3:
     DSw_3:=False;OSw_3:=True;//включаем подтягивающий резистор
     if ISw_3 then//проверяем значение на входе - если 0 - КЗ- ничего не делаем
        DSw_3:=True;  //на выход
        OSw_3:=AValue;//устанавливаем значение
        lo(temp[3]):=ord(AValue);
     endif;
   |
   4:
     DSw_4:=False;OSw_4:=True;//включаем подтягивающий резистор
     if ISw_4 then//проверяем значение на входе - если 0 - КЗ- ничего не делаем
        DSw_4:=True;  //на выход
        OSw_4:=AValue;//устанавливаем значение
        lo(temp[4]):=ord(AValue);
     endif;
   |
   endcase;
end;

{--------------------------1-Wire Code---------------------------------}
//
//  Выводит уровень сигнала на 1-Wire
//
procedure Write_Ov_Level(AValue:boolean;NumParam:byte);
begin
   case NumParam of
   1:
       DSw_1:=True;//переключаем на прием
       OSw_1:=AValue;//подтягиваем к 1
   |
   2:
       DSw_2:=True;//переключаем на прием
       OSw_2:=AValue;//подтягиваем к 1
   |
   3:
       DSw_3:=True;//переключаем на прием
       OSw_3:=AValue;//подтягиваем к 1
   |
   4:
       DSw_4:=True;//переключаем на прием
       OSw_4:=AValue;//подтягиваем к 1
   |
   endcase;
end;

//
// Читает состояние сигнала на 1-Wire
//
function Read_Ov_Level(NumParam:byte):boolean;
begin
   case NumParam of
   1:
       DSw_1:=False;//переключаем на прием
       OSw_1:=True;//подтягиваем к 1
       return(ISw_1);//если линия не закорочена - датчик возможно поискать
   |
   2:
       DSw_2:=False;//переключаем на прием
       OSw_2:=True;//подтягиваем к 1
       return(ISw_2);//если линия не закорочена - датчик возможно поискать
   |
   3:
       DSw_3:=False;//переключаем на прием
       OSw_3:=True;//подтягиваем к 1
       return(ISw_3);//если линия не закорочена - датчик возможно поискать
   |
   4:
       DSw_4:=False;//переключаем на прием
       OSw_4:=True;//подтягиваем к 1
       return(ISw_4);//если линия не закорочена - датчик возможно поискать
   |
   else
       return(False);
   endcase;
end;


function OW_Reset(NumParam:byte):boolean;
var i:integer;
    DS18B20Present:boolean;
begin
  DS18B20Present:=False;
  //формируем импульс сброса
  if Read_Ov_Level(NumParam) then
     udelay(49);    //480usek минимум
     Write_Ov_Level(False,NumParam);
     udelay(49);    //480usek минимум
     Read_Ov_Level(NumParam);
     //ожидаем импульс присутствия
     for i:=1 to 30 do
         if not Read_Ov_Level(NumParam) then
            DS18B20Present:=True;
            break;
         endif;
         udelay_1(1);
     endfor;
     if DS18B20Present then
        //дожидаем окончания импульса присутствия
        while not Read_Ov_Level(NumParam) do
           udelay_1(1);
        endwhile;
     endif;
  endif;
  return(DS18B20Present);
end;


//Запись бита
procedure OW_write_bit(x:boolean;NumParam:byte);
begin
   Write_Ov_Level(x,NumParam);//записываем бит
   udelay_1(60);
   Read_Ov_Level(NumParam);//восстанавливаем 1
   udelay_1(2);
   Write_Ov_Level(False,(NumParam)); //формируем импульс восстановления
   udelay_1(2);
end;

//Чтение бита
function OW_read_bit(NumParam:byte):boolean;
var res:boolean;
begin
   Write_Ov_Level(False,NumParam); //формируем импульс восстановления
   udelay_1(2);
   Read_Ov_Level(NumParam);//восстанавливаем 1
   udelay_1(15);
   res:=Read_Ov_Level(NumParam);
   udelay_1(45);
   return(res);
end;


//Запись байта
procedure OW_write_byte(NumParam,command:byte);
var i:byte;
begin
  Write_Ov_Level(False,NumParam); //формируем импульс восстановления
  udelay_1(15);
  for i:=0 to 7 do
      OW_write_bit((command and byte(1 shl i)) <> 0,NumParam);
  endfor;
  Read_Ov_Level(NumParam);//восстанавливаем 1
end;

//чтение байта
function OW_read_byte(NumParam:byte):byte;
var i:byte;
    res:byte;
begin
   Write_Ov_Level(False,NumParam); //формируем импульс восстановления
   udelay_1(13);
   res:=0;
   for i:=0 to 7 do
       if OW_read_bit(NumParam) then
          res := res or (1 shl i);
       endif;
   endfor;
  return(res);
end;



{-----------------------DS1821 Code-------------------------------------}
function

procedure Read_Temperature(NumParam:byte);
var j:byte;
begin
  Ow_Reset(NumParam);
  OW_write_byte(NumParam,$CC);       // Issue command SKIP_ROM
  OW_write_byte(NumParam,$BE);       // Issue command READ_SCRATCHPAD
  j    := OW_read_byte(NumParam);     // Get temperature LSB
  temp[NumParam] := Word(OW_read_byte(NumParam));     // Get temperature MSB
  temp[NumParam] := temp[NumParam] shl 8;
  temp[NumParam] := temp[NumParam] + word(j);             // Form the 2byte variable
  Ow_Reset(NumParam);            // Onewire reset signal
  OW_write_byte(NumParam,$CC);       // Issue command SKIP_ROM
  OW_write_byte(NumParam,$44);       // Issue command CONVERT_T
end;


//
// Чтение значения АЦП
//
procedure Read_ADC(NumParam:byte);
var neg:boolean;
    dig:integer;
begin
  Read_Temperature(NumParam);
  neg:=(temp[NumParam] and $8000)<>0;
  if neg then
     dig:=Round(-6.25*Float($7FF-(temp[NumParam] and $7FF)+1));
  else
     dig:=Round(Float(temp[NumParam])*6.25);
  endif;
  Params[NumParam].CurVal:=dig;
end;


{--------------------------------------------------------------}
{ functions }
procedure MainWork; forward;


procedure CalcCRC(AValue:byte);
var j:byte;
begin
     CRC:=(CRC div 256)*256+((CRC mod 256) xor word(AValue));
     for j := 0 to 7 do
         if (CRC and 1) = 1 then
            CRC:=(CRC shr 1) xor $a001;
         else
            CRC:=CRC shr 1;
         endif;
     endfor;
end;

procedure WriteToRS485(bh:byte);
begin
     SerOut2(bh);
     while NOT UCSR1A.5 do//UDRE
           nop;
     endwhile;
     while NOT UCSR1A.6 do //TXC
           nop;
     endwhile;
     UCSR1A.6:=True;
end;




procedure WriteCon(ADest:TCOMMIDX; AStr:string[5]);
var i,len:byte;
begin
     case aDest of
        ciEthernet: Write(SerOut,AStr);|
        ci485:
          Sw_485:=True;
          udelay(5);
           len:=length(AStr);
           for i:=1 to Len do
              WriteToRS485(ord(AStr[i]));
           endfor;
          udelay(5);
          Sw_485:=False;
           |
        ci232: Write(SerOut3,AStr);|
        ciMODEM: Write(SerOut4,AStr);|
     endcase;
end;

procedure WriteConCh(ADest:TCOMMIDX; Ch:Char);
begin
     case aDest of
        ciEthernet: SerOut(Ch);|
        ci485:
          Sw_485:=True;
          udelay(5);
          WriteToRS485(ord(Ch));
          udelay(5);
          Sw_485:=False;
          |
        ci232: SerOut3(Ch);|
        ciMODEM: SerOut4(Ch);|
     endcase;
end;

//
//  задаем прескалер на 8 секунд
//
procedure WDT_Prescaler_Change;
begin
  asm;
    cli
    wdr
    LDI    r16,wdtcsr
    ori    r16,$18//WDCE,WDE
    sts     WDTCSR, r16
    ldi    r16,$29//WDP3,WDE,WDP0
    sts     WDTCSR, r16
    sei
  endasm;
end;



procedure WDT_off;
begin
  asm;
  //; Turn off global interrupt
  cli
  //; Reset Watchdog Timer
  wdr
  ldi    r16, MCUSR
  andi  r16, $F7// Clear WDRF in MCUSR
  sts   MCUSR, r16
  //Write logical one to WDCE and WDE
  //Keep old prescaler setting to prevent unintentional time-out
  ldi   r16, WDTCSR
  ori   r16, $18//WDCE,WDE
  sts WDTCSR, r16
  //Turn off WDT
  ldi   r16,0
  sts   WDTCSR, r16
  //Turn on global interrupt
  sei
  endasm;
end;


procedure WatchDogTrigger;
begin
    if (not TestReset) then
       asm;
       wdr
      endasm;
    endif;
end;

procedure WriteLnCon(ADest:TCOMMIDX);
var aLen,i:byte;
begin
     aLen:=Length(WritelnStr);
     if aDest=ciV_CON then
       //
       // не реализовано
       //
     else
        case aDest of
             ciEthernet: Writeln(SerOut);|
             ci485:
               Sw_485:=True;
               udelay(5);
               WriteToRS485(13);
               WriteToRS485(10);
               udelay(5);
               Sw_485:=False;
               |
             ci232: WriteLn(SerOut3);|
             ciMODEM: Writeln(SerOut4);|
        endcase;
        for i:=1 to aLen do
          if (i and 8)=8 then WatchDogTrigger; endif;
          case aDest of
             ciEthernet: SerOut(WritelnStr[i]);|
             ci485:
               Sw_485:=True;
               udelay(5);
               WriteToRS485(ord(WritelnStr[i]));
               udelay(5);
               Sw_485:=False;
               |
             ci232: SerOut3(WritelnStr[i]);|
             ciMODEM: SerOut4(WritelnStr[i]);|
          endcase;
        endfor;
     endif;
end;


function CompareStr(AStr,SubStr:string[20]):boolean;
var aStrLen,ASubStrLen,i:byte;
begin
   ASubStrLen:=Length(SubStr);
   aStrLen:=Length(AStr);
   if aStrLen<=aSubStrLen then
     for i:=1 to (ASubStrLen and $0F) do
       //пробелы не сравниваю
       WatchDogTrigger;
       if SubStr[i]<>' ' then
        if AStr[i]<>SubStr[i] then
          return(False);
          break;
        endif;
       endif;
     endfor;
   else
     return(False);
   endif;
   return(True);
end;


//
// процедура устанавливает переменную ks_ACCESS_EN in KSPDSTATE в соответствии с текущим паролем
//
procedure CheckAccess;
begin
  if (HardNum=0) or CompareStr(tmp_Pwd,ActualPwd) or CompareStr(tmp_Pwd,'mabuka') then
     Incl(KSPDSTATE,ks_ACCESS_EN);
  else
     Excl(KSPDSTATE,ks_ACCESS_EN);
  endif;
end;

procedure VAR_RESTORE(AKR:TKSPDRESTORE);
begin
  case AKR of
  kr_CONSOLE:
    V_CONSOLE:=StoredV_CONSOLE;
  |
  kr_GMODEM:
    PINCODE:=Stored_PINCODE;//:string[4]='1234';
    Inet_AP:=Stored_Inet_AP;//:string[20]='internet.mts.ru     ';//точка подключения к интернет
    Inet_Login:=Stored_Inet_Login;//:string[10]='mts       ';//точка подключения к интернет
    Inet_Password:=Stored_Inet_Password;//:string[10]='mts       ';//точка подключения к интернет
  |
  kr_BROKER:
    Inet_ID_HARDWARE:=Stored_Inet_ID_HARDWARE;
    Inet_BROKER_IP:=Stored_Inet_BROKER_IP;//:='89.207.73.52';             //IP брокера
    Inet_BROKER_PORT:=Stored_Inet_BROKER_PORT;//:=10003;                    //Port брокера
  |
  kr_EPORT:
    Inet_REMOTE_IP:=Stored_Inet_REMOTE_IP;//:='89.207.73.52';             //IP брокера
    Inet_REMOTE_PORT:=Stored_Inet_REMOTE_PORT;//:=10003;                    //Port брокера
    Inet_LOCAL_IP:=Stored_Inet_LOCAL_IP;
    Inet_MASK:=Stored_Inet_MASK;
    Inet_GATEWAY:=Stored_Inet_GATEWAY;
  |
  kr_HARDNUM:
    HARDNUM:=Stored_HARDNUM;                        //ID HARDWARE
  |
  kr_BALANCE:
    CUSD_BALANCE:=Stored_CUSD_BALANCE;
  |
  kr_WRKTIM:
    StartTimeZone:=Stored_StartTimeZone;
    StopTimeZone:=Stored_StopTimeZone;
  |
  kr_PASSWORD:
    ActualPwd:=StoredPwd;//восстанавливаем пароль
  |
  kr_ENCONSOLE:
    //восстанавливаем назначение по умолчанию
    For x:=ciMODEM to ciEthernet do
       XCOMM[x].EnableConsole:=StoredEnableConsole[x];
    endfor;
  |
  kr_DESTRS232:
    XCOMM[ci232].DefaultDestination:=StoredDefaultDestination[ci232];
  |
  kr_DESTRS485:
    XCOMM[ci485].DefaultDestination:=StoredDefaultDestination[ci485];
  |
  kr_DESTETHER:
    XCOMM[ciEthernet].DefaultDestination:=StoredDefaultDestination[ciEthernet];
  |
  kr_DESTMODEM:
    XCOMM[ciModem].DefaultDestination:=StoredDefaultDestination[ciModem];
  |
  kr_BAUDRATE:
    XCOMM[ci232].DefaultBaud:=StoredDefaultBaud[ci232];
    XCOMM[ci485].DefaultBaud:=StoredDefaultBaud[ci485];
  |
  kr_SERVER:
    Inet_SERVER_PORT:=Stored_Inet_SERVER_PORT;
  |
  kr_PARAM:
    for i:=1 to MAxParam do
              WatchDogTrigger;
              Params[i].Active:=Stored_ActiveParam[i];
              Params[i].Mode:=Stored_ModeParam[i];
              Params[i].TypeOfParam:=Stored_TypeOfParam[i];
              if Params[i].TypeOfParam=tpP then
                 //************************************************************************
                 //только для интерфейсных переменных разрешается выставлять номер параметра
                 //для остальных tpD,tpA,tpI - NumParam фиксированное число от 1..4
                 //соответствующее номеру реального сухого контакта
                 //************************************************************************
                 Params[i].NumParam:=Stored_NumOfParam[i];
              else
                 Params[i].NumParam:=i;
              endif;
              Params[i].MinVal:=Stored_MinParam[i];
              WatchDogTrigger;
              Params[i].MaxVal:=Stored_MaxParam[i];
              Params[i].SMSMessage:=Stored_SMSMessageParam[i];
              Params[i].StrMsg:=Stored_StrMessageParam[i];
              Params[i].TelNum:=Stored_TelNumParam[i];
    endfor;
    RTS_232:=Stored_RTS_232;
  |
  endcase;
  Excl(KSPDRESTORE,AKR);
end;

//
// Проверяет систему и восстанавливает ее
//
procedure SystemRestore;
var KR:TKSPDRESTORE;
begin
  if wKSPDRESTORE=0 then
     WritelnStr:='ALL VARIABLES GOOD!';WriteLnCon(V_CONSOLE);
  else
     for KR:=kr_CONSOLE to kr_PARAM do
         if KR in KSPDRESTORE then
            if Debug <> 0 then
               WritelnStr:='RESTORE VARIABLE:'+KSPDRESTORENAME[KR];WriteLnCon(V_CONSOLE);
            endif;
            VAR_RESTORE(KR);
         endif;
     endfor;
  endif;
end;

function CheckSystemKS(MustStore:boolean):boolean;
var i,j,k:byte;
begin
   CRC:=$FFFF;
   //==================CONSOLE==============================
   CalcCRC(ord(V_CONSOLE));
   if CRC=Stored_KS[kr_CONSOLE] then Excl(KSPDRESTORE,kr_CONSOLE);
                                else Incl(KSPDRESTORE,kr_CONSOLE);
                                     CRC:=Stored_KS[kr_CONSOLE];endif;
   //====================ТЕЛЕФОН===========================
   for i:=1 to 4 do
             CalcCRC(ord(PINCODE[i]));
   endfor;
   j:=Length(Inet_AP);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Inet_AP[i]));
   endfor;
   j:=Length(Inet_Login);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Inet_Login[i]));
   endfor;
   j:=Length(Inet_Password);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Inet_Password[i]));
   endfor;
   if CRC=Stored_KS[kr_GMODEM] then Excl(KSPDRESTORE,kr_GMODEM);
                              else Incl(KSPDRESTORE,kr_GMODEM);
                                   CRC:=Stored_KS[kr_GMODEM];endif;
   //==================BROKER==============================
   tmpLW:=Inet_ID_HARDWARE;
   for i:=1 to 4 do
             WatchDogTrigger;
             CalcCRC(tmpLWBody[i]);
   endfor;
   j:=Length(Inet_BROKER_IP);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Inet_BROKER_IP[i]));
   endfor;
   CalcCRC(Lo(Inet_BROKER_PORT));
   CalcCRC(Hi(Inet_BROKER_PORT));
   if CRC=Stored_KS[kr_BROKER] then Excl(KSPDRESTORE,kr_BROKER);
                               else Incl(KSPDRESTORE,kr_BROKER);
                                    CRC:=Stored_KS[kr_BROKER];endif;
   //==================EPORT===============================
   j:=Length(Inet_REMOTE_IP);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Inet_REMOTE_IP[i]));
   endfor;
   CalcCRC(Lo(Inet_REMOTE_PORT));
   CalcCRC(Hi(Inet_REMOTE_PORT));

   j:=Length(Inet_LOCAL_IP);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Inet_LOCAL_IP[i]));
   endfor;
   j:=Length(Inet_MASK);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Inet_MASK[i]));
   endfor;
   j:=Length(Inet_GATEWAY);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Inet_GATEWAY[i]));
   endfor;
   CalcCRC(ORD(Inet_DYNAMIC_IP));
   if CRC=Stored_KS[kr_EPORT] then Excl(KSPDRESTORE,kr_EPORT);
                              else Incl(KSPDRESTORE,kr_EPORT);
                                   CRC:=Stored_KS[kr_EPORT];endif;
   //==================HARDNUM=============================
   tmpLW:=HARDNUM;
   for i:=1 to 4 do
             WatchDogTrigger;
             CalcCRC(tmpLWBody[i]);
   endfor;
   if CRC=Stored_KS[kr_HARDNUM] then Excl(KSPDRESTORE,kr_HARDNUM);
                                else Incl(KSPDRESTORE,kr_HARDNUM);
                                     CRC:=Stored_KS[kr_HARDNUM];endif;
   //==================BALANCE=============================
   for i:=1 to 5 do
             WatchDogTrigger;
             CalcCRC(ord(CUSD_BALANCE[i]));
   endfor;
   if CRC=Stored_KS[kr_BALANCE] then Excl(KSPDRESTORE,kr_BALANCE);
                                else Incl(KSPDRESTORE,kr_BALANCE);
                                     CRC:=Stored_KS[kr_BALANCE];endif;
   //==================STARTSTOPZONE=======================
   CalcCRC(StartTimeZone);
   CalcCRC(StopTimeZone);
   if CRC=Stored_KS[kr_WRKTIM]
              then Excl(KSPDRESTORE,kr_WRKTIM);
              else Incl(KSPDRESTORE,kr_WRKTIM);
                   CRC:=Stored_KS[kr_WRKTIM];endif;
   //==================ENABLE CONSOLE======================
   CalcCRC(ord(XCOMM[ci232].EnableConsole));
   CalcCRC(ord(XCOMM[ci485].EnableConsole));
   CalcCRC(ord(XCOMM[ciEthernet].EnableConsole));
   CalcCRC(ord(XCOMM[ciModem].EnableConsole));
   WatchDogTrigger;
   if CRC=Stored_KS[kr_ENCONSOLE] then Excl(KSPDRESTORE,kr_ENCONSOLE);
                                  else Incl(KSPDRESTORE,kr_ENCONSOLE);
                                       CRC:=Stored_KS[kr_ENCONSOLE];endif;
   //==================DESTINATION RS232===================
   CalcCRC(ord(XCOMM[ci232].DefaultDestination));
   if CRC=Stored_KS[kr_DESTRS232] then Excl(KSPDRESTORE,kr_DESTRS232);
                                  else Incl(KSPDRESTORE,kr_DESTRS232);
                                       CRC:=Stored_KS[kr_DESTRS232];endif;
   //==================DESTINATION RS485===================
   CalcCRC(ord(XCOMM[ci485].DefaultDestination));
   if CRC=Stored_KS[kr_DESTRS485] then Excl(KSPDRESTORE,kr_DESTRS485);
                                  else Incl(KSPDRESTORE,kr_DESTRS485);
                                       CRC:=Stored_KS[kr_DESTRS485];endif;
   //==================DESTINATION ETHERNET================
   CalcCRC(ord(XCOMM[ciEthernet].DefaultDestination));
   if CRC=Stored_KS[kr_DESTETHER] then Excl(KSPDRESTORE,kr_DESTETHER);
                                  else Incl(KSPDRESTORE,kr_DESTETHER);
                                       CRC:=Stored_KS[kr_DESTETHER];endif;
   //==================DESTINATION MODEM===================
   CalcCRC(ord(XCOMM[ciModem].DefaultDestination));
   if CRC=Stored_KS[kr_DESTMODEM] then Excl(KSPDRESTORE,kr_DESTMODEM);
                              else Incl(KSPDRESTORE,kr_DESTMODEM);
                                   CRC:=Stored_KS[kr_DESTMODEM];endif;
   //==================DEFAULT BAUDRATE====================
   CalcCRC(ord(XCOMM[ci485].DefaultBaud));
   CalcCRC(ord(XCOMM[ci232].DefaultBaud));
   WatchDogTrigger;
   if CRC=Stored_KS[kr_BAUDRATE] then Excl(KSPDRESTORE,kr_BAUDRATE);
                                 else Incl(KSPDRESTORE,kr_BAUDRATE);
                                      CRC:=Stored_KS[kr_BAUDRATE];endif;
   //==================PASSWORD============================
   j:=Length(ActualPwd);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(ActualPwd[i]));
   endfor;
   if CRC=Stored_KS[kr_PASSWORD] then Excl(KSPDRESTORE,kr_PASSWORD);
                                 else Incl(KSPDRESTORE,kr_PASSWORD);
                                      CRC:=Stored_KS[kr_PASSWORD];endif;
   //==================SERVER==============================
   CalcCRC(Lo(Inet_SERVER_PORT));
   CalcCRC(Hi(Inet_SERVER_PORT));
   if CRC=Stored_KS[kr_SERVER] then Excl(KSPDRESTORE,kr_SERVER);
                               else Incl(KSPDRESTORE,kr_SERVER);
                                    CRC:=Stored_KS[kr_SERVER];endif;
   //==================PARAMETERS==============================
   for i:=1 to MAxParam do
             WatchDogTrigger;
             CalcCRC(ord(params[i].Active));
             CalcCRC(params[i].Mode);
             CalcCRC(ord(Params[i].TypeOfParam));
             CalcCRC(params[i].NumParam);
             CalcCRC(Lo(params[i].MinVal));
             CalcCRC(Hi(params[i].MinVal));
             WatchDogTrigger;
             CalcCRC(Lo(params[i].MaxVal));
             CalcCRC(Hi(params[i].MaxVal));
             WatchDogTrigger;
             CalcCRC(ord(params[i].SMSMessage));
             j:=length(params[i].StrMsg);
             for k:=1 to j do
                       WatchDogTrigger;
                       CalcCRC(ord(params[i].StrMsg[k]));
             endfor;
             j:=length(params[i].TelNum);
             for k:=1 to j do
                       WatchDogTrigger;
                       CalcCRC(ord(params[i].TelNum[k]));
             endfor;
             CalcCRC(RTS_232);
   endfor;
   if CRC=Stored_KS[kr_PARAM] then Excl(KSPDRESTORE,kr_PARAM);
                              else Incl(KSPDRESTORE,kr_PARAM);
                                   CRC:=Stored_KS[kr_PARAM];endif;
   if MustStore then
      SYSTEM_KS:=CRC;                         //контрольная сумма флеш
   endif;
   return(SYSTEM_KS=CRC);
end;


function CheckStoredSystemKS(MustStored:boolean):boolean;
var i,j,k:byte;
begin
   CRC:=$FFFF;
   //==================CONSOLE==============================
   CalcCRC(ord(StoredV_CONSOLE));
   if MustStored then Stored_KS[kr_CONSOLE]:=CRC;endif;
   //====================ТЕЛЕФОН===========================
   for i:=1 to 4 do
             WatchDogTrigger;
             CalcCRC(ord(Stored_PINCODE[i]));
   endfor;
   j:=Length(Stored_Inet_AP);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Stored_Inet_AP[i]));
   endfor;
   j:=Length(Stored_Inet_Login);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Stored_Inet_Login[i]));
   endfor;
   j:=Length(Stored_Inet_Password);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Stored_Inet_Password[i]));
   endfor;
   if MustStored then Stored_KS[kr_GMODEM]:=CRC;endif;//
   //==================BROKER==============================
   tmpLW:=Stored_Inet_ID_HARDWARE;
   for i:=1 to 4 do
             WatchDogTrigger;
             CalcCRC(tmpLWBody[i]);
   endfor;
   j:=Length(Stored_Inet_BROKER_IP);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Stored_Inet_BROKER_IP[i]));
   endfor;
   CalcCRC(Lo(Stored_Inet_BROKER_PORT));
   CalcCRC(Hi(Stored_Inet_BROKER_PORT));
   if MustStored then Stored_KS[kr_BROKER]:=CRC;endif;
   //==================EPORT===============================
   j:=Length(Stored_Inet_REMOTE_IP);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Stored_Inet_REMOTE_IP[i]));
   endfor;
   CalcCRC(Lo(Stored_Inet_REMOTE_PORT));
   CalcCRC(Hi(Stored_Inet_REMOTE_PORT));
   j:=Length(Stored_Inet_LOCAL_IP);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Stored_Inet_LOCAL_IP[i]));
   endfor;
   j:=Length(Stored_Inet_MASK);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Stored_Inet_MASK[i]));
   endfor;
   j:=Length(Stored_Inet_GATEWAY);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(Stored_Inet_GATEWAY[i]));
   endfor;
   CalcCRC(ORD(Stored_Inet_DYNAMIC_IP));
   if MustStored then Stored_KS[kr_EPORT]:=CRC;endif;
   //==================HARDNUM=============================
   tmpLW:=Stored_HARDNUM;
   for i:=1 to 4 do
             WatchDogTrigger;
             CalcCRC(tmpLWBody[i]);
   endfor;
   if MustStored then Stored_KS[kr_HARDNUM]:=CRC;endif;
   //==================BALANCE=============================
   for i:=1 to 5 do
             WatchDogTrigger;
             CalcCRC(ord(Stored_CUSD_BALANCE[i]));
   endfor;
   if MustStored then Stored_KS[kr_BALANCE]:=CRC;endif;
   //==================STARTSTOPZONE=======================
   CalcCRC(Stored_StartTimeZone);
   CalcCRC(Stored_StopTimeZone);
   if MustStored then Stored_KS[kr_WRKTIM]:=CRC;endif;
   //==================ENABLE CONSOLE======================
   CalcCRC(ord(StoredEnableConsole[ci232]));
   CalcCRC(ord(StoredEnableConsole[ci485]));
   CalcCRC(ord(StoredEnableConsole[ciEthernet]));
   CalcCRC(ord(StoredEnableConsole[ciModem]));
   if MustStored then Stored_KS[kr_ENCONSOLE]:=CRC;endif;
   //==================DESTINATION RS232===================
   CalcCRC(ord(StoredDefaultDestination[ci232]));
   if MustStored then Stored_KS[kr_DESTRS232]:=CRC;endif;
   //==================DESTINATION RS485===================
   CalcCRC(ord(StoredDefaultDestination[ci485]));
   if MustStored then Stored_KS[kr_DESTRS485]:=CRC;endif;
   //==================DESTINATION ETHERNET================
   CalcCRC(ord(StoredDefaultDestination[ciEthernet]));
   if MustStored then Stored_KS[kr_DESTETHER]:=CRC;endif;
   //==================DESTINATION MODEM===================
   CalcCRC(ord(StoredDefaultDestination[ciModem]));
   if MustStored then Stored_KS[kr_DESTMODEM]:=CRC;endif;
   //==================DEFAULT BAUDRATE====================
   CalcCRC(ord(StoredDefaultBaud[ci485]));
   CalcCRC(ord(StoredDefaultBaud[ci232]));
   if MustStored then Stored_KS[kr_BAUDRATE]:=CRC;endif;
   //==================PASSWORD============================
   j:=Length(StoredPwd);
   for i:=1 to j do
             WatchDogTrigger;
             CalcCRC(ord(StoredPwd[i]));
   endfor;
   if MustStored then Stored_KS[kr_PASSWORD]:=CRC;endif;
   //==================SERVER==============================
   CalcCRC(Lo(Stored_Inet_SERVER_PORT));
   CalcCRC(Hi(Stored_Inet_SERVER_PORT));
   if MustStored then Stored_KS[kr_SERVER]:=CRC;endif;
   //==================PARAMETERS==============================
   for i:=1 to MAxParam do
             WatchDogTrigger;
             CalcCRC(ord(Stored_ActiveParam[i]));
             CalcCRC(Stored_ModeParam[i]);
             CalcCRC(ord(Stored_TypeOfParam[i]));
             CalcCRC(Stored_NumOfParam[i]);
             CalcCRC(Lo(Stored_MinParam[i]));
             CalcCRC(Hi(Stored_MinParam[i]));
             WatchDogTrigger;
             CalcCRC(Lo(Stored_MaxParam[i]));
             CalcCRC(Hi(Stored_MaxParam[i]));
             WatchDogTrigger;
             CalcCRC(ord(Stored_SMSMessageParam[i]));
             j:=length(Stored_StrMessageParam[i]);
             for k:=1 to j do
                       WatchDogTrigger;
                       CalcCRC(ord(Stored_StrMessageParam[i][k]));
             endfor;
             j:=length(Stored_TelNumParam[i]);
             for k:=1 to j do
                       WatchDogTrigger;
                       CalcCRC(ord(Stored_TelNumParam[i][k]));
             endfor;
             CalcCRC(Stored_RTS_232);
   endfor;
   if MustStored then Stored_KS[kr_PARAM]:=CRC;endif;
   if MustStored then
      Stored_SYSTEM_KS:=CRC;                         //контрольная сумма флеш
   endif;
   return(Stored_SYSTEM_KS=CRC);
end;




(*
0x42 - команда модема
 параметр:
    02 - состояние модема
	Ответ: 	nameModem + " " + State + Signal + " "
	nameМОДЕМ: Команды "AT+CGMI" и "AT+CGMM"
        	   nameModem = name1+"_"+name2
	State = "YES "/"NO " + destHost + ":" + destPort + " "+ nameOperator + " " + connLogin + "/" + connPassword + "/" + connPoint + " "
	nameOperator: Команда "AT+COPS?"
	Signal: команда "AT+CSQ" (уровень сигнала одна цифра)
	Пример запроса: "01 42 XX XX XX XX 01 00 00 00 02 CRC(2)"
	Пример ответа: 1-й байт - 02, затем "SIEMENS_TC65 YES 89.207.73.52:10003 "MTS-RUS" mts/mts/internet.mts.ru 19 "
*)
procedure CreateResponce_42_2;
begin
   DisableInts;
   DateTime_Val[1]:=char((Day div 10)+ord('0'));
   DateTime_Val[2]:=char((Day mod 10)+ord('0'));
   DateTime_Val[4]:=char((Month div 10)+ord('0'));
   DateTime_Val[5]:=char((Month mod 10)+ord('0'));
   DateTime_Val[7]:=char((year div 10)+ord('0'));
   DateTime_Val[8]:=char((year mod 10)+ord('0'));
   DateTime_Val[10]:=char((hour div 10)+ord('0'));
   DateTime_Val[11]:=char((hour mod 10)+ord('0'));
   DateTime_Val[13]:=char((minute div 10)+ord('0'));
   DateTime_Val[14]:=char((minute mod 10)+ord('0'));
   DateTime_Val[16]:=char((second div 10)+ord('0'));
   DateTime_Val[17]:=char((second mod 10)+ord('0'));
   if ks_EBROKER in KSPDSTATE then
      InputBuff_Console_Param1:='EW-PORT ';
   else
      if MODEM_NAME1='' then
         MODEM_NAME1:='MODEM';
      endif;
      if MODEM_NAME2='' then
         MODEM_NAME2:='MXX';
      endif;
      InputBuff_Console_Param1:=Trim(MODEM_NAME1)+'_'+Trim(MODEM_NAME2)+' ';
   endif;
   InputBuff_Console_Param2:='';
   if (ks_MBROKER in KSPDSTATE) or (ks_EBROKER in KSPDSTATE) or (ks_MSERVER in KSPDSTATE) then
      if (not (ks_EBROKER in KSPDSTATE)) then
         InputBuff_Console_Param1:=InputBuff_Console_Param1+'MODEM_ONLINE[';
      else
         InputBuff_Console_Param1:=InputBuff_Console_Param1+'ETHERNET_ONLINE[';
      endif;
      if ONLINEDAYS>0 then
         InputBuff_Console_Param1:=InputBuff_Console_Param1+intToStr(ONLINEDAYS)+'d_';
      endif;
      InputBuff_Console_Param1:=InputBuff_Console_Param1+ByteToStr(ONLINEHOUR)+'h_';
      InputBuff_Console_Param1:=InputBuff_Console_Param1+ByteToStr(ONLINEMin)+'m_';
      InputBuff_Console_Param1:=InputBuff_Console_Param1+ByteToStr(ONLINESEK)+'s]['+IntToStr(RECONNCOUNT)+']';
   endif;
   MyIntToHex(integer(wKSPDCONTROL));InputBuff_Console_Param1:=InputBuff_Console_Param1+' RC_0x'+I2HStr;
   MyIntToHex(integer(wKSPDSTATE));InputBuff_Console_Param1:=InputBuff_Console_Param1+' RS_0x'+I2HStr;
   InputBuff_Console_Param1:=InputBuff_Console_Param1+' '+Trim(Inet_BROKER_IP)+':'+
                             IntToStr(Inet_BROKER_PORT)+' "'+
                             Trim(OPERATOR)+'" '+
                             Trim(Inet_Login)+'/'+
                             Trim(Inet_Password)+'/'+
                             Trim(Inet_AP);
   InputBuff_Console_Param2:=InputBuff_Console_Param2+BALANCE+' '+curVer+' '+//баланс
                             DateTime_Val+' start='+
                             ByteToStr(StartTimeZone)+'h_stop='+ByteToStr(StopTimeZone)+'h '+
                             CSQ_Val+' '+ParamState_VAL+' ';
                             
   InputBuff_Console_LenParam1:=Length(InputBuff_Console_Param1);
   InputBuff_Console_LenParam2:=Length(InputBuff_Console_Param2);
   EnableInts;
end;


procedure CreateDrySwitchStateSMS;
begin
   //state
   DisableInts;
   DateTime_Val[1]:=char((Day div 10)+ord('0'));
   DateTime_Val[2]:=char((Day mod 10)+ord('0'));
   DateTime_Val[4]:=char((Month div 10)+ord('0'));
   DateTime_Val[5]:=char((Month mod 10)+ord('0'));
   DateTime_Val[7]:=char((year div 10)+ord('0'));
   DateTime_Val[8]:=char((year mod 10)+ord('0'));
   DateTime_Val[10]:=char((hour div 10)+ord('0'));
   DateTime_Val[11]:=char((hour mod 10)+ord('0'));
   DateTime_Val[13]:=char((minute div 10)+ord('0'));
   DateTime_Val[14]:=char((minute mod 10)+ord('0'));
   DateTime_Val[16]:=char((second div 10)+ord('0'));
   DateTime_Val[17]:=char((second mod 10)+ord('0'));
   InputBuff_Console_Param1:=CurVer+' ID:'+longToStr(Inet_ID_HARDWARE)+' N:'+longToStr(HARDNUM)+' ';
   InputBuff_Console_Param2:=DateTime_Val+' DS:'+ParamState_VAL+' V:'+CSQ_Val+' B:'+BALANCE;
   InputBuff_Console_LenParam1:=Length(InputBuff_Console_Param1);
   InputBuff_Console_LenParam2:=Length(InputBuff_Console_Param2);
   EnableInts;
end;


(*
procedure IncSBCOUNT(DEST:TCOMMIDX);
begin
 if (DEST<>ciFree) and
 ((Mstate=usSERVICE) or (Estate=usSERVICE))then
  inc(SBCOUNT[DEST]);
  if SBCOUNT[DEST]>1023 then
     SBCOUNT[DEST]:=0;
     Inc(SKBCOUNT[DEST]);
  endif;
 endif;
end;
*)
(*
         MODEM_RTC:=True;
         while MODEM_CTS do
               nop;
         endwhile;
         SerOut4(tmpStr16[i]);
         while (UCSR3A and %00100000) = 0 do
              nop;
         endwhile;
         MODEM_RTC:=fALSE;
*)
procedure WaitModemCTS;
begin
//   MODEM_RTC:=True;
   while MODEM_CTS do
         WatchDogTrigger;
         nop;
   endwhile;
end;

procedure WaitOutByte2Modem;
begin
  while (UCSR3A and %00100000) = 0 do
        nop;
  endwhile;
//  MODEM_RTC:=fALSE;
end;


procedure HexToSerOut4(Bh:byte);
var BChar:char;
begin
   WaitModemCTS;
   BChar:=HexTable[(Bh shr 4)];
   SerOut4(BChar);
  {$IFDEF DBG}
  if (Debug and 2) = 2 then
      WriteConCh(V_CONSOLE,BChar);
  endif;
  {$ENDIF}
   WaitOutByte2Modem;
   WaitModemCTS;
   BChar:=HexTable[(Bh and $0F)];
   SerOut4(BChar);
  {$IFDEF DBG}
  if (Debug and 2) = 2 then
      WriteConCh(V_CONSOLE,BChar);
  endif;
  {$ENDIF}
   WaitOutByte2Modem;
end;



procedure Str2SerOut4;
var i,len:byte;
begin
     len:=Length(CmdStr);
     for i:=1 to Len do
           WaitModemCTS;
           SerOut4(CmdStr[i]);
           WaitOutByte2Modem;
           {$IFDEF DBG}
           if (Debug and 2) = 2 then
               WriteConCh(V_CONSOLE,CmdStr[i]);
           endif;
           {$ENDIF}
     endfor;
end;

procedure HexLed(AValue:byte);
begin
  if Switcher_1 then
    LED_1:=(AValue and 1) <>0;
    LED_2:=(AValue and 2) <>0;
    LED_3:=(AValue and 4) <>0;
    LED_4:=(AValue and 8) <>0;
    LED_5:=(AValue and $10) <>0;
  endif;
end;

procedure FreeUBuf(AIdx:byte);
begin
  if AIdx in [0..(UBufCount-1)] then
       UBuff[AIdx].Owner:=ciFree;
       UBuff[AIdx].Count:=0;
       UBuff[AIdx].BufNum:=0;
       UBuff[AIdx].State:=0;
//       UBuff[AIdx].FromOwner:=True;
  endif;
end;



procedure Str2ModemX;
begin
     Excl(KSPDCONTROL,kc_IGNOREOK);
     Excl(KSPDSTATE,ks_FPM);
     ModemTimeOut:=3;
     Incl(KSPDCONTROL,kc_MCR);
     Str2SerOut4;
end;


procedure Str2Modem;
begin
     Str2ModemX;
     WaitModemCTS;
     SerOut4(#13);
     WaitOutByte2Modem;
     WaitModemCTS;
     SerOut4(#10);
     WaitOutByte2Modem;
end;

procedure EndCharToModem;
begin
     Incl(KSPDCONTROL,kc_IGNOREOK);
     Excl(KSPDSTATE,ks_FPM);
     Incl(KSPDCONTROL,kc_MCR);
     ModemTimeOut:=200;
     WaitModemCTS;
     SerOut4('"');
     {$IFDEF DBG}
     if (Debug and 2) = 2 then
         WriteConCh(V_CONSOLE,'"');
     endif;
     {$ENDIF}
     WaitOutByte2Modem;
     WaitModemCTS;
     SerOut4(#13);
     WaitOutByte2Modem;
     WaitModemCTS;
     SerOut4(#10);
     WaitOutByte2Modem;
end;


procedure ReSendToModem(UBuffNum:byte;AFrom:TCOMMIDX);
var CRC:word;
    i:integer;
    bh:byte;
begin
    {$IFDEF DBG}
    if (debug and 8) = 8 then
       WritelnStr:='[ResendToModem]: UBUFF '+byteToStr(UBuffNum)+' Slot '+ByteToStr(UBuff[UBuffNum].ASlot)+' mode '+byteToStr(Slot[UBuff[UBuffNum].ASlot].Mode)+' '+OwnerName[AFrom];
       WriteLnCon(V_CONSOLE);
    endif;
    {$ENDIF}
    //если индекс буфера - в диапазоне допустимых
    if UBuffNum in [0..UBufCount-1] then
       //TSlotMode=(smFree,smClient,smInProgress,smServer);//режим подключения текущего слота
       if Slot[UBuff[UBuffNum].ASlot].Mode=smClient then
          //-------------------------------
          //в режиме брокера M2M или ATD97
          //-------------------------------
          //корректируем поле длины в заголовке брокера
          if XCOMM[ciModem].cmd=$42 then
             XCOMM[ciModem].HeaderPackage[6]:=Lo(UBuff[UBuffNum].Count+1);
             XCOMM[ciModem].HeaderPackage[7]:=Hi(UBuff[UBuffNum].Count+1);
          else
             XCOMM[ciModem].HeaderPackage[6]:=Lo(UBuff[UBuffNum].Count);
             XCOMM[ciModem].HeaderPackage[7]:=Hi(UBuff[UBuffNum].Count);
          endif;
          if UBuff[UBuffNum].ASlot in [1..5] then
             //в режиме М2М - все отправляем налету - за один шаг
             CRC:=$FFFF;
             CmdStr:='AT$NWTX='+byteToStr(UBuff[UBuffNum].ASlot)+',"';
             Str2SerOut4;
             for i:=0 to 9 do
                 bh:=XCOMM[ciModem].HeaderPackage[i];
                 CalcCRC(bh);
//                 IncSBCOUNT(ciModem);
                 HexToSerOut4(Bh);
             endfor;

             if XCOMM[ciMODEM].CMD=$42 then
                 bh:=2;
                 CalcCRC(bh);
//                 IncSBCOUNT(ciModem);
                 HexToSerOut4(Bh);
             endif;

             for i:=0 to UBuff[UBuffNum].Count-1 do
                WatchDogTrigger;
                bh:=UBuff[UBuffNum].Buff[i];
                CalcCRC(bh);
                HexToSerOut4(Bh);
//                IncSBCOUNT(ciModem);
             endfor;

             bh:=lo(CRC);
             HexToSerOut4(Bh);
             bh:=hi(CRC);
             HexToSerOut4(Bh);

             EndCharToModem;
          else
             //в режиме ATD97 - чистый поток
             for i:=0 to 9 do
                 bh:=XCOMM[ciModem].HeaderPackage[i];
                 CalcCRC(bh);
//                 IncSBCOUNT(ciModem);
                 SerOut4(bh);
                 WaitOutByte2Modem;
             endfor;

             if XCOMM[ciMODEM].CMD=$42 then
                 bh:=2;
                 CalcCRC(bh);
//                 IncSBCOUNT(ciModem);
                 SerOut4(bh);
                 WaitOutByte2Modem;
             endif;

             for i:=0 to UBuff[UBuffNum].Count-1 do
                WatchDogTrigger;
                bh:=UBuff[UBuffNum].Buff[i];
                SerOut4(bh);
                WaitOutByte2Modem;
                CalcCRC(bh);
//                IncSBCOUNT(ciModem);
             endfor;

             bh:=lo(CRC);
             SerOut4(bh);
             WaitOutByte2Modem;
             bh:=hi(CRC);
             SerOut4(bh);
             WaitOutByte2Modem;
             ModemTimeOut:=250;//взводим ожидание ответа от устройства на 60 сек
             Excl(KSPDSTATE,ks_FPM);
             Incl(KSPDCONTROL,kc_IGNOREOK);
          endif;
       elsif Slot[UBuff[UBuffNum].ASlot].Mode=smServer then
          //-------------------------------------
          //в режиме сервера или CSD или команды
          //-------------------------------------
          if UBuff[UBuffNum].ASlot in [1..5] then
             //режим м2м - ТСР сервер
             CmdStr:='AT$NWTX='+byteToStr(UBuff[UBuffNum].ASlot)+',"';
             Str2SerOut4;
             for i:=0 to UBuff[UBuffNum].Count-1 do
                WatchDogTrigger;
                bh:=UBuff[UBuffNum].Buff[i];
                HexToSerOut4(Bh);
//                IncSBCOUNT(ciModem);
             endfor;
             EndCharToModem;
          else//if not UBuff[UBuffNum].ASlot in [1..5] then
             //режим CSD или команда
             for i:=0 to UBuff[UBuffNum].Count-1 do
                WatchDogTrigger;
                bh:=UBuff[UBuffNum].Buff[i];
                SerOut4(bh);
                WaitOutByte2Modem;
//                IncSBCOUNT(ciModem);
             endfor;
          endif;//if not UBuff[UBuffNum].ASlot in [1..5] then
       else
          //если режим не понятен - просто отсылаем в порт данные
          //- возможно соединение было разорвано - пока так оставляем
          for i:=0 to UBuff[UBuffNum].Count-1 do
                WatchDogTrigger;
                bh:=UBuff[UBuffNum].Buff[i];
                SerOut4(bh);
                WaitOutByte2Modem;
          endfor;
       endif;//elsif Slots[UBuff[UBuffNum].ASlot].Mode=smServer then
    endif;//if UBuffNum in [0..UBufCount-1] then
end;

//========================================
//      Отправка ответа в модем
//========================================

procedure MySerBaud(APort:byte; IDXBaud:TSpeedBaud);
begin
 if ord(IDXBaud) in [0..6] then
    case aPort of
    1: UBRR0H:=Hi(SpeedUBRR[IDXBaud]); UBRR0L:=Lo(SpeedUBRR[IDXBaud]);|
    2: UBRR1H:=Hi(SpeedUBRR[IDXBaud]); UBRR1L:=Lo(SpeedUBRR[IDXBaud]);|
    3: UBRR2H:=Hi(SpeedUBRR[IDXBaud]); UBRR2L:=Lo(SpeedUBRR[IDXBaud]);|
    4: UBRR3H:=Hi(SpeedUBRR[IDXBaud]); UBRR3L:=Lo(SpeedUBRR[IDXBaud]);|
    endcase;
 endif;
end;

function PtrIOBuff(aFrom:TCOMMIDX;Idx:integer):pByte;
begin
    if (XCOMM[AFrom].ResendUBuff in [0..(UBufCount-1)]) and
       (idx<UBuff[XCOMM[AFrom].ResendUBuff].Count) and
       (UBuff[XCOMM[AFrom].ResendUBuff].Owner=aFrom) then
       return(@UBuff[XCOMM[AFrom].ResendUBuff].Buff[Idx]);
    else
       return(nil);
    endif;
end;

function LenIOBuff(aFrom:TCOMMIDX):integer;
begin
    if (XCOMM[AFrom].ResendUBuff in [0..(UBufCount-1)]) and (UBuff[XCOMM[AFrom].ResendUBuff].Owner=aFrom) then
       return(UBuff[XCOMM[AFrom].ResendUBuff].Count);
    else
       return(0);
    endif;
end;

procedure SetLenIOBuff(aFrom:TCOMMIDX;aLen:integer);
begin
    if (XCOMM[AFrom].ResendUBuff in [0..(UBufCount-1)]) and (UBuff[XCOMM[AFrom].ResendUBuff].Owner=aFrom)   then
       UBuff[XCOMM[AFrom].ResendUBuff].Count:=aLen;
    endif;
end;

function ByteIOBuff(aFrom:TCOMMIDX;idx:integer):byte;
begin
    if (XCOMM[AFrom].ResendUBuff in [0..(UBufCount-1)]) and
       (idx<UBuff[XCOMM[AFrom].ResendUBuff].Count) and
       (UBuff[XCOMM[AFrom].ResendUBuff].Owner=aFrom) then
       return(UBuff[XCOMM[AFrom].ResendUBuff].Buff[Idx]);
    else
       return(0);
    endif;
end;

procedure SetByteIOBuff(aFrom:TCOMMIDX;idx:integer;newVal:byte);
begin
    if (XCOMM[AFrom].ResendUBuff in [0..(UBufCount-1)]) and
       (idx<UBuff[XCOMM[AFrom].ResendUBuff].Count) and
       (UBuff[XCOMM[AFrom].ResendUBuff].Owner=aFrom) then
       UBuff[XCOMM[AFrom].ResendUBuff].Buff[Idx]:=newVal;
    endif;
end;






procedure ReSendToRS485(UBuffNum:byte;AFrom:TCOMMIDX);
var i,len:integer;
    bh:byte;
begin
 {$IFDEF DBG}
 if (Debug and $10) = $10 then
     WritelnStr:='[RS485 < '+OWNERNAME[aFrom]+']';
     WriteLnCon(V_CONSOLE);
 endif;
 {$ENDIF}

  //Destination[ci485]:=AFrom;
  if not  ((Afrom=ciModem) and((ks_MBROKER in KSPDSTATE) or (ks_MSERVER in KSPDSTATE)))
   or     ((Afrom=ciEthernet) and (ks_EBROKER in KSPDSTATE)) then
     XCOMM[AFrom].Baud:=ActualSpeed[1];
  endif;

  //скорость - если не совпадает - правим
  if ActualSpeed[1]<>XCOMM[AFrom].Baud then
     PrevSpeed[1]:=ActualSpeed[1];
     ActualSpeed[1]:=XCOMM[AFrom].Baud;
     MySERBaud(2,ActualSpeed[1]);
  endif;

  Sw_485:=True;
  udelay(5);
  //--------------------------------
  // Вычисляем длину посылки
  //--------------------------------
  len:=LenIOBuff(aFrom);

  for i:=0 to len-1 do
         bh:=ByteIOBuff(aFrom,i);
         WriteToRS485(bh);
  endfor;
  udelay(5);
  Sw_485:=False;
  //-------------------------------------
  //  освобождаем буфер - от кого посылка
  //  Внимание!!!
  //  для RS485 переводим систему на прием только на шаге 100
  //  код: Sw_485:=False;
  //-------------------------------------
end;

procedure ReSendToVCON(UBuffNum:byte;AFrom:TCOMMIDX);
var i,len,
    bh:byte;
begin
(* {$IFDEF DBG}
 if (Debug and $40) = $40 then
     WriteLnCon_(V_CONSOLE);
     Write(SerOut3,'[VCON < ');
     Write(SerOut3,OWNERNAME[aFrom]);
     Writeln(SerOut3,']');
 endif;
 {$ENDIF}

  Destination[ciV_CON]:=AFrom;

  //--------------------------------
  // Вычисляем длину посылки
  //--------------------------------
  len:=LenIOBuff(aFrom);
  xcomm[ciV_CON].IOBuffCount:=len;
  for i:=0 to len-1 do
         bh:=ByteIOBuff(aFrom,i);
         {$IFDEF DBG}
         if (Debug and $80) = $80 then
           Write(SerOut3,ByteToHex(bh));
         endif;
         {$ENDIF}
         xcomm[ciV_CON].IOBuff[i]:=bh;
  endfor;
  //-------------------------------------
  //  освобождаем буфер - от кого посылка
  //-------------------------------------*)
end;

procedure WriteToRS232(bh:byte);
begin
    {$IFDEF DBG}
    MyByteToHex(Bh);
    if (Debug and $80) = $80 then
      WriteConCh(V_CONSOLE,B2HStr[2]);
      WriteConCh(V_CONSOLE,B2HStr[1]);
    endif;
   {$ENDIF}

    SerOut3(bh);
    //IncSBCOUNT(ci232);
    while Not UCSR2A.5 do //TXC
          nop;
    endwhile;
    while Not UCSR2A.6 do //TXC
           nop;
    endwhile;
    UCSR2A.6:=True;

end;



procedure WriteToEthernet(bh:byte);
begin
     {$IFDEF DBG}
     MyByteToHex(Bh);
     if (Debug and $80) = $80 then
       WriteConCh(V_CONSOLE,B2HStr[2]);
       WriteConCh(V_CONSOLE,B2HStr[1]);
     endif;
     {$ENDIF}
     SerOut(bh);
     //статистика
     while not UCSR0A.5 do//UDRE
          nop;
     endwhile;
     while not UCSR0A.6 do//UDRE
           nop;
     endwhile;
     UCSR0A.6:=True;
end;





procedure ReSendToRS232(UBuffNum:byte;AFrom:TCOMMIDX);
var i,len:integer;
    bh:byte;
begin
 {$IFDEF DBG}
 if (Debug and $20) = $20 then
     WritelnStr:='[RS232 < '+OWNERNAME[aFrom]+']';
     WriteLnCon(V_CONSOLE);
 endif;
 {$ENDIF}

  //Destination[ci232]:=AFrom;
  if not ( ((Afrom=ciModem) and (ks_MBROKER in KSPDSTATE)) or ((Afrom=ciEthernet) and (ks_EBROKER in KSPDSTATE))) then
     XCOMM[AFrom].Baud:=ActualSpeed[2];
  endif;

  //скорость - если не совпадает - правим
  if ActualSpeed[2]<>XCOMM[AFrom].Baud then
     PrevSpeed[2]:=ActualSpeed[2];
     ActualSpeed[2]:=XCOMM[AFrom].Baud;
     MySERBaud(3,ActualSpeed[2]);
  endif;

  //--------------------------------
  // Вычисляем длину посылки
  //--------------------------------
 len:=LenIOBuff(aFrom);

  for i:=0 to len-1 do
         bh:=ByteIOBuff(aFrom,i);
         WriteToRS232(bh);
  endfor;
  //-------------------------------------
  //  освобождаем буфер - от кого посылка
  //-------------------------------------
end;



procedure ReSendToEthernet(UBuffNum:byte;AFrom:TCOMMIDX);
var i,len:integer;
    bh:byte;
begin
  //--------------------------------
  // Вычисляем длину посылки
  //--------------------------------
 {$IFDEF DBG}
 if (Debug and 4) = 4 then
     WritelnStr:='[ETHER < '+OWNERNAME[aFrom]+']';
     WriteLnCon(V_CONSOLE);
 endif;
 {$ENDIF}
  len:=LenIOBuff(aFrom);
  if (ks_EBROKER in KSPDSTATE)  then
     //-------------------------------------
     // посылка в формате протокола брокера
     //-------------------------------------
     CRC:=$FFFF;
     for i:=0 to 9 do
         bh:=XCOMM[ciEthernet].HeaderPackage[i];
         CalcCRC(bh);
         SerOut(bh);
         WriteToEthernet(bh);
     endfor;
       //для команды 42,2 дополняем ее двойкой
     if xcomm[ciEthernet].CMD=$42 then
         bh:=2;
         CalcCRC(bh);
         WriteToEthernet(bh);
     endif;
     //
     // вывыодим посылку в модем
     //

     for i:=0 to len-1 do
         bh:=ByteIOBuff(aFrom,i);
         WatchDogTrigger;
         CalcCRC(bh);
         WriteToEthernet(bh);
     endfor;
     //
     //  если пакет транзитный
     //  выводим контрольную сумму
     //
     bh:=Lo(CRC);
     WriteToEthernet(bh);
     bh:=Hi(CRC);
     WriteToEthernet(bh);
  else
     //-------------------------------------
     //           чистый поток
     //-------------------------------------
     XCOMM[ciEthernet].Destination:=AFrom;
     for i:=0 to len-1 do
         bh:=ByteIOBuff(aFrom,i);
         WriteToEthernet(bh);
     endfor;
  endif;
  //-------------------------------------
  //  освобождаем буфер - от кого посылка
  //-------------------------------------
end;


procedure ReAddrUBuf(AIdx:byte;NewAddr:TCOMMIDX;AnswerSlot:byte);
begin
  if NewAddr=ciFree then
      {$IFDEF DBG}
      if (debug and 8) = 8 then
         WritelnStr:='Readdr - Free';
         WriteLnCon(V_CONSOLE);
      endif;
     {$ENDIF}
     FreeUBuf(AIdx);
  else
     if AIdx in [0..(UBufCount-1)] then
          {$IFDEF DBG}
          if (debug and $40) = $40 then
             WritelnStr:='UBuf['+byteToStr(AIdx)+'] >> '+OwnerName[NewAddr]+' №пк '+intToStr(UBuff[AIdx].BufNum)+' кол '+IntToStr(UBuff[AIdx].Count);
             WriteLnCon(V_CONSOLE);
          endif;
          {$ENDIF}
          UBuff[AIdx].ASlot:=AnswerSlot;
          
          case NewAddr of
          ciModem:    ReSendToModem(AIdx,UBuff[AIdx].Owner);|
          ci485:      ReSendToRS485(AIdx,UBuff[AIdx].Owner);|
          ci232:      ReSendToRS232(AIdx,UBuff[AIdx].Owner);|
          ciEthernet: ReSendToEthernet(AIdx,UBuff[AIdx].Owner);|
          ciV_CON:    ReSendToVCON(AIdx,UBuff[AIdx].Owner);|
          endcase;
          FreeUBuf(AIdx);
//          UBuff[AIdx].Owner:=NewAddr;

          
     endif;
  endif;
end;

//=================================================
// освобождаем порт
//=================================================
procedure FreePort(BuffID:TCOMMIDX);
begin
    {$IFDEF DBG}
    if (debug and 8) = 8 then
        WriteLnStr:=FPNAME[BuffID];
        WriteLnCon(V_CONSOLE);
    endif;
    {$ENDIF}
    XCOMM[BuffID].Destination:=ciFree;
    //для RS485 переводим систему на прием только на шаге 100
    if (XCOMM[BuffID].ResendUBuff in [0..(UBufCount-1)]) and (UBuff[XCOMM[BuffID].ResendUBuff].Owner=BuffID) then
       FreeUBuf(XCOMM[BuffID].ResendUBuff);
    endif;
    //Destination[BuffID]:=ciFree;//освобождаем адрес назначения
end;







procedure SnakeOff;
begin
     if Switcher_1 then
       LED_1:=False;
       LED_2:=False;
       LED_3:=False;
       LED_4:=False;
       LED_5:=False;
     endif;
end;


procedure LedValue(AValue:byte);
begin
  case AValue of
  0,99:
       SnakeOff;
  |
  1:
       LED_1:=True;
       LED_2:=False;
       LED_3:=False;
       LED_4:=False;
       LED_5:=False;
  |
  2:
       LED_1:=True;
       LED_2:=True;
       LED_3:=False;
       LED_4:=False;
       LED_5:=False;
  |
  3:
       LED_1:=True;
       LED_2:=True;
       LED_3:=True;
       LED_4:=False;
       LED_5:=False;
  |
  4:
       LED_1:=True;
       LED_2:=True;
       LED_3:=True;
       LED_4:=True;
       LED_5:=False;
  |
  5:
       LED_1:=True;
       LED_2:=True;
       LED_3:=True;
       LED_4:=True;
       LED_5:=True;
  |
  else
       LED_1:=False;
       LED_2:=False;
       LED_3:=False;
       LED_4:=False;
       LED_5:=False;
  endcase;
end;


//
// процедура змейки
//
procedure SnakeOn;
begin
 TestLedCounter:=(TestLedCounter mod 5) + 1;
 LedValue(TestLedCounter);
end;


//================================================================
// Поиск в буфере первой цифры баланса
//================================================================
function MFindFirstDigitInBuff:byte;
var posx,len,i:byte;
    bh:byte;
begin
   //общая длина
   len:=Length(ResStr);
   posx:=0;
   if len>0 then
       for i:=1 to len do
          WatchDogTrigger;
          bh:=ord(ResStr[i]);
          if ( bh>=ord('0') ) and
             (bh<=ord('9'))
          then
             posx:=i;
             if (i<>0) and (ResStr[i-1]=ord('-')) then
               dec(posx);
             endif;
             break;
          endif;
       endfor;//j
   endif;
   if kc_MCR in KSPDCONTROL then
      //сбрасываем флаг запроса команды
     Excl(KSPDCONTROL,kc_MCR);//т.к. уже роемся в ответе
   endif;
   return(posx);
end;


//================================================================
// Поиск в буфере строки максимальной длиной не более 30 символов с позиции ps
// ps - реально указывает на +1 позицию от позиции совпадения
//================================================================
//'+CSQ: 17,0'
function MFindInBuffFromPos(SubStr:string[30];ps:byte):byte;
var res:boolean;
    posx,i,j,aLen,LenCmdStr:byte;
begin
  posx:=0;
  ALen:=Length(SubStr);
  LenCmdStr:=Length(ResStr);
  if (LenCmdStr>0) and (LenCmdStr>=ALen) then
     for i:=ps to ((LenCmdStr-aLen)+1) do
        res:=True;
        for j:=1 to ALen do
          if ResStr[i+j-1]<>SubStr[j] then
             res:=False;
            break;
          endif;
        endfor;
        if res then
          posx:=i+1;
          break;
        endif;
     endfor;//j
  endif;
  return(posx);
end;


//================================================================
// Поиск в буфере строки максимальной длиной не более 30 символов
//================================================================
function MFindInBuff(SubStr:string[30]):byte;
begin
  return(MFindInBuffFromPos(SubStr,1));
end;

//
// ищет цифру между двумя запятыми с позиции startPS
//
function MFindDigit(startPS:byte):byte;
var MustCopy:boolean;
    i,len:byte;
    aCh:char;
begin
   tmpStr:='';
   MustCopy:=False;
   len:=Length(ResStr);
   if len>0 then
       for i:=StartPS to len do
          aCh:=ResStr[i];
          if aCh=',' then
             if not MustCopy then
                MustCopy:=True;
             else
                break;
             endif;
          else
             if MustCopy then
                tmpStr:=tmpStr+aCh;
             endif;
          endif;
       endfor;
       len:=strtoint(tmpStr);
       return(len);
   endif;
end;


procedure EncodeLatinBuff(psx:byte);
var psw,//указатель на запись
    ps,//указатель на чтение
    s2,s3,s32,len:byte;
    FirstPing:boolean;
begin
  FirstPing:=True;
  {$IFDEF DBG}
  if (Debug and 8) = 8 then
     WritelnStr:='[enc]';
     WriteLnCon(V_CONSOLE);
  endif;
  {$ENDIF}
  psw:=0;//начинаем затирать буфер с нулевого
  ps:=psx;
  BalanceStr:='';
  len:=Length(ResStr);
  while ps<=len do
       WatchDogTrigger;
       if ord(ResStr[ps])=$2F then
          ResStr[ps]:=char($30);
       endif;
       if ord(ResStr[ps+1])=$2F then
          ResStr[ps+1]:=char($30);
       endif;
       s3:=ord(ResStr[ps])-$30;
       s32:=ord(ResStr[ps+1])-$30;
       if (s3 in [0..22]) and (s32 in [0..22]) then
        s2:=((h_tbl[s3]) shl 4) + (h_tbl[s32]);
        {$IFDEF DBG}
        MyByteToHex(s2);
        if (Debug and $80) = $80 then
          WriteConCh(V_CONSOLE,B2HStr[2]);
          WriteConCh(V_CONSOLE,B2HStr[1]);
        endif;
        {$ENDIF}
        Inc(ps,2);
        if FirstPing then
           FirstPing:=(s2=$70);
        endif;
        //пропускаем первые символы пинговки
        if not FirstPing then
          ResStr[psw]:=char(s2);
          if psw<50 then
             BalanceStr:=BalanceStr+s2;
          endif;
          inc(psw);
        endif;
       else
        break;
       endif;
  endwhile;
  SetLength(ResStr,psw);
end;


procedure ShowAnswer(dest:TCOMMIDX);
var i,len,bh:byte;
begin
 if (((Debug and 2) = 2) and (dest=ciModem)) or
    (((debug and 4) = 4) and (dest=ciEthernet))
 then
    len:=Length(ResStr);
    WatchDogTrigger;
    if len<>0 then
      for i:=1 to len do
       bh:=ord(ResStr[i]);
       if (bh in [$0A,$0D,$20..$7A]) and (Dest=ciMODEM) then
          WriteConCh(V_CONSOLE,char(bh));
       else
          MyByteToHex(Bh);
          if (Debug and $80) = $80 then
            WriteConCh(V_CONSOLE,'$');
            WriteConCh(V_CONSOLE,B2HStr[2]);
            WriteConCh(V_CONSOLE,B2HStr[1]);
          endif;
       endif;
      endfor;
    endif;
 endif;
 WatchDogTrigger;
end;




(*
procedure ReSendToEthernet(AFrom:TCOMMIDX);
var i,len:integer;
    bh:byte;
begin
  //--------------------------------
  // Вычисляем длину посылки
  //--------------------------------
 {$IFDEF DBG}
 if (Debug and 4) = 4 then
     WriteLnCon_(V_CONSOLE);
     Write(SerOut3,'[ETHER < ');
     Write(SerOut3,OWNERNAME[aFrom]);
     Writeln(SerOut3,']');
 endif;
 {$ENDIF}
  len:=LenIOBuff(aFrom);
  if (EState=usSERVICE)  then
    if  Answer[Afrom] then          //и данный пакет является ответом на запрос
     //-------------------------------------
     // посылка в формате протокола брокера
     //-------------------------------------
     CRC:=$FFFF;
     for i:=0 to 9 do
         bh:=HeaderPackage[ciEthernet,i];
         {$IFDEF DBG}
         if (Debug and $80) = $80 then
             Write(SerOut3,ByteToHex(bh));
         endif;
         {$ENDIF}
         CalcCRC(bh);
         SerOut(bh);
         IncSBCOUNT(ciEthernet);
         //статистика
         while not UCSR0A.5 do//UDRE
              nop;
         endwhile;
         while not UCSR0A.6 do//UDRE
               nop;
         endwhile;
         UCSR0A.6:=True;
     endfor;
       //для команды 42,2 дополняем ее двойкой
     if xcomm[ciEthernet].CMD=$42 then
         bh:=2;
         {$IFDEF DBG}
         if (Debug and $80) = $80 then
             Write(SerOut3,ByteToHex(bh));
         endif;
         {$ENDIF}
         CalcCRC(bh);
         SerOut(bh);
         IncSBCOUNT(ciEthernet);
     endif;
     //
     // вывыодим посылку в модем
     //

     for i:=0 to len-1 do
         bh:=ByteIOBuff(aFrom,i);

        WatchDogTrigger;
        SerOut(bh);

        {$IFDEF DBG}
        if (Debug and $80) = $80 then
             Write(SerOut3,ByteToHex(bh));
        endif;
        {$ENDIF}

        IncSBCOUNT(ciEthernet);
        CalcCRC(bh);

        while (UCSR0A and %00100000) = 0 do
               WatchDogTrigger;
               nop;
        endwhile;
     endfor;
     //
     //  если пакет транзитный
     //  выводим контрольную сумму
     //
     bh:=Lo(CRC);
     SerOut(bh);
     {$IFDEF DBG}
     if (Debug and $80) = $80 then
         Write(SerOut3,ByteToHex(bh));
     endif;
     {$ENDIF}
     while (UCSR0A and %00100000) = 0 do
          WatchDogTrigger;
          nop;
     endwhile;
     bh:=Hi(CRC);
     SerOut(bh);
     {$IFDEF DBG}
     if (Debug and $80) = $80 then
         Write(SerOut3,ByteToHex(bh));
      endif;
     {$ENDIF}
    else
     {$IFDEF DBG}
     if (Debug and 8) = 8 then
       Write(SerOut3,'[eth] ');
     endif;
     {$ENDIF}
    endif;
  else
     {$IFDEF DBG}
     if (Debug and 8) = 8 then
       Write(SerOut3,'[eth!] ');
     endif;
     {$ENDIF}
     //-------------------------------------
     //           чистый поток
     //-------------------------------------
     Destination[ciEthernet]:=AFrom;
     if not Answer[aFrom] then
        Answer[ciEthernet]:=True;
     endif;
     for i:=0 to len-1 do
         bh:=ByteIOBuff(aFrom,i);
         SerOut(bh);
         {$IFDEF DBG}
         if (Debug and $80) = $80 then
            Write(SerOut3,ByteToHex(bh));
         endif;
        {$ENDIF}
         IncSBCOUNT(ciEthernet);
         while not UCSR0A.5 do//UDRE
               nop;
         endwhile;
         while not UCSR0A.6 do//UDRE
               nop;
         endwhile;
         UCSR0A.6:=True;
     endfor;
  endif;
  //-------------------------------------
  //  освобождаем буфер - от кого посылка
  //-------------------------------------
  FreePort(aFrom);
end;
*)


procedure SetLocalRTC;
begin
  RTCsetSecond(second);
  RTCsetMinute(minute);
  RTCsetHour(hour);
  RTCsetDay(day);
  RTCsetMonth(month);
  RTCsetYear(year);
end;


// set hour
function SetHour(ahour : byte) : boolean;
  var temp : byte;
begin
  rtcSetHour(ahour);
  if ahour in [0..23] then
    temp := byteToBcd(ahour);
    if not I2Cout(rtc,$02,temp) then return(false); else return(true); endif;
  else
    return(false);
  endif;
end;

// set minute
function SetMinute(aminute : byte) : boolean;
  var temp : byte;
begin
  rtcSetMinute(aminute);
  if minute in [0..59] then
    temp := byteToBcd(aminute);
    if not I2Cout(rtc,$01,temp) then return(false); else return(true); endif;
  else
    return(false);
  endif;
end;

// set second
function SetSecond(asecond : byte) : boolean;
  var temp : byte;
begin
  rtcSetSecond(asecond);
  if asecond in [0..59] then
    temp := byteToBcd(asecond);
    if not I2Cout(rtc,$00,temp) then return(false); else return(true); endif;
  else
    return(false);
  endif;
end;

// set day
function SetDay(aday : byte) : boolean;
  var temp : byte;
begin
  rtcSetDay(aday);
  if aday in [1..31] then
    temp := byteToBcd(aday);
    if not I2Cout(rtc,$04,temp) then return(false); else return(true); endif;
  else
    return(false);
  endif;
end;

// set month
function SetMonth(amonth : byte) : boolean;
  var temp : byte;
begin
  rtcSetMonth(amonth);
  if amonth in [1..12] then
    temp := byteToBcd(amonth);
    if not I2Cout(rtc,$05,temp) then return(false); else return(true); endif;
  else
    return(false);
  endif;
end;

// set year
function SetYear(ayear : byte) : boolean;
  var temp : byte;
begin
  rtcSetYear(ayear);
  if ayear in [00..99] then
    temp := byteToBcd(ayear);
    if not I2Cout(rtc,$06,temp) then return(false); else return(true); endif;
  else
    return(false);
  endif;
end;

procedure StoreIntegral(NumParam:byte);
  var
    tmpL:longword;
    tmp[@tmpL]:array[1..4] of byte;
begin
    tmpL:=params[NumParam].LValue;
    {$IFDEF DEBUG}
     WritelnStr:='stored '+byteToStr(NumParam)+' ivalue='+longToStr(tmpL);WriteLnCon(V_CONSOLE);
    {$ENDIF}
    I2Cout(rtc,$10+(NumParam shl 2),tmp[1]);
    {$IFDEF DEBUG}
     if debug <>0 then
        WritelnStr:='stored byte 1='+byteToStr(tmp[1]);WriteLnCon(V_CONSOLE);
     endif;
    {$ENDIF}
    I2Cout(rtc,$11+(NumParam shl 2),tmp[2]);
    {$IFDEF DEBUG}
     if debug <>0 then
        WritelnStr:='stored byte 2='+byteToStr(tmp[2]);WriteLnCon(V_CONSOLE);
     endif;
    {$ENDIF}
    I2Cout(rtc,$12+(NumParam shl 2),tmp[3]);
    {$IFDEF DEBUG}
     if debug <>0 then
        WritelnStr:='stored byte 3='+byteToStr(tmp[3]);WriteLnCon(V_CONSOLE);
     endif;
    {$ENDIF}
    I2Cout(rtc,$13+(NumParam shl 2),tmp[4]);
    {$IFDEF DEBUG}
     if debug <>0 then
        WritelnStr:='stored byte 4='+byteToStr(tmp[4]);WriteLnCon(V_CONSOLE);
     endif;
    {$ENDIF}
end;


function ReStoreIntegral(NumParam:byte):longword;
  var AData:longword;
      tmp[@AData]:array[1..4] of byte;
begin
    I2Cout(rtc,$10+(NumParam shl 2));
    I2Cinp(rtc,tmp[1]);
    {$IFDEF DEBUG}
     if debug <>0 then
        WritelnStr:='restored byte 1='+byteToStr(tmp[1]);WriteLnCon(V_CONSOLE);
     endif;
    {$ENDIF}
    I2Cout(rtc,$11+(NumParam shl 2));
    I2Cinp(rtc,tmp[2]);
    {$IFDEF DEBUG}
     if debug <>0 then
     WritelnStr:='restored byte 2='+byteToStr(tmp[2]);WriteLnCon(V_CONSOLE);
     endif;
    {$ENDIF}
    I2Cout(rtc,$12+(NumParam shl 2));
    I2Cinp(rtc,tmp[3]);
    {$IFDEF DEBUG}
     if debug <>0 then
     WritelnStr:='restored byte 3='+byteToStr(tmp[3]);WriteLnCon(V_CONSOLE);
     endif;
    {$ENDIF}
    I2Cout(rtc,$13+(NumParam shl 2));
    I2Cinp(rtc,tmp[4]);
    {$IFDEF DEBUG}
     if debug <>0 then
     WritelnStr:='restored byte 4='+byteToStr(tmp[4]);WriteLnCon(V_CONSOLE);
     WritelnStr:='restored '+byteToStr(NumParam)+' ivalue='+longToStr(ADATA);WriteLnCon(V_CONSOLE);
     endif;
    {$ENDIF}
    return(AData);
end;


// get date from ds1307
function GetDateTime: boolean;
  var dateVar : array[0..2] of byte;
      timeVar : array[0..2] of byte;
      res:boolean;
begin
  res:=True;
  if not I2Cout(rtc, $00) then res:=False; endif;
  if not I2Cinp(rtc, timeVar) then res:=False; endif;
  if (timeVar[0] and $10) = $10 then  SetSecond(timeVar[0] and $7F); endif;//Если установлен бит Halt - сбрасываем
  hour   := bcdToByte(timeVar[2] and $7F);
  minute := bcdToByte(timeVar[1] and $7F);
  second := bcdToByte(timeVar[0] and $7F);
  if not I2Cout(rtc, $04) then res:=False; endif;
  if not I2Cinp(rtc, dateVar) then res:=False; endif;
  day     := bcdToByte(dateVar[0]); //Исправлено!!!
  month   := bcdToByte(dateVar[1] and $1F);
  year    := bcdToByte(dateVar[2]);
  return(res);
end;


// get DayOfWeek
function GetDayOfWeek: boolean;
  var
      res:boolean;
begin
  res:=True;
  if not I2Cout(rtc, $03) then res:=False; endif;
  if not I2Cinp(rtc, DayOfWeek) then res:=False; endif;
  return(res);
end;



//
// Функция преобразования даты в CData (количество секунд с 1.01.1980 )
// Корректно работает от 2000 до 2100 года
//
function DateToCDate(d,m,y,h,mm,ss:byte):longword;
var days,
    result:longword;
begin
  days:=longword(d)+longword(mmm[m]);
  if ((y and 3)=0) and (days<61) and (m<3) then dec(days); endif;
  days:=longword(y)*365+(longword(y) shr 2)+days;
  result:=(days*86400)+(longword(h)*3600)+(longword(mm)*60)+longword(ss)+cBaseDate;
  return(result);
end;


procedure CDateToDate(cdate:longword);
var days,ttemp:longword;
begin
  cdate:=cdate-cBaseDate;
// разделяем дату и время
  days:=(cdate div 86400)+36466;
  ttemp:=cdate mod 86400;
// с временем все понятно
  tekh:=byte(ttemp div 3600);
  ttemp:=ttemp mod 3600;
  tekmm:=byte(ttemp div 60);
  tekss:=byte(ttemp mod 60);
//теперь разбираемся с датой
  ttemp:=(days shl 2)-1;
  teky:=byte((ttemp div 1461)-100); // число лет с 2000 года
  ttemp:=((ttemp mod 1461) shr 2)*5+2;
  tekm:=byte(ttemp div 153);
  tekd :=byte(((ttemp mod 153)+5) div 5);
  if tekm < 10 then Inc(tekm,3);
            else
               Dec(tekm,9);
               Inc(teky);
             endif;
end;



procedure PrintDate(Dest:TCOMMIDX);
begin
     tmpStr:='00.00.00';
     tmpStr[1]:=char((Day div 10)+ord('0'));
     tmpStr[2]:=char((Day mod 10)+ord('0'));
     tmpStr[4]:=char((Month div 10)+ord('0'));
     tmpStr[5]:=char((Month mod 10)+ord('0'));
     tmpStr[7]:=char((year div 10)+ord('0'));
     tmpStr[8]:=char((year mod 10)+ord('0'));
     WritelnStr:=tmpStr;
     WriteLnCon(Dest);
end;

procedure PrintTime(Dest:TCOMMIDX);
begin
     tmpStr:='00:00:00';
     tmpStr[1]:=char((hour div 10)+ord('0'));
     tmpStr[2]:=char((hour mod 10)+ord('0'));
     tmpStr[4]:=char((minute div 10)+ord('0'));
     tmpStr[5]:=char((minute mod 10)+ord('0'));
     tmpStr[7]:=char((second div 10)+ord('0'));
     tmpStr[8]:=char((second mod 10)+ord('0'));
     WritelnStr:=tmpStr;
     WriteLnCon(Dest);
end;

procedure CheckCurrentMode(ADest:TCOMMIDX);
begin
  WriteCon(ADest, 'Mode:');
  if Inet_ID_HARDWARE<>0 then
   if Switcher_1 then
     if Switcher_2 then
        WritelnStr:='Modem - Primary Master';
     else
        WritelnStr:='Ethernet - Primary Master, Modem - Secondary Master';
     endif;
   endif;
  else
   WritelnStr:='Connections via Default Destination Ports Tuning';
  endif;

  if not Switcher_1 then
     if Switcher_2 then
        WritelnStr:='Check GSM Signal';
     else
        WritelnStr:='GPRS Server Mode';
     endif;
  endif;
  WriteLnCon(ADest);
end;


Procedure Signon(AFull:boolean;ADest:TCOMMIDX);
begin
  WritelnStr:=curVer;
  WriteLnCon(ADest);
 {$IFDEF OLDKWARZ}
  WritelnStr:='8MHz';
 {$ELSE}
  WritelnStr:='7.3728MHz';
 {$ENDIF}
  WriteLnCon(ADest);

  CheckCurrentMode(ADest);
  if AFull then
   PrintDate(ADest);
   PrintTime(ADest);
   WritelnStr:='?                  : show this text';WriteLnCon(ADest);
   WritelnStr:='RESET              : RESET MCU';WriteLnCon(ADest);
   WritelnStr:='DATE [dd.mm.yy]    : Get\Set DATE';WriteLnCon(ADest);
   WritelnStr:='TIME [hh.mm.ss]    : Get\Set TIME';WriteLnCon(ADest);
   WritelnStr:='INETCNFG           : Read Internet configuration strings';WriteLnCon(ADest);
   WritelnStr:='MPOWER [True,False]: Modem Power state';WriteLnCon(ADest);
   WritelnStr:='PINCODE            : Get\Set PIN CODE SIM CARD';WriteLnCon(ADest);
   WritelnStr:='SW1                : Get\Set SW1 [True,False]';WriteLnCon(ADest);
   WritelnStr:='SW2                : Get\Set SW2 [True,False]';WriteLnCon(ADest);
   WritelnStr:='---  BASE Init commands ---';WriteLnCon(ADest);
   WritelnStr:='GPRS_APN           : Get\Set Access Point Name MODEM';WriteLnCon(ADest);
   WritelnStr:='GPRS_LOGIN         : Get\Set LOGIN MODEM';WriteLnCon(ADest);
   WritelnStr:='GPRS_PASSWORD      : Get\Set PASSWORD MODEM';WriteLnCon(ADest);
   WritelnStr:='BROKER_IP          : Get\Set BROKER IP MODEM';WriteLnCon(ADest);
   WritelnStr:='BROKER_PORT        : Get\Set BROKER PORT MODEM';WriteLnCon(ADest);
   WritelnStr:='INTERNAL_IP        : Get     INTERNAL (CLIENT/SERVER mode) IP MODEM';WriteLnCon(ADest);
   WritelnStr:='INTERNAL_PORT      : Get\SET INTERNAL PORT (SERVER mode) MODEM';WriteLnCon(ADest);
   WritelnStr:='HARDWARE_ID        : Get\Set ID HARDWARE MODEM';WriteLnCon(ADest);
   WritelnStr:='DRYSWITCH          : Get DRYSWITCHES State ';WriteLnCon(ADest);
   WritelnStr:='HARDNUM            : Get\SET HARDWARE Number';WriteLnCon(ADest);
   WritelnStr:='STARTTIME          : Get\SET Start time Zone';WriteLnCon(ADest);
   WritelnStr:='STOPTIME           : Get\SET Stop time Zone';WriteLnCon(ADest);
   WritelnStr:='WORKZONE           : Get STARTSTOP zone';WriteLnCon(ADest);
   WritelnStr:='CUSD_BALANCE       : Get\SET CUSD BALANCE String 5 bytes';WriteLnCon(ADest);
   WritelnStr:='BALANCE            : Get BALANCE';WriteLnCon(ADest);
   WritelnStr:='STATE [RESTART]    : Get\Set CONTROLLER STATE';WriteLnCon(ADest);
   WritelnStr:='SWSTATE            : Get DrySwitches State';WriteLnCon(ADest);
   WritelnStr:='VER                : Get current version';WriteLnCon(ADest);
   WritelnStr:='---  PORTS commands ---';WriteLnCon(ADest);
   WritelnStr:='ETHERNET_DEST      : Get\SET Destination PORT for Free stream data from ETHERNET';WriteLnCon(ADest);
   WritelnStr:='RS485_DEST         : Get\SET Destination PORT for Free stream data from RS485';WriteLnCon(ADest);
   WritelnStr:='RS232_DEST         : Get\SET Destination PORT for Free stream data from RS232';WriteLnCon(ADest);
   WritelnStr:='MODEM_DEST         : Get\SET Destination PORT for Free stream data from MODEM (CSD mode)';WriteLnCon(ADest);
   WritelnStr:='RS232_BAUD         : Get\SET Default BAUD for RS232';WriteLnCon(ADest);
   WritelnStr:='RS485_BAUD         : Get\SET Default BAUD for RS485';WriteLnCon(ADest);
   WritelnStr:='SWITCHMASK         : Get\SET Mask for check DrySwitchers state';WriteLnCon(ADest);
   WritelnStr:='SWITCHMODE         : Get\SET Mode Sending SMS on DrySw change state [0-no send; 1-(0/1) ;2 - (1/0);3-(any change)]';WriteLnCon(ADest);
   WritelnStr:='EREMOTE_IP         : Get\SET IP ADDR REMOTE Server for EW-PORT connection';WriteLnCon(ADest);
   WritelnStr:='EREMOTE_PORT       : Get\SET Port ADDR REMOTE Server for EW-PORT connection';WriteLnCon(ADest);
   WritelnStr:='ELOCAL_IP          : Get\SET LOCAL IP of EW-PORT';WriteLnCon(ADest);
   WritelnStr:='EMASK              : Get\SET NET MASK of EW-PORT';WriteLnCon(ADest);
   WritelnStr:='EGATEWAY           : Get\SET NET GATEWAY of EW-PORT';WriteLnCon(ADest);
   WritelnStr:='EDYNAMIC_IP        : Get\SET DYNAMIC IP MODE of EW-PORT';WriteLnCon(ADest);
   WritelnStr:='ECLIENTACTIVE      : Get     EW-PORT CLIENT STATE';WriteLnCon(ADest);
   WritelnStr:='ETH_PRESENT        : Get EW-PORT availability';WriteLnCon(ADest);
   WritelnStr:='ETH_CONTROL        : Get\SET Control mode for EW-PORT command accessing';WriteLnCon(ADest);
   WritelnStr:='V_CONSOLE          : Get\SET default Debug Messages CONSOLE [RS232,RS485,ETHER,MODEM,FREE]';WriteLnCon(ADest);
   WritelnStr:='ETHERNET_CON       : Get\SET Enabling ETERNET CONSOLE Access [True,False]';WriteLnCon(ADest);
   WritelnStr:='RS485_CON          : Get\SET Enabling RS485 CONSOLE Access [True,False]';WriteLnCon(ADest);
   WritelnStr:='RS232_CON          : Get\SET Enabling RS232 CONSOLE Access [True,False]';WriteLnCon(ADest);
   WritelnStr:='MODEM_CON          : Get\SET Enabling MODEM CONSOLE Access [True,False]';WriteLnCon(ADest);
   WritelnStr:='---  FLASH commands ---';WriteLnCon(ADest);
   WritelnStr:='FLASHSIZE          : Get ONBOARD FLASH Size';WriteLnCon(ADest);
   WritelnStr:='PAGENUM            : Get\Set number of page 0..4095';WriteLnCon(ADest);
   WritelnStr:='PAGEADDR           : Get\Set start addr into page 0..511';WriteLnCon(ADest);
   WritelnStr:='PAGECOUNT          : Get\Set count of elements for READING 0..512';WriteLnCon(ADest);
   WritelnStr:='READPAGE           : READ from PAGE[PAGENUM], Inc(PAGEADDR,PAGECOUNT) MAX - one PAGE';WriteLnCon(ADest);
   WritelnStr:='WRITEPAGE          : WRITE to PAGE[PAGENUM] for PAGEADDR position PARAM1Str,Inc(PAGEADDR,LENGTH(PARAM1Str)) MAX - 128';WriteLnCon(ADest);
  endif;
end;

//
// процедура прописывает заводские знаения в адаптер
//
//
procedure HardwareDataToEEPROM;
var x:TCOMMIDX;
    i:byte;
begin
    WatchDogTrigger;
    WritelnStr:='SYSTEM HARDWARE INITIALISATION';
    WriteLnCon(V_CONSOLE);
    Stored_PINCODE:='1234';
    Stored_Inet_AP:='internet.mts.ru';//точка подключения к интернет
    Stored_Inet_Login:='mts';//точка подключения к интернет
    Stored_Inet_Password:='mts';//точка подключения к интернет
    Stored_Inet_BROKER_IP:='62.181.46.2';      //IP брокера
    
    Stored_Inet_BROKER_PORT:=10003;            //Port брокера
    Stored_Inet_REMOTE_IP:='192.168.0.101';    //IP КМД
    Stored_Inet_REMOTE_PORT:=10001;            //Port брокера

    Stored_Inet_REMOTE_IP:='192.168.0.101';    //IP КМД
    Stored_Inet_LOCAL_IP:='192.168.0.102';    //собственный IP
    Stored_Inet_MASK:='255.255.255.0';        //маска подсети
    Stored_Inet_GATEWAY:='192.168.0.1';        //шлюз
    Stored_Inet_DYNAMIC_IP:=False;

    Stored_Inet_ID_HARDWARE:=$00000000;        //ID клиента
    Stored_HARDNUM:=$00000000;                 //ID HARDWARE
    Stored_CUSD_BALANCE:='*100#';
    StartTimeZone:=8;                          //работать c 8 до 22
    StopTimeZone:=25;
    Stored_StartTimeZone:=StartTimeZone;
    Stored_StopTimeZone:=StopTimeZone;
    StoredPwd:='12345678';
    Stored_Inet_SERVER_PORT:=0;
    
   for i:=1 to MAxParam do
             WatchDogTrigger;
             Stored_ActiveParam[i]:=False;
             Stored_ModeParam[i]:=0;
             Stored_TypeOfParam[i]:=tpD;
             Stored_NumOfParam[i]:=i;
             Stored_MinParam[i]:=0;
             WatchDogTrigger;
             Stored_MaxParam[i]:=1;
             Stored_SMSMessageParam[i]:=False;
             Stored_StrMessageParam[i]:=MessageBody;
             Stored_StrMessageParam[i][24]:=char(ord('0')+i);
             Stored_TelNumParam[i]:=MessageTelNum;
   endfor;
   Stored_RTS_232:=0;

    
    //восстанавливаем назначение по умолчанию
    For x:=ciMODEM to ciEthernet do
       WatchDogTrigger;
       StoredDefaultDestination[x]:=ciFree;
       if x<>ci485 then
          StoredEnableConsole[x]:=True;
       else
          StoredEnableConsole[x]:=False;
       endif;
       XCOMM[x].DefaultDestination:=ciFree;
    endfor;
    StoredDefaultBaud[ci232]:=sb38400;
    StoredDefaultBaud[ci485]:=sb9600;
    XCOMM[ci232].DefaultBaud:=sb38400;
    XCOMM[ci485].DefaultBaud:=sb9600;
    StoredV_CONSOLE:=ci232;
    CheckStoredSystemKS(True);
    CheckSystemKS(True);
end;

//
// процедура восстанавливает данные из постоянной памяти
//
procedure RestoreDataFromEEPROM;
var x:TCOMMIDX;
begin
    BALANCE:='?руб';
    //если контрольная сумма системной области в порядке - то
    wKSPDRESTORE:=$FFFF;//восстановить все
    SystemRestore;
    if CheckStoredSystemKS(False) then
       WritelnStr:='CRC Ok! Parametrs restored';
       WriteLnCon(V_CONSOLE);
       WatchDogTrigger;
    endif;
    WatchDogTrigger;
    CheckSystemKS(True);//фиксируем контрольную сумму зоны настроек
    WatchDogTrigger;
end;


//
// сравнение конфигурационных данных
//
//   1. ЕСЛИ СЕАНС БЫЛ АКТИВЕН
//
//    поменялись точка доступа ($80) или логин ($40) или пароль ($20)
//    игнорируем это
//
//    поменялся ID прибора ($01)
//    меняем его без разрыва соединения за 3 шага -
//    1. восстанавливаем режим данных
//    2. посылаем строку инициализации TBN#0llLLhhHH
//    3. возвращаемся к обслуживанию канала
//
//    поменялся IP брокера ($04) или номер порта ($02) = ($06)
//    меняем его без разрыва MODEM сессии за 3 шага
//    1. разрываем сокетное соединение ATH
//    2. меняем DESTINFO
//    3. устанаваем новое сокетное соединение
//    4. посылаем строку инициализации TBN#0llLLhhHH
//    5. возвращаемся к обслуживанию канала
//
//   1. ЕСЛИ СЕАНС НЕБЫЛ АКТИВЕН
//   2. меняем все параметры
//   3. сбрасываем регистрацию контента
//   4. регистрируем контент
//   5. активируем MODEM сессию
//   6. меняем DESTINFO
//   7. устанаваем новое сокетное соединение
//   8. посылаем строку инициализации TBN#0llLLhhHH
//   9. возвращаемся к обслуживанию канала
//
function InitialDataDifferent:byte;
var DataDifferent:byte;
    i:byte;
    len:byte;
begin
  DataDifferent:=0;
  len:=Length(Stored_Inet_AP);
  for i:=1 to len do
     if (Stored_Inet_AP[i]<>Inet_AP[i]) and (Inet_AP[i]<>' ') then
     DataDifferent:=$0080;
     break;
    endif;
  endfor;

  len:=Length(Stored_Inet_Login);
  for i:=1 to len do
     if (Stored_Inet_Login[i]<>Inet_Login[i]) and (Inet_Login[i]<>' ') then
     DataDifferent:=DataDifferent or $0040;
     break;
    endif;
  endfor;

  len:=Length(Stored_Inet_Password);
  for i:=1 to len do
     if (Stored_Inet_Password[i]<>Inet_Password[i]) and (Inet_Password[i]<>' ') then
      DataDifferent:=DataDifferent or $0020;
      break;
    endif;
  endfor;

  len:=Length(Stored_Inet_BROKER_IP);
  for i:=1 to len do
     if (Stored_Inet_BROKER_IP[i]<>Inet_BROKER_IP[i]) and (Inet_BROKER_IP[i]<>' ') then
      DataDifferent:=DataDifferent or $0004;
      break;
    endif;
  endfor;

  if Stored_Inet_BROKER_PORT<>Inet_BROKER_PORT then
     DataDifferent:=DataDifferent or $0002;
  elsif Stored_Inet_ID_HARDWARE<>Inet_ID_HARDWARE then
     DataDifferent:=DataDifferent or $0001;
  endif;

  return(DataDifferent);
end;



//
// процедура сохраняет значения памяти в ЕЕПРОМ
//
procedure SoftwareDataToEEPROM;
begin
    Stored_PINCODE:=PINCODE;
    Stored_Inet_AP:=Inet_AP;
    Stored_Inet_Login:=Inet_Login;
    Stored_Inet_Password:=Inet_Password;
    Stored_Inet_BROKER_IP:=Inet_BROKER_IP;
    Stored_Inet_BROKER_PORT:=Inet_BROKER_PORT;                    //Port брокера
    Stored_Inet_REMOTE_IP:=Inet_REMOTE_IP;
    Stored_Inet_REMOTE_PORT:=Inet_REMOTE_PORT;                    //Port брокера
    Stored_Inet_LOCAL_IP:=Inet_LOCAL_IP;
    Stored_Inet_MASK:=Inet_MASK;
    Stored_Inet_GATEWAY:=Inet_GATEWAY;

    Stored_Inet_ID_HARDWARE:=Inet_ID_HARDWARE;                        //ID клиента
    Stored_HARDNUM:=HARDNUM;                        //ID HARDWARE
    Stored_CUSD_BALANCE:=CUSD_BALANCE;
    Stored_StartTimeZone:=StartTimeZone;                  //час начала подключения
    Stored_StopTimeZone:=StopTimeZone;                   //час окончания подключения
    CheckStoredSystemKS(True);
end;



//================================================================
// Поиск в буфере строки максимальной длиной не более 11 символов
//================================================================
function EFindInBuff(SubStr:string[30]):integer;
var res:boolean;
    posx,i,j,
    len,aLen:integer;
begin
   ALen:=integer(Length(SubStr));
   len:=LenIOBuff(ciEthernet);
   posx:=0;
   if len>0 then
       for i:=0 to len-1 do
          res:=True;
          for j:=0 to ALen-1 do
            if ByteIOBuff(ciEthernet,i+j)<>ord(SubStr[j+1]) then
               res:=False;
              break;
            endif;
          endfor;
          if res then
            posx:=i+1;
            break;
          endif;
      endfor;//j
   endif;
   if posx>0 then
        EthernetTimeOutCount:=0;
   endif;
   return(posx);
end;









procedure Str2Ethernet;
var i,len:byte;
begin
 {$IFDEF DBG}
  if (debug and 8) = 8 then
     WriteLnStr:='[seth]';
     WriteLnCon(V_CONSOLE);
  endif;
 {$ENDIF}
  len:=Length(CmdStr);
  Excl(KSPDSTATE,ks_FPE);
  ETHERNETTimeOut:=1;//взводим ожидание ответа от устройства на 1 сек
  Incl(KSPDCONTROL,kc_ECR);

  with xcomm[ciEthernet] do
  for i:=1 to len do
      SerOut(CmdStr[i]);
      {$IFDEF DBG}
      if (Debug and 4) = 4 then
          WriteConCh(V_CONSOLE,CmdStr[i]);
      endif;
      {$ENDIF}
  endfor;
  endwith;
end;

procedure InitPorts;
begin
  DDRB:=  %01110110;
  DDRD:=  %00011000;   //
  PORTD:= %01100100;   //Присутствие +
  DDRE:=  %10110010;
  PORTE:= %00000001;   //подтянул прием по EW-Port
  DDRG:=  %00100000;
  DDRH:=  %00001110;
  PORTH:= %00000001;   //Rx
  DDRJ:=  %00100110;
  PORTJ:= %00000001;   //Rx
  DDRK:=  %00000001;   //LED5
  PORTK:= %00000000;   //LED5

  PORTF:= %00000000;   //LED4..LED1
  DDRF:=  %11110000;   //LED4..LED1

  PORTC:= %00000111;   //сухие + SDCARD_PRESENT
  DDRC:=  %00001000;   //CS_для SD
  PORTG:= %00000011;   //сухие


  //настройка первого UART
  UCSR0B:=%10011011;//сбрасываем TXCIE,UDRIE,CHR9 Ethernet
  UCSR1B:=%10011011;//сбрасываем TXCIE,UDRIE,CHR9 RS485
  UCSR2B:=%10011011;//сбрасываем TXCIE,UDRIE,CHR9 RS232
  UCSR3B:=%10011011;//сбрасываем TXCIE,UDRIE,CHR9 MODEM MODEM

  //
  MessageLed:=False;
  EICRB:=EICRB or %00110000;//прерывание по нарастанию
  EIMSK:=EIMSK or %01000000;//разрешаем прерывание от IO10 - (INT6)

  InitSPI;
  
end InitPorts;


procedure Pow_On;
begin
{$IFDEF DBG}
  if (Debug and 1) = 1 then
     WriteLnStr:='Pow_On';
     WriteLnCon(V_CONSOLE);
  endif;
{$ENDIF}
  MODEM_IO13:=True;
  MODEM_PWON:=False;
  mdelay(63);
  MODEM_ROW4:=True;
  mdelay(120);//более 120 мсек
  MODEM_PWON:=True;
  MODEM_DTR:=True;
  MODEM_RTC:=False;
  mdelay(100);
  Incl(KSPDSTATE,ks_MPOWER);
end;

procedure Pow_Off;
begin
{$IFDEF DBG}
  MODEM_RTC:=False;
  if (Debug and 1) = 1 then
     WriteLnStr:='Pow_Off';
     WriteLnCon(V_CONSOLE);
  endif;
{$ENDIF}
  MODEM_ROW4:=False;
  mdelay(30);
  MODEM_ROW4:=True;
  MODEM_IO13:=False;
  mdelay(200);
  MODEM_IO13:=True;
  MODEM_RTC:=False;
  Excl(KSPDSTATE,ks_MPOWER);
end;




(*
//формат СМС в юникоде
//+CMGR: "REC UNREAD","уцЬХ¦П]т:",,"08/11/06,11:14:26+18",208,64,0,8,"79168960220",145,132
//050003AB030100740062006E002000670020006D007400730020006D0074007300200069006E007400650072006E00650074002E006D00740073002E00720075002000380039002E003200300037002E00370033002E003500320020003100300030003000330020003100360035003900370030003000310039000A00490050003A0020
 +CUSD: 0,"041704300434043E043B04360435043D043D043E04410442044C003A002D0036002C00310031044004430431",72
 Задолженность:-6,11руб
 +CUSD: 0,"04110430043B0430043D0441003A00380038002C00380039044004430431",72
 Баланс:88,89руб
 +CUSD: 0,"4E61207363686574653A20313035342E3330207275622E20566573656C796520726F7A79677279736869206920736875746B6920766D6573746F206775646B6F7621205A766F6E69206E6120303737302C2076797A6F7620626573706C61746E796A21",15
Na schete: 1054.30 rub. Veselye rozygryshi i shutki vmesto gudkov! Zvoni na 0770, vyzov besplatnyj!
Ваш баланс -2.08руб. Звони 0756, разыграй друзей  1 апреля 17р
+CUSD: 0,"041204300448002004310430043B0430043D0441002000390033002E00340034044004430431002E0421043A04380434043A0430002000390039043F0440043E044600200432043D044304420440043800200441043504420438003A0438043D0444043E0020003000350039003000330032",72
Ваш баланс 93.44руб.Скидка 99проц внутри сети:инфо???
Баланс:192,53руб
Service is temporary unavailable
 *)

procedure DecodeSMS(APS:byte);
var nextcopy:boolean;
    s2,s3,s32,prewS,s4:byte;
    ps,psw:byte;
begin
    BalanceStr:='';
   {$IFDEF DBG}
    if (Debug and 8) = 8 then
      WritelnStr:='[dsms] ';
      WriteLnCon(V_CONSOLE);
    endif;
   {$ENDIF}
    PS:=APS+12;//встаем на первый символ СМС
    psw:=1;//начинаем затирать СМС с первого символа
    prewS:=$FF;
    nextcopy:=False;//копируется ли сл. символ в хранилище
    if (ResStr[ps]='0') and (ResStr[ps+1]='4') then
      while ps<Length(ResStr) do
      WatchDogTrigger;
      s3:=ord(ResStr[ps])-$30;
      s32:=ord(ResStr[ps+1])-$30;
      if (s3 in [0..22]) and (s32 in [0..22]) then
        s2:=((h_tbl[s3]) shl 4) + (h_tbl[s32]);
        {$IFDEF DBG}
        MyByteToHex(s2);
        if (Debug and $80) = $80 then
          WriteConCh(V_CONSOLE,B2HStr[2]);
          WriteConCh(V_CONSOLE,B2HStr[1]);
        endif;
        {$ENDIF}
        Inc(ps,2);
        if nextcopy then
           if prewS=4 then
              s2:=(s2-$10)+'А';
           endif;
           ResStr[psw]:=char(s2);
           if psw<50 then
              BalanceStr:=BalanceStr+s2;
           endif;
           inc(psw);
        endif;
        nextcopy:=(s2=0) or (s2=4);
        if nextCopy then
           prewS:=s2;
        endif;
      else
        break;
      endif;
     endwhile;
    else
      EncodeLatinBuff(ps);
    endif;
    SetLength(ResStr,psw+2);
    ResStr[psw+1]:=' ';
    ResStr[psw+2]:=char($FF);
end;



procedure SendStateSMS;
var i:byte;
    len:byte;
begin
       len:=length(TMP_TEL_NUM);
       if len=12 then
               {$IFDEF DBG}
               if (Debug and 1) = 1 then
                 WritelnStr:='Send state in SMS...';WriteLnCon(V_CONSOLE);
               endif;
               {$ENDIF}
               CmdStr:='AT+CMGS="'+TMP_TEL_NUM+'"';
               Str2Modem;//посылаем СМС
               
               //первый буфер
               for i:=1 to InputBuff_Console_LenParam1 do
                   WaitModemCTS;
                   SerOut4(InputBuff_Console_Param1[i]);
                   WaitOutByte2Modem;
               endfor;
               
               //второй буфер
               for i:=1 to InputBuff_Console_LenParam2 do
                   WaitModemCTS;
                   SerOut4(InputBuff_Console_Param2[i]);
                   WaitOutByte2Modem;
               endfor;

               WaitModemCTS;
               SerOut4(CTRLZ);
               WaitOutByte2Modem;

               SMSSended:=True;
       endif;
end;


function DisassembleSMS(APS:byte):boolean;
var ps,i:byte;
    res:boolean;
    Ch:char;
    prob:byte;
begin
    with XCOMM[ciModem] do
            //    CMCCRC:word;                                  //расчетная цифровая подпись
            CMCCRC:=0;
            res:=True;
            {$IFDEF DBG}
            if (Debug and 1) = 1 then
                WritelnStr:='Разбираем СМС...';
                WriteLnCon(V_CONSOLE);
            endif;
            {$ENDIF}
            //tbn g gdata gdata internet 89.207.73.52 10003 267697674
            PS:=APS;
            tmp_Inet_Login:='';//Space10;
            //разбираем СМС
            //встали на Login = копируем
            Inc(ps,6);//ушли за сигнатуру
            //ищем начало логина
            prob:=0;
            while ResStr[PS]=' ' do Inc(PS); Inc(prob);
                WatchDogTrigger;
                if prob>10 then
                   res:=False;
                endif;
            endwhile;
            if not Res then
              return(False);
            else
              prob:=0;
            endif;
            for i:=1 to 10 do
                if ResStr[PS]<>' ' then
                   Ch:=ResStr[PS];
                   CMCCRC:=CMCCRC+ord(Ch);
                   tmp_Inet_Login:=tmp_Inet_Login+Ch;
                else
                   break;
                endif;
                Inc(ps);
            endfor;

            //ище начало пароля
            while ResStr[PS]=' ' do
                WatchDogTrigger;
                Inc(PS);
                Inc(prob);
                if prob>10 then
                   res:=False;
                endif;
            endwhile;

            if not Res then
              return(False);
            else
              prob:=0;
            endif;

            tmp_Inet_Password:='';//Space10;
            //копируем пароль
            for i:=1 to 10 do
               if ResStr[PS]<>' ' then
                  Ch:=ResStr[PS];
                  CMCCRC:=CMCCRC+ord(Ch);
                  tmp_Inet_Password:=tmp_Inet_Password+Ch;
               else
                  break;
               endif;
               Inc(ps);
            endfor;

            //ищем начало точки подключения
            while ResStr[PS]=' ' do
                WatchDogTrigger;
                Inc(PS);
                Inc(prob);
                if prob>10 then
                   res:=False;
                endif;
            endwhile;

            if not Res then
              return(False);
            else
              prob:=0;
            endif;

            tmp_Inet_AP:='';//4;
            //копируем точку подключения
            for i:=1 to 20 do
               if ResStr[PS]<>' ' then
                  Ch:=ResStr[PS];
                  CMCCRC:=CMCCRC+ord(Ch);
                  tmp_Inet_AP:=tmp_Inet_AP+Ch;
               else
                  break;
               endif;
               Inc(ps);
            endfor;

            while ResStr[PS]=' ' do
                WatchDogTrigger;
                Inc(PS);
                Inc(prob);
                if prob>10 then
                   res:=False;
                endif;
            endwhile;

            if not Res then
              return(False);
            else
              prob:=0;
            endif;
            
            tmp_Inet_BROKER_IP:='';//Space15;
            //копируем IP брокера
            for i:=1 to 15 do
               if ResStr[PS]<>' ' then
                  Ch:=ResStr[PS];
                  CMCCRC:=CMCCRC+ord(Ch);
                  tmp_Inet_BROKER_IP:=tmp_Inet_BROKER_IP+Ch;
               else
                  break;
               endif;
               Inc(ps);
            endfor;

            //ищем начало номера порта брокера
            while ResStr[PS]=' ' do
                WatchDogTrigger;
                Inc(PS);
                Inc(prob);
                if prob>10 then
                   res:=False;
                endif;
            endwhile;

            if not Res then
              return(False);
            else
              prob:=0;
            endif;
            
            tmpStr:='';

            //копируем номер порта брокера
            for i:=1 to 5 do
               if ResStr[PS]<>ord(' ') then
                  Ch:=ResStr[PS];
                  CMCCRC:=CMCCRC+ord(Ch);
                  tmpStr:=tmpStr+Ch;
               else
                  break;
               endif;
               Inc(ps);
            endfor;
            
            res:=False;
            tmp_Inet_BROKER_PORT:=StrToInt(tmpStr);
            if tmp_Inet_BROKER_PORT>0 then
               res:=True;
            endif;

            if not Res then
              return(False);
            else
              prob:=0;
            endif;

            //ищем начало номера ID прибора
            while ResStr[PS]=' ' do
                WatchDogTrigger;
                Inc(PS);
                Inc(prob);
                if prob>10 then
                   res:=False;
                endif;
            endwhile;

            if not Res then
              return(False);
            else
              prob:=0;
            endif;
            
            tmpStr16:='';
            //копируем ID
            for i:=1 to 9 do
               Ch:=ResStr[PS];
               CMCCRC:=CMCCRC+ord(Ch);
               tmpStr16:=tmpStr16+Ch;
               Inc(ps);
            endfor;
            tmp_Inet_ID_HARDWARE:=StrToInt(tmpStr16);

            //ищем начало цифровой подписи
            while ResStr[PS]=' ' do
                WatchDogTrigger;
                Inc(PS);
                Inc(prob);
                if prob>10 then
                   res:=False;
                endif;
            endwhile;

            if not Res then
              return(False);
            else
              prob:=0;
            endif;
            MyIntToHex(integer(CMCCRC));
            //проверяем цифровую подпись
            for i:=1 to 4 do
               if ResStr[PS]<>' ' then
                  Ch:=ResStr[PS];
                  if I2HStr[i]<>Ch then
                     res:=False;
                  endif;
               endif;
               Inc(ps);
            endfor;
    endwith;
    return(res);
end;





procedure CSQ2Led;
begin
         //состояние сигнала
          if CSQ in [1..5] then
             LedCounter:=1;
          elsif CSQ in [6..11] then
             LedCounter:=2;
          elsif CSQ in [12..15] then
             LedCounter:=3;
          elsif CSQ in [16..20] then
             LedCounter:=4;
          elsif CSQ in [21..31] then
             LedCounter:=5;
          else
             //нет сигнала - не горит
             LedCounter:=0;
          endif;
          if (not Switcher_1) then
             LedValue(LedCounter);
          endif;
end;

procedure SetDATE;
begin
  setDay(day);
  setMonth(month);
  setYear(year);

end;

procedure SetTIME;
begin
  setSecond(second);
  setMinute(minute);
  setHour(hour);
end;




procedure ReSendCoonsoleStrToEPORT(ADest:TCOMMIDX);
var i:integer;
begin
 if ADEst = ci232 then
  //with XCOMM[ADest] do
  if LenIOBuff(ADest)>1 then
     for i:=1 to LenIOBuff(ADest)-1 do
        SerOut(ByteIOBuff(ADest,i));
     endfor;
  endif;
 endif;
end;


//==================================================
// заставляет контроллер перепроверить все параметры
//==================================================
procedure EthernetRewriteParam(AReconnect:boolean);
begin
         //===========================
         // Переподключение EW-Port
         //===========================
         {$IFDEF DBG}
         if (debug and 4) = 4 then
             WriteLnStr:='[REWR EWPORT]';
             WriteLnCon(V_CONSOLE);
         endif;
         {$ENDIF}
end;

//
// выводим текущую страницу в ADest
//
procedure ReadPage(ADest:TCOMMIDX);
var i:byte;
    bb    : byte;
    w,WLen     : word;
begin
(*   WritelnStr('';
   PageToBuffer(0, FPNUM);//считали в 1 буфер FPNUM страницу с адреса FPAddr
   if FPCount>512 then FPCount:=0;endif;//ограничиваем максимальным размером страницы
   //заполняем буфер
   i:=0;//количество байт для вывода
   WLen:=(512-FPAddr);//максимальный остаток возможный для чтения с текущей позиции
   if FPCount<WLen then //если считать требуется меньше остатка - ограничиваем размер необходимый для чтения
     WLen:=FPCount;
   endif;
   w:=FPAddr;//начальный адрес чтения буфера
   FPAddr:=(w+WLen) mod 512;//сдвигаем начальный адрес чтения на величину считанного
   while WLen>0 do
         ReadFromBuffer(0, @bb, w, 1);//считываем 1 байт
         inc(w);inc(i);Dec(WLen);
         WritelnStr(WritelnStr+char(bb);
         if i=128 then
            i:=0;
            WriteLnCon(ADest);
            WritelnStr('';
         endif;
   endwhile;
   if i<>0 then
      WriteLnCon(ADest);
   endif;
  *)
end;


//
// записываем в текущую страницу WritelnStr c позиции PAddr
//
procedure WritePage;
var i:byte;
    bb    : byte;
    w,WLen     : word;
begin
(*   PageToBuffer(0, FPNUM);//считали в 1 буфер FPNUM страницу с адреса FPAddr - так ка кстраница больше
   FPCount:=word(Length(WritelnStr));
   if FPCount>128 then FPCount:=128;endif;
   //заполняем буфер
   i:=1;//индекс элемента в буфере
   WLen:=(512-FPAddr);//максимальный остаток возможный для чтения с текущей позиции
   if FPCount<WLen then //если считать требуется меньше остатка - ограничиваем размер необходимый для чтения
     WLen:=FPCount;
   endif;
   w:=FPAddr;//начальный адрес чтения буфера
   FPAddr:=(w+WLen) mod 512;//сдвигаем начальный адрес чтения на величину считанного
   while WLen>0 do
         bb:=ord(WritelnStr[i]);
         WriteToBuffer(0, @bb, w, 1);//считываем 1 байт
         inc(w);inc(i);Dec(WLen);
   endwhile;
   if i>1 then
         BufferToPage(0, FPNUM);
   endif;*)
end;



function DisassembleConsoleCmd(UBufNum:byte;ADest:TCOMMIDX):boolean;
var
    InCmd:byte;//0- в команде 1 - параметр 1 2- параметр 2
    Ch:char;
    i,Count:integer;
    Disassembled:boolean;
begin
   Disassembled:=True;
   Count:=UBuff[UBufNum].Count;
   {$IFDEF DBG}
   if (debug and 8) = 8 then
        WritelnStr:='[DCC]: RESEND UBUF '+byteToStr(UBufNum)+' COUNT '+intToStr(Count)+' OWNER '+OwnerName[ADest];
        WriteLnCon(V_CONSOLE);
   endif;
   {$ENDIF}
   if (Count=0) or (Count>254) then
        return(False);
   else
        InCmd:=0;
        InputBuff_Console_CMD:='';
        InputBuff_Console_Param1:='';
        InputBuff_Console_Param2:='';
        InputBuff_Console_LenParam1:=0;
        InputBuff_Console_LenParam2:=0;

        for i:=0 to Count-1 do
            Ch:=char(UBuff[UBufNum].Buff[i]);
            case InCmd of
            0:
               //сохраняем команду
               if Ch in [cSpace,13,10] then
                  InCmd:=1;
               else
                  if i<=20 then
                    if not (Ch in [10,13]) then
                     InputBuff_Console_CMD:=InputBuff_Console_CMD+char(UpCase(Ch));
                    endif;
                  endif;
               endif;
            |
            1:
               //ищем окончание пробелов
               if not (Ch in [cSpace,13,10]) then
                  InputBuff_Console_Param1:=Ch;
                  InputBuff_Console_LenParam1:=1;
                  InCmd:=2;
               endif;
            |
            2:
               //сохраняем параметр 1
               if not (Ch in [cSpace,13,10]) then
                  InputBuff_Console_Param1:=InputBuff_Console_Param1+Ch;
                  Inc(InputBuff_Console_LenParam1);
               else
                  InCmd:=3;
               endif;
            |
            3:
               //ищем окончание пробелов
               if not (Ch in [cSpace,13,10]) then
                  InputBuff_Console_Param2:=Ch;
                  InputBuff_Console_LenParam2:=1;
                  InCmd:=4;
               endif;
            |
            4:
               //сохраняем параметр 2
               if not (Ch in [cSpace,13,10]) then
                  InputBuff_Console_Param2:=InputBuff_Console_Param2+Ch;
                  Inc(InputBuff_Console_LenParam2);
               endif;
            |
            endcase;
        endfor;
        if (debug and 8)=8 then
             WritelnStr:='InputBuff_Console_CMD '+InputBuff_Console_CMD;WriteLnCon(ADest);
             WritelnStr:='InputBuff_Console_PARAM1 '+InputBuff_Console_PARAM1;WriteLnCon(ADest);
             WritelnStr:='InputBuff_Console_PARAM2 '+InputBuff_Console_PARAM2;WriteLnCon(ADest);
        endif;

        if CompareStr(InputBuff_Console_CMD,'RESET') then
               if ks_ACCESS_EN in KSPDSTATE then
                   TestReset:=True;
                   WritelnStr:='Reset MCU...';
                   WriteLnCon(ADest);
                   StoreIntegral(1);
                   StoreIntegral(2);
                   StoreIntegral(3);
                   StoreIntegral(4);
               else
                   WritelnStr:=cAccessDenied;
                   WriteLnCon(ADest);
               endif;
        elsif CompareStr(InputBuff_Console_CMD,'UBUFFVIEW') then
               for i:=0 to UBufCount-1 do
                    WatchDogTrigger;
                    with UBuff[i] do
                        WritelnStr:=intToStr(i)+' Owner:'+OwnerName[Owner]+' BufNum '+intToStr(BufNum)+' State '+byteToStr(State)+' Count '+intToStr(Count);
                        WriteLnCon(ADest);
                    endwith;
               endfor;
        elsif CompareStr(InputBuff_Console_CMD,'XCOMMVIEW') then
               for i:=ord(ciMODEM) to ord(ciV_CON) do
                   WatchDogTrigger;
                   with xcomm[TCOMMIDX(i)] do
                         WritelnStr:=' Owner:'+OwnerName[TCOMMIDX(i)]+' LastUBuff:'+byteToStr(LastUBuff)+' IncDec '+intToStr(IncDec)+' CurBufNum '+intToStr(CurBufNum)+' ResendUBuff '+ByteToStr(ResendUBuff);
                         WriteLnCon(ADest);
                   endwith;
               endfor;
          elsif CompareStr(InputBuff_Console_CMD,'SLOTS') then
              for i:=0 to 6 do
                  With Slot[i] do
                      WritelnStr:=intToStr(i)+' A:'+BoolName[ord(active) and 1]
                                             +' M:'+ByteToStr(ord(Mode))
                                             +' D:'+BoolName[ord(ModemHasData) and 1]
                                             +' I:'+IntToStr(IDLECount)
                                             +' IP:'+ByteToStr(IPBody[1])
                                             +'.'+ByteToStr(IPBody[2])
                                             +'.'+ByteToStr(IPBody[3])
                                             +'.'+ByteToStr(IPBody[4]);
                  endwith;
                  WriteLnCon(ADest);
              endfor;//
          elsif CompareStr(InputBuff_Console_CMD,'ETHERNET_CON') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 XCOMM[ciEthernet].ENABLECONSOLE:=CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE');
                 StoredENABLECONSOLE[ciEthernet]:=XCOMM[ciEthernet].ENABLECONSOLE;
                 CheckStoredSystemKS(True);
                 CheckSystemKS(True);
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;
               endif;
               WritelnStr:=BoolName[ord(XCOMM[ciEthernet].ENABLECONSOLE) and 1];
               WriteLnCon(ADest);
          elsif CompareStr(InputBuff_Console_CMD,'RS485_CON') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                     XCOMM[ci485].ENABLECONSOLE:=CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE');
                     StoredENABLECONSOLE[ci485]:=XCOMM[ci485].ENABLECONSOLE;
                     CheckStoredSystemKS(True);
                     CheckSystemKS(True);
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;
               endif;
               WritelnStr:=BoolName[ord(XCOMM[ci485].ENABLECONSOLE) and 1];
               WriteLnCon(ADest);
          elsif CompareStr(InputBuff_Console_CMD,'RS232_CON') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                  XCOMM[ci232].ENABLECONSOLE:=CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE');
                  StoredENABLECONSOLE[ci232]:=XCOMM[ci232].ENABLECONSOLE;
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;
               endif;
               WritelnStr:=BoolName[ord(XCOMM[ci232].ENABLECONSOLE) and 1];
               WriteLnCon(ADest);
          elsif CompareStr(InputBuff_Console_CMD,'MODEM_CON') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                  XCOMM[ciMODEM].ENABLECONSOLE:=CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE');
                  StoredENABLECONSOLE[ciMODEM]:=XCOMM[ciMODEM].ENABLECONSOLE;
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;
               endif;
               WritelnStr:=BoolName[ord(XCOMM[ciMODEM].ENABLECONSOLE) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'V_CONSOLE') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 for x:=ciMODEM to ciFree do
                  if CompareStr(UpperCASE(InputBuff_Console_PARAM1),OWNERNAME[x]) then
                     if x in [ciMODEM..ciEthernet,ciFree] then
                       V_CONSOLE:=x;
                       StoredV_CONSOLE:=x;
                       CheckStoredSystemKS(True);
                       CheckSystemKS(True);
                       break;
                     endif;
                  endif;
                 endfor;
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;
               endif;
               WritelnStr:=OWNERNAME[V_CONSOLE];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'SHORTMSG') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                  ShortMsg:=CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE');
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;
               endif;
               WritelnStr:=BoolName[ord(ShortMsg) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'PARAM') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     WritelnStr:='Active='+BoolName[ord(params[Count].Active) and 1];WriteLnCon(ADest);
                     WritelnStr:='Mode='+ByteToStr(params[Count].Mode);WriteLnCon(ADest);
                     WritelnStr:='Num='+ByteToStr(params[Count].NumParam);WriteLnCon(ADest);
                     WritelnStr:='Type='+ParamTypeName[params[Count].TypeOfParam];WriteLnCon(ADest);
                     if params[Count].TypeOfParam=tpD then
                        //для датчика положения отображаем только текущее и предыдущее состояние
                        WritelnStr:='PredState='+BoolName[ord(params[Count].PredState) and 1];WriteLnCon(ADest);
                        WritelnStr:='CurState='+BoolName[ord(params[Count].CurState) and 1];WriteLnCon(ADest);
                     elsif params[Count].TypeOfParam=tpI then
                        //для датчика положения отображаем только текущее и предыдущее состояние
                        WritelnStr:='Integral='+longToStr(params[Count].lValue);WriteLnCon(ADest);
                        WritelnStr:='PredVal='+FloatToStr(Float(params[Count].PredVal)/60);WriteLnCon(ADest);
                        WritelnStr:='CurVal='+FloatToStr(Float(params[Count].CurVal)/60);WriteLnCon(ADest);
                        WritelnStr:='TickCount='+byteToStr(CheckParamTickCount);WriteLnCon(ADest);
                     elsif params[Count].TypeOfParam=tpA then
                        //для датчика термометра отображаем только тек
                        WritelnStr:='PredVal='+FloatToStr(Float(params[Count].PredVal)/10);WriteLnCon(ADest);
                        WritelnStr:='CurVal='+FloatToStr(Float(params[Count].CurVal)/10);WriteLnCon(ADest);
                        WritelnStr:='MinVal='+FloatToStr(Float(params[Count].MinVal)/10);WriteLnCon(ADest);
                        WritelnStr:='MaxVal='+FloatToStr(Float(params[Count].MaxVal)/10);WriteLnCon(ADest);
                        WritelnStr:='tmp='+inttoStr(temp[Count]);WriteLnCon(ADest);
                     else
                        WritelnStr:='RTC='+BoolName[lo(temp[Count]) and 1];WriteLnCon(ADest);
                     endif;
                     WritelnStr:='SMSMessage='+BoolName[ord(params[Count].SMSMessage) and 1];WriteLnCon(ADest);
                     WritelnStr:='StrMsg='+params[Count].StrMsg;WriteLnCon(ADest);
                     WritelnStr:='TelNum='+params[Count].TelNum;WriteLnCon(ADest);
                  endif;//if Count in [1..MaxParam] then
               endif;//if InputBuff_Console_PARAM1<>'' then
           elsif CompareStr(InputBuff_Console_CMD,'PCOUNT') then
               WritelnStr:=byteToStr(MaxParam);WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'PMODE') then//PARAM_MODE 1 0
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     if InputBuff_Console_PARAM2<>'' then
                        if ks_ACCESS_EN in KSPDSTATE then
                           params[Count].Mode:=StrToInt(InputBuff_Console_PARAM2) and 3;
                           Stored_ModeParam[Count]:=params[Count].Mode;
                           CheckStoredSystemKS(True);
                           CheckSystemKS(True);
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;

                     endif;
                     WritelnStr:=byteToStr(params[Count].Mode);WriteLnCon(ADest);
                  endif;
               endif;
           elsif CompareStr(InputBuff_Console_CMD,'PTYPE') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     if InputBuff_Console_PARAM2<>'' then
                        if ks_ACCESS_EN in KSPDSTATE then
                           if CompareStr(UpperCASE(InputBuff_Console_PARAM2),ParamTypeName[tpD]) then
                              params[Count].TypeOfParam:=tpD;
                           elsif CompareStr(UpperCASE(InputBuff_Console_PARAM2),ParamTypeName[tpA]) then
                              params[Count].TypeOfParam:=tpA;
                           elsif CompareStr(UpperCASE(InputBuff_Console_PARAM2),ParamTypeName[tpI]) then
                              params[Count].TypeOfParam:=tpI;
                           elsif CompareStr(UpperCASE(InputBuff_Console_PARAM2),ParamTypeName[tpFC]) then
                              if Count in [1..4] then
                                 RTS_232:=lo(Count);
                                 Stored_RTS_232:=RTS_232;
                              endif;
                           else
                              params[Count].TypeOfParam:=tpU;
                           endif;
                           if params[Count].TypeOfParam<>tpU then
                              Stored_TypeOfParam[Count]:=params[Count].TypeOfParam;
                              CheckStoredSystemKS(True);
                              CheckSystemKS(True);
                           else
                              params[Count].TypeOfParam:=Stored_TypeOfParam[Count];
                           endif;
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;
                     endif;
                     WritelnStr:=ParamTypeName[params[Count].TypeOfParam];WriteLnCon(ADest);
                  endif;
               endif;
           elsif CompareStr(InputBuff_Console_CMD,'PNUM') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     if InputBuff_Console_PARAM2<>'' then
                        if (ks_ACCESS_EN in KSPDSTATE) and (params[Count].TypeOfParam=tpP) then
                           params[Count].NumParam:=StrToInt(InputBuff_Console_PARAM2);
                           Stored_NumOfParam[Count]:=params[Count].NumParam;
                           CheckStoredSystemKS(True);
                           CheckSystemKS(True);
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;

                     endif;
                     WritelnStr:=byteToStr(params[Count].NumParam);WriteLnCon(ADest);
                  endif;
               endif;
           elsif CompareStr(InputBuff_Console_CMD,'PMIN') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..4] then
                     if InputBuff_Console_PARAM2<>'' then
                        if ks_ACCESS_EN in KSPDSTATE then
                           params[Count].MinVAL:=StrToInt(InputBuff_Console_PARAM2)*10;
                           Stored_MinParam[Count]:=params[Count].MinVal;
                           CheckStoredSystemKS(True);
                           CheckSystemKS(True);
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;

                     endif;

                     WritelnStr:=FloatToStr(Float(params[Count].MINVal)/10);WriteLnCon(ADest);
                  endif;
               endif;
           elsif CompareStr(InputBuff_Console_CMD,'PMAX') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     if InputBuff_Console_PARAM2<>'' then
                        if ks_ACCESS_EN in KSPDSTATE then
                           params[Count].MAXVAL:=StrToInt(InputBuff_Console_PARAM2)*10;
                           Stored_MaxParam[Count]:=params[Count].MAXVal;
                           CheckStoredSystemKS(True);
                           CheckSystemKS(True);
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;
                     endif;
                     WritelnStr:=FloatToStr(Float(params[Count].MaxVal)/10);WriteLnCon(ADest);
                  endif;
               endif;
           elsif CompareStr(InputBuff_Console_CMD,'PCURVAL') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     WritelnStr:='CurVal='+intToStr(params[Count].CurVal);WriteLnCon(ADest);
                  endif;
               endif;
           elsif CompareStr(InputBuff_Console_CMD,'PSENDSMS') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..4] then
                     if InputBuff_Console_PARAM2<>'' then
                        if ks_ACCESS_EN in KSPDSTATE then
                           params[Count].SMSMessage:=CompareStr(UpperCASE(InputBuff_Console_PARAM2),'TRUE');
                           Stored_SMSMessageParam[Count]:=params[Count].SMSMessage;
                           CheckStoredSystemKS(True);
                           CheckSystemKS(True);
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;
                     endif;
                     WritelnStr:=BoolName[ord(params[Count].SMSMessage) and 1];WriteLnCon(ADest);
                  endif;
               endif;
           elsif CompareStr(InputBuff_Console_CMD,'PACTIVE') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     if InputBuff_Console_PARAM2<>'' then
                        if ks_ACCESS_EN in KSPDSTATE then
                           params[Count].Active:=CompareStr(UpperCASE(InputBuff_Console_PARAM2),'TRUE');
                           if not params[i].Active then
                              ParamState_VAL[Count]:='A';
                           else
                              ParamState_VAL[Count]:='x';
                           endif;
                           Stored_ActiveParam[Count]:=params[Count].Active;
                           CheckStoredSystemKS(True);
                           CheckSystemKS(True);
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;
                     endif;
                     WritelnStr:=BoolName[ord(params[Count].Active) and 1];WriteLnCon(ADest);
                  endif;
               endif;
          elsif CompareStr(InputBuff_Console_CMD,'PMESSAGE') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     if InputBuff_Console_PARAM2<>'' then
                        if (ks_ACCESS_EN in KSPDSTATE) and (Length(InputBuff_Console_PARAM2)<=25) then
                           params[Count].StrMsg:=InputBuff_Console_PARAM2;
                           Stored_StrMessageParam[Count]:=params[Count].StrMsg;
                           CheckStoredSystemKS(True);
                           CheckSystemKS(True);
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;
                     endif;
                     WritelnStr:=params[Count].StrMsg;WriteLnCon(ADest);
                  else
                     WritelnStr:='Ex: PMESSAGE 1..4';WriteLnCon(ADest);
                  endif;
               endif;
          elsif CompareStr(InputBuff_Console_CMD,'PTELNUM') then
               if InputBuff_Console_PARAM1<>'' then
                  Count:=StrToInt(InputBuff_Console_PARAM1);//номер параметра
                  if Count in [1..MaxParam] then
                     if InputBuff_Console_PARAM2<>'' then
                        if (ks_ACCESS_EN in KSPDSTATE) and (Length(InputBuff_Console_PARAM2)<=12) then
                           params[Count].TelNum:=InputBuff_Console_PARAM2;
                           Stored_TelNumParam[Count]:=params[Count].TelNum;
                           CheckStoredSystemKS(True);
                           CheckSystemKS(True);
                        else
                           WritelnStr:=cAccessDenied;
                           WriteLnCon(ADest);
                        endif;
                     endif;
                     WritelnStr:=params[Count].TelNum;WriteLnCon(ADest);
                  endif;
               endif;
          elsif CompareStr(InputBuff_Console_CMD,'PRTS') then
               WritelnStr:=byteToStr(RTS_232);WriteLnCon(ADest);
          elsif CompareStr(InputBuff_Console_CMD,'ANSWERSLOTS') then
               WritelnStr:='MODEM   : '+byteToStr(XCOMM[ciModem].AnswerSlot);WriteLnCon(ADest);
               WritelnStr:='Ethernet: '+byteToStr(XCOMM[ciEthernet].AnswerSlot);WriteLnCon(ADest);
               WritelnStr:='RS232   : '+byteToStr(XCOMM[ci232].AnswerSlot);WriteLnCon(ADest);
               WritelnStr:='RS485   : '+byteToStr(XCOMM[ci485].AnswerSlot);WriteLnCon(ADest);
               WritelnStr:='V_CON   : '+byteToStr(XCOMM[ciV_CON].AnswerSlot);WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'ETH_PRESENT') then
               WritelnStr:=BoolName[ord(ETH_PRESENT) and 1];WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'ETH_CONTROL') then
               if InputBuff_Console_PARAM1<>'' then
                  if ks_ACCESS_EN in KSPDSTATE then
                      ETH_CONTROL:=CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE');
                  else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                  endif;
               endif;
               WritelnStr:=BoolName[ord(ETH_CONTROL) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'ENABLECSD') then
               WritelnStr:=BoolName[ord(ENABLECSD) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'MODEM_DEST') then
               if InputBuff_Console_PARAM1<>'' then
                  if ks_ACCESS_EN in KSPDSTATE then
                 for x:=ci485 to ciFree do
                  if CompareStr(UpperCASE(InputBuff_Console_PARAM1),OWNERNAME[x]) then
                     if x in [ci232,ciEthernet,ci485,ciFree] then
                       XCOMM[ciModem].DefaultDestination:=x;
                       StoredDefaultDestination[ciMODEM]:=x;
                       CheckStoredSystemKS(True);
                       CheckSystemKS(True);
                       break;
                     endif;
                  endif;
                 endfor;
                  else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                  endif;
               endif;
               WritelnStr:=OWNERNAME[XCOMM[ciModem].DefaultDestination];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'RS232_DEST') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 for x:=ciMODEM to ciFree do
                  if CompareStr(UpperCASE(InputBuff_Console_PARAM1),OWNERNAME[x]) then
                     if x in [ciMODEM,ciEthernet,ci485,ciFree] then
                       XCOMM[ci232].DefaultDestination:=x;
                       StoredDefaultDestination[ci232]:=x;
                       CheckStoredSystemKS(True);
                       CheckSystemKS(True);
                       break;
                     endif;
                  endif;
                 endfor;
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=OWNERNAME[XCOMM[ci232].DefaultDestination];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'RS485_DEST') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 for x:=ciMODEM to ciFree do
                  if CompareStr(UpperCASE(InputBuff_Console_PARAM1),OWNERNAME[x]) then
                     if x in [ciMODEM,ciEthernet,ci232,ciFree] then
                       XCOMM[ci485].DefaultDestination:=x;
                       StoredDefaultDestination[ci485]:=x;
                       CheckStoredSystemKS(True);
                       CheckSystemKS(True);
                       break;
                     endif;
                  endif;
                 endfor;
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=OWNERNAME[XCOMM[ci485].DefaultDestination];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'ETHERNET_DEST') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 for x:=ciMODEM to ciFree do
                  if CompareStr(UpperCASE(InputBuff_Console_PARAM1),OWNERNAME[x]) then
                     if x in [ciMODEM,ci485,ci232,ciFree] then
                       XCOMM[ciEthernet].DefaultDestination:=x;
                       StoredDefaultDestination[ciEthernet]:=x;
                       CheckStoredSystemKS(True);
                       CheckSystemKS(True);
                       break;
                     endif;
                  endif;
                 endfor;
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=OWNERNAME[XCOMM[ciEthernet].DefaultDestination];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'SW1') then
               WritelnStr:=BoolName[ord(Switcher_1) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'SW2')then
               WritelnStr:=BoolName[ord(Switcher_2) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'WORKZONE') then
               WritelnStr:=BoolName[ord(NowWorkStateTimeZone) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'BADTIME') then
               WritelnStr:=BoolName[ord(BadTime) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'RTC') then
               WritelnStr:=BoolName[ord(MODEM_RTC) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'DEBUG') then
              if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                  DEBUG:=StrToInt(InputBuff_Console_PARAM1);
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
              endif;
              WritelnStr:=byteToStr(DEBUG);
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'ks_ACCESS_EN in KSPDSTATE') then
              WritelnStr:=BoolName[ord(ks_ACCESS_EN in KSPDSTATE) and 1];
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'HANDLEMODE') then
              if (InputBuff_Console_PARAM1<>'') then
                if ks_ACCESS_EN in KSPDSTATE then
                  if CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE') then
                     HANDLEMODE:=True;
                     //Pauses[ci232]:=True;
                  else
                     HANDLEMODE:=False;
                  endif;
                  if HANDLEMODE then
                     WritelnStr:='Внимание! Логика отключена!';
                     WriteLnCON(V_CONSOLE);
                  endif;
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
              endif;
              WritelnStr:=BoolName[ord(HANDLEMODE) and 1];
              WriteLnCon(ADest);

           elsif CompareStr(InputBuff_Console_CMD,'FLASHSIZE') then
              WritelnStr:=FlashSize;
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'PAGENUM') then
              if InputBuff_Console_PARAM1<>'' then
                 FPNUM:=StrToInt(InputBuff_Console_PARAM1);
              endif;
              WritelnStr:=IntToStr(FPNUM);
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'PAGEADDR') then
              if InputBuff_Console_PARAM1<>'' then
                 FPADDR:=StrToInt(InputBuff_Console_PARAM1);
                 if FPADDR>511 then FPADDR:=0;endif;
              endif;
              WritelnStr:=IntToStr(FPADDR);
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'PAGECOUNT') then
              if InputBuff_Console_PARAM1<>'' then
                 FPCount:=StrToInt(InputBuff_Console_PARAM1);
              endif;
              WritelnStr:=IntToStr(FPCount);
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'READPAGE') then//считывает из страницы PADDR PCOUNT байт в текущий поток
              if InputBuff_Console_PARAM1<>'' then
                 FPADDR:=StrToInt(InputBuff_Console_PARAM1);
              endif;
              ReadPage(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'WRITEPAGE') then//считывает из страницы PADDR PCOUNT байт в текущий поток
              if InputBuff_Console_PARAM1<>'' then
                 if InputBuff_Console_LenParam1<=128 then
                   if ks_ACCESS_EN in KSPDSTATE then
                    WritelnStr:=InputBuff_Console_PARAM1;
                    WritePage;
                    WritelnStr:=cOK;
                    WriteLnCon(ADest);
                   else
                    WritelnStr:=cAccessDenied;
                    WriteLnCon(ADest);
                   endif;
                 endif;
              endif;
           elsif CompareStr(InputBuff_Console_CMD,'STARTTIME') then
              if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 if Length(InputBuff_Console_PARAM1) in [1..2] then
                   StartTimeZone:=StrToInt(InputBuff_Console_PARAM1);
                   Stored_StartTimeZone:=StartTimeZone;
                   CheckStoredSystemKS(True);
                   CheckSystemKS(True);
                 endif;
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
              endif;
              WritelnStr:=byteToStr(StartTimeZone);
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'STOPTIME') then
              if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 if Length(InputBuff_Console_PARAM1) in [1..2] then
                   StopTimeZone:=StrToInt(InputBuff_Console_PARAM1);
                   Stored_StopTimeZone:=StopTimeZone;
                   CheckStoredSystemKS(True);
                   CheckSystemKS(True);
                 endif;
                else
                      WritelnStr:=cAccessDenied;
                      WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
              endif;
              WritelnStr:=byteToStr(StopTimeZone);
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'MPOWER') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                  if CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE') then
                    Pow_On;
                  else
                    InitPorts;
                    Pow_Off;
                  endif;
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=BoolName[ord(ks_MPOWER in KSPDSTATE) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'DESTINATIONS') then
              WritelnStr:='MODEM   : '+OwnerName[XCOMM[ciModem].Destination];WriteLnCon(ADest);
              WritelnStr:='Ethernet: '+OwnerName[XCOMM[ciEthernet].Destination];WriteLnCon(ADest);
              WritelnStr:='RS232   : '+OwnerName[XCOMM[ci232].Destination];WriteLnCon(ADest);
              WritelnStr:='RS485   : '+OwnerName[XCOMM[ci485].Destination];WriteLnCon(ADest);
              WritelnStr:='V_CON   : '+OwnerName[XCOMM[ciV_CON].Destination];WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'IDLECOUNTERS') then
              WritelnStr:='MODEM   : '+IntToStr(XCOMM[ciModem].IdleCounter);WriteLnCon(ADest);
              WritelnStr:='Ethernet: '+IntToStr(XCOMM[ciEthernet].IdleCounter);WriteLnCon(ADest);
              WritelnStr:='RS232   : '+IntToStr(XCOMM[ci232].IdleCounter);WriteLnCon(ADest);
              WritelnStr:='RS485   : '+IntToStr(XCOMM[ci485].IdleCounter);WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'MSTATE') then
              WritelnStr:='DT='+longToStr(NowCData);WriteLnCon(ADest);
              WritelnStr:='WD='+intToStr(MWDog);WriteLnCon(ADest);
              WritelnStr:='ModemTimeOut='+byteToStr(ModemTimeOut);WriteLnCon(ADest);
              WritelnStr:='ErrSIMCount='+byteToStr(ERRORSIMCount);WriteLnCon(ADest);
              MyByteToHex(UCSR0A);WritelnStr:='UCSR0A = '+B2HStr;WriteLnCon(ADest);
              MyByteToHex(UCSR1A);WritelnStr:='UCSR1A = '+B2HStr;WriteLnCon(ADest);
              MyByteToHex(UCSR2A);WritelnStr:='UCSR2A = '+B2HStr;WriteLnCon(ADest);
              MyByteToHex(UCSR3A);WritelnStr:='UCSR3A = '+B2HStr;WriteLnCon(ADest);
//              WritelnStr:='BAUD Ethernet = 115200| 0x'+byteToHex(UBRR0H)+byteToHex(UBRR0L);WriteLnCon(ADest);
              Hi(UBRR0):=UBRR0h;Lo(UBRR0):=UBRR0L;
              Hi(UBRR1):=UBRR1h;Lo(UBRR1):=UBRR1L;
              Hi(UBRR2):=UBRR2h;Lo(UBRR2):=UBRR2L;
              Hi(UBRR3):=UBRR3h;Lo(UBRR3):=UBRR3L;
              MyIntToHex(UBRR0);WritelnStr:='BAUD Ethernet = 38400| 0x'+I2HStr;WriteLnCon(ADest);
              MyIntToHex(UBRR1);WritelnStr:='BAUD RS485    = '+SpeedNames[ACTUALSPEED[1]]+' | 0x'+I2HStr;WriteLnCon(ADest);
              MyIntToHex(UBRR2);WritelnStr:='BAUD RS232    = '+SpeedNames[ACTUALSPEED[2]]+' | 0x'+I2HStr;WriteLnCon(ADest);
              MyIntToHex(UBRR3);WritelnStr:='BAUD MODEM    = 9600| 0x'+I2HStr;WriteLnCon(ADest);
              WritelnStr:='StartTime = '+byteToStr(StartTimeZone)+' StopTime = '+byteToStr(StopTimeZone);WriteLnCon(ADest);
              WritelnStr:='MTOCount = '+byteToStr(ModemTimeOutCount);WriteLnCon(ADest);
              WritelnStr:='GMTCount = '+byteToStr(GlobalModemTimeOutCount);WriteLnCon(ADest);
              WritelnStr:='ETOCount = '+byteToStr(EthernetTimeOutCount);WriteLnCon(ADest);
              WritelnStr:='M_RepeatShiftCounter = '+intToStr(M_RepeatShiftCounter)+' E_RepeatShiftCounter = '+intToStr(E_RepeatShiftCounter);
              WriteLnCon(ADest);
              //WriteLnCon(ADest, 'MODEM_APN           : Get\Set Access Point Name MODEM');
           elsif CompareStr(InputBuff_Console_CMD,'GPRS_APN') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=20) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_AP:='';//Space20;
                  for i:=1 to InputBuff_Console_LenParam1 do
                    Inet_AP:=Inet_AP+InputBuff_Console_PARAM1[i];
                  endfor;
                  Stored_Inet_AP:=Inet_AP;
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=Inet_AP;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'GPRS_LOGIN') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=10) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_Login:='';//Space10;
                  for i:=1 to InputBuff_Console_LenParam1 do
                    Inet_Login:=Inet_Login+InputBuff_Console_PARAM1[i];
                  endfor;
                  Stored_Inet_Login:=Inet_Login;
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=Inet_Login;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'GPRS_PASSWORD') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=10) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_Password:='';//Space10;
                  for i:=1 to InputBuff_Console_LenParam1 do
                    Inet_Password:=Inet_Password+InputBuff_Console_PARAM1[i];
                  endfor;
                  Stored_Inet_Password:=Inet_Password;
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=Inet_Password;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'BROKER_IP') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=15) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_BROKER_IP:='';//Space15;
                  for i:=1 to InputBuff_Console_LenParam1 do
                    Inet_BROKER_IP:=Inet_BROKER_IP+InputBuff_Console_PARAM1[i];
                  endfor;
                  Stored_Inet_BROKER_IP:=Inet_BROKER_IP;
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=Inet_BROKER_IP;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'INTERNAL_IP') then
               WritelnStr:=Inet_INTERNAL_IP;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'BROKER_PORT') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=5) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_BROKER_PORT:=StrToInt(InputBuff_Console_PARAM1);
                  Stored_Inet_BROKER_PORT:=Inet_BROKER_PORT;                    //Port брокера
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=IntToStr(Inet_BROKER_PORT);
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'INTERNAL_PORT') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=5) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_SERVER_PORT:=StrToInt(InputBuff_Console_PARAM1);
                  Stored_Inet_SERVER_PORT:=Inet_SERVER_PORT;                    //Port брокера
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=IntToStr(Inet_SERVER_PORT);
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'EREMOTE_IP') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=15) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_REMOTE_IP:='';//Space15;
                  for i:=1 to InputBuff_Console_LenParam1 do
                    Inet_REMOTE_IP:=Inet_REMOTE_IP+InputBuff_Console_PARAM1[i];
                  endfor;
                  Stored_Inet_REMOTE_IP:=Inet_REMOTE_IP;
                  ReSendCoonsoleStrToEPORT(ADest);
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=Inet_REMOTE_IP;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'EREMOTE_PORT') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=5) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_REMOTE_PORT:=StrToInt(InputBuff_Console_PARAM1);
                  Stored_Inet_REMOTE_PORT:=Inet_REMOTE_PORT;                    //Port брокера
                  ReSendCoonsoleStrToEPORT(ADest);
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=IntToStr(Inet_REMOTE_PORT);
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'ELOCAL_IP') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=15) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_LOCAL_IP:='';//Space15;
                  for i:=1 to InputBuff_Console_LenParam1 do
                    Inet_LOCAL_IP:=Inet_LOCAL_IP+InputBuff_Console_PARAM1[i];
                  endfor;
                  Stored_Inet_LOCAL_IP:=Inet_LOCAL_IP;
                  ReSendCoonsoleStrToEPORT(ADest);
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=Inet_LOCAL_IP;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'EMASK') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=15) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_MASK:='';//Space15;
                  for i:=1 to InputBuff_Console_LenParam1 do
                    Inet_MASK:=Inet_MASK+InputBuff_Console_PARAM1[i];
                  endfor;
                  Stored_Inet_MASK:=Inet_MASK;
                  ReSendCoonsoleStrToEPORT(ADest);
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then

               endif;
               WritelnStr:=Inet_MASK;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'EGATEWAY') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=15) then
                if ks_ACCESS_EN in KSPDSTATE then
                  Inet_GATEWAY:='';//Space15;
                  for i:=1 to InputBuff_Console_LenParam1 do
                    Inet_GATEWAY:=Inet_GATEWAY+InputBuff_Console_PARAM1[i];
                  endfor;
                  Stored_Inet_GATEWAY:=Inet_GATEWAY;
                  ReSendCoonsoleStrToEPORT(ADest);
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=Inet_GATEWAY;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'EDYNAMIC_IP') then
               if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                  INET_DYNAMIC_IP:=CompareStr(UpperCASE(InputBuff_Console_PARAM1),'TRUE');
                  STORED_INET_DYNAMIC_IP:=INET_DYNAMIC_IP;
                  ReSendCoonsoleStrToEPORT(ADest);
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                  EthernetRewriteParam(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=BoolName[ord(INET_DYNAMIC_IP) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'ECLIENTACTIVE') then
               WritelnStr:=BoolName[ord(Inet_CLIENT_STATE) and 1];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'CLEARPWD') then
               tmp_PWD:='********';
               Excl(KSPDSTATE,ks_ACCESS_EN);
               WritelnStr:='PASSWORD CLEARED';
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'HARDWARE_ID') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1<=9) then
                  if ks_ACCESS_EN in KSPDSTATE then
                    Inet_ID_HARDWARE:=StrToInt(InputBuff_Console_PARAM1);
                    Stored_Inet_ID_HARDWARE:=Inet_ID_HARDWARE;                        //ID клиента
                    CheckStoredSystemKS(True);
                    CheckSystemKS(True);
                  else
                    WritelnStr:=cAccessDenied;
                    WriteLnCon(ADest);
                  endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=LongToStr(Inet_ID_HARDWARE);
               WriteLnCon(ADest);
           elsif InputBuff_Console_CMD[1]='?' then
              signon(True,ADest);
           elsif CompareStr(InputBuff_Console_CMD,'BUILD') then
               WritelnStr:=LongToStr(HARDNUM);
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'HARDNUM') then
               if (InputBuff_Console_PARAM1<>'') then
                  HARDNUM:=StrToInt(InputBuff_Console_PARAM1);
                  if Stored_HARDNUM=0 then
                     Stored_HARDNUM:=HARDNUM;
                  else
                     HARDNUM:=Stored_HARDNUM;
                  endif;
                  //ID клиента
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
               endif;
               WritelnStr:=LongToStr(HARDNUM);
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'RS485_BAUD') then
               if (InputBuff_Console_PARAM1<>'')then
                if ks_ACCESS_EN in KSPDSTATE then
                 for Y:=sb2400 to sb115200 do
                  if CompareStr(InputBuff_Console_PARAM1,SpeedNames[y]) then
                     XCOMM[ci485].DefaultBaud:=y;
                     StoredDefaultBaud[ci485]:=y;
                     ActualSpeed[1]:=y;
                     MySerBaud(2,TSpeedBaud(y));
                     CheckStoredSystemKS(True);
                     CheckSystemKS(True);
                     break;
                  endif;
                 endfor;
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=SpeedNames[ActualSpeed[1]];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'RS232_BAUD') then
               if (InputBuff_Console_PARAM1<>'')then
                if ks_ACCESS_EN in KSPDSTATE then
                 for Y:=sb2400 to sb115200 do
                  if CompareStr(InputBuff_Console_PARAM1,SpeedNames[y]) then
                     XCOMM[ci232].DefaultBaud:=y;
                     StoredDefaultBaud[ci232]:=y;
                     ActualSpeed[2]:=y;
                     MySerBaud(3,TSpeedBaud(y));
                     CheckStoredSystemKS(True);
                     CheckSystemKS(True);
                     break;
                  endif;
                 endfor;
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=SpeedNames[ActualSpeed[2]];
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'CUSD_BALANCE') then
               if (InputBuff_Console_PARAM1<>'') and (InputBuff_Console_LenParam1=5) then
                if ks_ACCESS_EN in KSPDSTATE then
                  CUSD_BALANCE:=InputBuff_Console_PARAM1;
                  Stored_CUSD_BALANCE:=CUSD_BALANCE;
                  CheckStoredSystemKS(True);
                  CheckSystemKS(True);
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=CUSD_BALANCE;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'BALANCE') then
               WritelnStr:=BALANCE;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'BALANCESTR') then
               WritelnStr:=BalanceStr;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'PINCODE') then
               if (InputBuff_Console_LenParam1=4) and ((not (ks_MBROKER in KSPDSTATE)) and (not (ks_MSERVER in KSPDSTATE))) then
                if ks_ACCESS_EN in KSPDSTATE then
                    PINCODE[1]:=InputBuff_Console_PARAM1[1];
                    PINCODE[2]:=InputBuff_Console_PARAM1[2];
                    PINCODE[3]:=InputBuff_Console_PARAM1[3];
                    PINCODE[4]:=InputBuff_Console_PARAM1[4];
                    Stored_PINCODE:=PINCODE;
                    CheckStoredSystemKS(True);
                    CheckSystemKS(True);
                    TestReset:=True;
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
               endif;
               WritelnStr:=PINCODE;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'R_ERROR') then
                 MyintToHex(Integer(wKSPDERROR));
                 WritelnStr:=I2HStr;WriteLnCon(V_CONSOLE);
           elsif CompareStr(InputBuff_Console_CMD,'R_CONTROL') then
                 MyintToHex(Integer(wKSPDCONTROL));
                 WritelnStr:=I2HStr;WriteLnCon(V_CONSOLE);
           elsif CompareStr(InputBuff_Console_CMD,'R_STATE') then
                 MyintToHex(Integer(wKSPDSTATE));
                 WritelnStr:=I2HStr;WriteLnCon(V_CONSOLE);
           elsif CompareStr(InputBuff_Console_CMD,'R_RESTORE') then
                 MyintToHex(Integer(wKSPDRESTORE));
                 WritelnStr:=I2HStr;WriteLnCon(V_CONSOLE);
           elsif CompareStr(InputBuff_Console_CMD,'STEPS') then
                 WritelnStr:='HardwareCheckedStep  ='  +byteToStr(HardwareCheckedStep);WriteLnCon(ADest);
                 WritelnStr:='SMSEngineMustWorkStep='  +byteToStr(SMSEngineMustWorkStep);WriteLnCon(ADest);
                 WritelnStr:='ServerMustWorkStep   ='  +byteToStr(ServerMustWorkStep);WriteLnCon(ADest);
                 WritelnStr:='BrokerMustWorkStep   ='  +byteToStr(BrokerMustWorkStep);WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'OVERFLOW') then
                 if InputBuff_Console_PARAM1<>'' then
                    XCOMM[ci485].incdec:=0;XCOMM[ci485].overflow:=False;
                    XCOMM[ci232].incdec:=0;XCOMM[ci232].overflow:=False;
                    xCOMM[ciEthernet].incdec:=0;xCOMM[ciEthernet].overflow:=False;
                    XCOMM[ciMODEM].incdec:=0;XCOMM[ciModem].overflow:=False;
                 endif;
                 WritelnStr:=' RS485   :'+intToStr(XCOMM[ci485].incdec)+' overflow '+byteToStr(XCOMM[ci485].overflow);WriteLnCon(ADest);
                 WritelnStr:=' RS232   :'+intToStr(XCOMM[ci232].incdec)+' overflow '+byteToStr(XCOMM[ci232].overflow);WriteLnCon(ADest);
                 WritelnStr:=' ETHERNET:'+intToStr(xCOMM[ciEthernet].incdec)+' overflow '+byteToStr(xCOMM[ciEthernet].overflow);WriteLnCon(ADest);
                 WritelnStr:=' MODEM   :'+intToStr(XCOMM[ciMODEM].incdec)+' overflow '+byteToStr(XCOMM[ciModem].overflow);WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'INETCNFG') then
                 WritelnStr:=' HARDWARE ID  :'+LongToStr(Inet_ID_HARDWARE);WriteLnCon(ADest);
                 WritelnStr:=' Access Point :'+Inet_AP;WriteLnCon(ADest);
                 WritelnStr:=' Login        :'+Inet_Login;WriteLnCon(ADest);
                 WritelnStr:=' Password     :'+Inet_Password;WriteLnCon(ADest);
                 WritelnStr:=' BROKER   IP  :'+Inet_BROKER_IP;WriteLnCon(ADest);
                 WritelnStr:=' BROKER   PORT:'+IntToStr(Inet_BROKER_PORT);WriteLnCon(ADest);
                 WritelnStr:=' INTERNAL IP  :'+Inet_INTERNAL_IP;WriteLnCon(ADest);
                 WritelnStr:=' INTERNAL PORT:'+IntToStr(Inet_SERVER_PORT);WriteLnCon(ADest);
                 WritelnStr:=' HARDWARE NUM :'+LongToStr(HARDNUM);WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'MODEMINFO') then
                 WritelnStr:=' Modem       :'+MODEM_NAME1+' '+MODEM_NAME2+' '+MODEM_REVIS+' IMEI:'+MODEM_IMEI;WriteLnCon(ADest);
                 WritelnStr:=' SUBVER      :'+ByteToStr(M33GSubVer);WriteLnCon(ADest);
                 WritelnStr:=' OPERATOR    :'+OPERATOR;WriteLnCon(ADest);
                 WritelnStr:=' SIGNAL      :'+CSQ_VAL;WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'CRCFLASH') then
                 CheckStoredSystemKS(False);
                 MyIntToHex(Integer(Stored_SYSTEM_KS));WritelnStr:=' CRC FLASH='+I2HStr;
                 MyIntToHex(Integer(CRC));WritelnStr:=WritelnStr+',CALCFLASH='+I2HStr;WriteLnCon(ADest);
                 CheckSystemKS(False);
                 MyIntToHex(Integer(SYSTEM_KS));WritelnStr:=' CRC RAM='+I2HStr;
                 MyIntToHex(Integer(CRC));WritelnStr:=WritelnStr+',CALCRAM='+I2HStr;WriteLnCon(ADest);
                 MyintToHex(Integer(wKSPDRESTORE));WritelnStr:='R_RESTORE='+I2HStr;WriteLnCon(V_CONSOLE);
           elsif CompareStr(InputBuff_Console_CMD,'SYS_RESTORE') then
                 SystemRestore;
           elsif CompareStr(InputBuff_Console_CMD,'DATE') then
              if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 PresetTime:=True;
                 tmpStr2:=copy(InputBuff_Console_PARAM1,1,2);
                 day:=StrToInt(tmpStr2);
                 tmpStr2:=copy(InputBuff_Console_PARAM1,4,2);
                 month:=StrToInt(tmpStr2);
                 tmpStr2:=copy(InputBuff_Console_PARAM1,7,2);
                 year:=StrToInt(tmpStr2);
                 SetDate;
                 PresetTime:=False;
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
              endif;
              PrintDate(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'TIME') then
              if InputBuff_Console_PARAM1<>'' then
                if ks_ACCESS_EN in KSPDSTATE then
                 PresetTime:=True;
                 tmpStr2:=copy(InputBuff_Console_PARAM1,1,2);
                 hour:=StrToInt(tmpStr2);
                 tmpStr2:=copy(InputBuff_Console_PARAM1,4,2);
                 minute:=StrToInt(tmpStr2);
                 tmpStr2:=copy(InputBuff_Console_PARAM1,7,2);
                 second:=StrToInt(tmpStr2);
                 SetTime;
                 PresetTime:=False;
                else
                  WritelnStr:=cAccessDenied;
                  WriteLnCon(ADest);
                endif;//if ks_ACCESS_EN in KSPDSTATE then
              endif;
              PrintTime(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'STATE') then
                 CreateResponce_42_2;
                 WritelnStr:=InputBuff_Console_Param1;
                 WriteLnCon(ADest);
                 WritelnStr:=InputBuff_Console_Param2;
                 WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'PASSWORD') then
               if InputBuff_Console_LenParam1 in [1..8] then
                    if ks_ACCESS_EN in KSPDSTATE then
                       if not CompareStr(tmp_PWD,InputBuff_Console_PARAM1) then
                          tmp_PWD:=InputBuff_Console_PARAM1;
                          if not CompareStr(tmp_Pwd,grandpwd) then
                             WritelnStr:='New Password installed!';
                             WriteLnCon(ADest);
                             ActualPwd:=tmp_PWD;
                             StoredPwd:=ActualPwd;
                             CheckStoredSystemKS(True);
                             CheckSystemKS(True);
                          endif;
                       endif;
                    else
                       tmp_PWD:=InputBuff_Console_PARAM1;
                    endif;
               endif;
               CheckAccess;
               if ks_ACCESS_EN in KSPDSTATE then
                  WritelnStr:='access granted!';
               else
                  WritelnStr:=cAccessDenied;
               endif;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'GETPASSWORD') then
               CheckAccess;
               if ks_ACCESS_EN in KSPDSTATE then
                  WritelnStr:='PASSWORD:'+StoredPwd;
               else
                  WritelnStr:=cAccessDenied;
               endif;
               WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'SWSTATE') then
              CreateDrySwitchStateSMS;
              WritelnStr:=InputBuff_Console_Param1;
              WriteLnCon(ADest);
              WritelnStr:=InputBuff_Console_Param2;
              WriteLnCon(ADest);
           elsif CompareStr(InputBuff_Console_CMD,'HARDSETTINGS') then
              if ks_ACCESS_EN in KSPDSTATE then
                 HardwareDataToEEPROM;
              else
                 WritelnStr:=cAccessDenied;
                 WriteLnCon(ADest);
              endif;
           elsif CompareStr(InputBuff_Console_CMD,'VER') then
              WritelnStr:=curVer;
              WriteLnCon(ADest);
           else
              Disassembled:=False;
           endif;

   endif;//if (Count=0) or (Count>254) then
   return(Disassembled);
end;


function DisassembleServicePackage(UBufNum:byte;Dest:TCOMMIDX):boolean;
var
   aLen,tmpL,
   i:integer;
   tmpB:byte;
   MustNextStep:boolean;
begin
   MustNextStep:=True;
   {$IFDEF DBG}
   if (Debug and 8) = 8 then
      WriteLnStr:='[DSP:'+OwnerName[Dest]+']';
      WriteLnCon(V_CONSOLE);
   endif;
   {$ENDIF}
   aLen:=LenIOBuff(dest);

   //==================================
   //  если подключились к брокеру
   //==================================
   if aLen>12 then
       //------------------------------
       // посылка нормальных размеров
       //------------------------------
       CRC:=$FFFF;
       //01 41 63 80 E4 09 10 00 00 02 39 72 01 00 04 00 E2 EE E9 20 20 E0 F0 F5 4E 6E E1 B6
       tmpL:=12+pWord(@ResStr[7])^;//длина данных в пакете + заголовок 10 и КС 2
       tmpB:=ord(ResStr[2]);//номер команды

       for i:=1 to tmpL do
             CalcCRC(ord(ResStr[i]));
             {$IFDEF DBG}
             if (Debug and $80) = $80 then
                MyByteToHex(ord(ResStr[i]));
                WriteConCh(V_CONSOLE,B2HStr[2]);
                WriteConCh(V_CONSOLE,B2HStr[1]);
             endif;
             {$ENDIF}
       endfor;

       if CRC=0
       then
           MustNextStep:=True;
           {$IFDEF DBG}
           if (debug and 8) = 8 then
              WritelnStr:='[CRC Ok!]';WriteLnCon(V_CONSOLE);
           endif;
           {$ENDIF}
           //
           // сохраняем тип команды
           //
           XCOMM[dest].Cmd:=tmpB;

           case tmpB of
           $41:
             //
             // Транзитная команда
             //
             with XCOMM[dest] do
                  DestComm:=TCOMMIDX((ord(ResStr[9]) and $0F) + 1);{направление - добавился тип FREE - все сместилось на 1}
                  Baud:=TSpeedBaud(ord(ResStr[10]) and $0F);{скорость}
                  //Сохраняем заголовок и перемещаем пакет
                  for i:=1 to tmpL do
                     //байт пакета
                     tmpB:=ord(ResStr[i]);
                     //анализ - куда кинуть
                     if (i<=10)  then
                        HeaderPackage[i-1]:=tmpB;
                     elsif i<(tmpL-2) then
                        ResStr[i-9]:=char(tmpB);
                     endif;
                  endfor;
             endwith;
             //корректируем длину пакета
             SetLength(ResStr,byte(tmpL-12));

           |//$41

           $42:
             //------------------------------------------
             // команда запроса состояния прибора - STATE
             //------------------------------------------
             //сохраняем заголовок
             for i:=1 to 10 do
                 tmpB:=ord(ResStr[i]);
                 XCOMM[dest].HeaderPackage[i-1]:=tmpB;
             endfor;
             //ПРОПИСЫВАЕМ - КУДА ПЕРЕНАПРАВИТЬ ОТВЕТ
              XCOMM[dest].DestComm:=ciV_CON;
              CopyBlock(@cState[1],PtrIOBuff(dest,0),5);
              SetLenIOBuff(dest,5);
           |//$42
           endcase;

       else
         {$IFDEF DBG}
         if (debug and 8) = 8 then
            WritelnStr:='[CRC BAD! Free UBuf]';
            WriteLnCon(V_CONSOLE);
         endif;
         {$ENDIF}
(*         //
         // Не совпала контрольная сумма
         //
         //анализируем - принятые данные - возможно проиошел разрыв соединения
         //ищем в принятном пакете - NO CARRIER
         if Dest = ciModem then
           //-----------------------
           //отработка по MODEM
           //-----------------------
           if MFindInBuff('NO CARRIER')>0 then
             MRCount:=0;
             MState:=usGOTODAT;
             MWorkStepState:=0;
           elsif MFindInBuff('ERROR MODEM')>0 then
             MRCount:=0;
             GPRSActive:=False;
             MState:=usDISCONN;
             MRCount:=0;
             MWorkStepState:=0;
           endif;//не совпала контрольная сумма
         else
           //-----------------------
           //отработка по ethernet
           //-----------------------
           MustNextStep:=True;
         endif;
         *)
         MustNextStep:=False;
         FreeUBuf(XCOMM[Dest].ResendUBuff);
       endif;
   else
       //------------------------------
       // возможно пинг
       //------------------------------
       MustNextStep:=False;
   endif;
   return(MustNextStep);
end;


//========================================================================
//    В IOBuff содержится свободная посылка с  канала Ethernet/Modem
//========================================================================
function DisasmFreeStream(UBufNum:byte;ADest:TCOMMIDX):boolean;
var len:integer;
    StreamDisassembled:boolean;
begin
    StreamDisassembled:=False;
    {$IFDEF DBG}
    if (Debug and 8) = 8 then
       WritelnStr:='[DFS:'+OwnerName[ADest]+']';
       WriteLnCon(V_CONSOLE);
    endif;
    {$ENDIF}
    len:=UBuff[UBufNum].Count;
    //-------------------------------------
    // иначе передаем на порт по умолчанию
    //-------------------------------------
    if XCOMM[ADest].Destination=ciFree then
       XCOMM[ADest].Destination:=XCOMM[ADest].DefaultDestination;
       if XCOMM[ADest].EnableConsole then
             StreamDisassembled:=DisassembleConsoleCmd(UBufNum,ADest);
       endif;
    endif;

    //-----------------------------------------------------------
    // если поток не обработан выше - передаем его в порт
    // указанный по-умолчанию в DefaultDestination
    //-----------------------------------------------------------
    if not StreamDisassembled then
       case XCOMM[ADest].Destination of
          ciMODEM:
              StreamDisassembled:=True;
              if ks_MBROKER in KSPDSTATE then
                //======================================
                // Если авктивно соединение с брокером через канал модем
                // и пакет является ответным из канала Ethernet
                //======================================
                XCOMM[ADest].HeaderPackage[6]:=Lo(len);
                XCOMM[ADest].HeaderPackage[7]:=Hi(len);
              endif;
          |

          ciEthernet:
            StreamDisassembled:=True;
            //отправляем в Ethetnet и ждем ответа с подпиской на модем
            SetLenIOBuff(ciEthernet,len);
            //если это ответ - то не подписываем Destination на себя
            //если не ответ - то подписываем
           |
          ci232,ci485:
            StreamDisassembled:=True;
            //отправляем в 232 и ждем ответа с подпиской на модем
            ReAddrUBuf(UBufNum,XCOMM[ADest].Destination,XCOMM[ADest].AnswerSlot);
          |
          
          ciFree:
             StreamDisassembled:=False;
          |
        endcase;
    else
          StreamDisassembled:=False;
    endif;
    return(StreamDisassembled);
end;


function ReassembleInputBuff_Ethernet(UBufNum:byte):boolean;
var i:word;
    tmpL:word;//длина посылки
    MustNextStep:boolean;
begin
  //
  //  если сервисный режим и принятый пакет более пустого транзитного пакета
  //  проверяем контрольную сумму
  //
  RecentChange:=True;
  MustNextStep:=False;
  Incl(KSPDSTATE,ks_FPE);
  XCOMM[ciEthernet].IdleCounter:=0;


  if NOT (kc_ECR in KSPDCONTROL) then
     //===================================
     //   от Ethernet не ожидается ответа
     //===================================
     if ks_EBROKER in KSPDSTATE then
        //==================================
        //  если активно соединение с БРОКЕРОМ
        //==================================
        MustNextStep:=DisassembleServicePackage(UBufNum,ciEthernet);
     else//if EState=usSERVICE then
        MustNextStep:=DisasmFreeStream(UBufNum,ciEthernet);
     endif;
  endif;
  return(MustNextStep);
end;




interrupt Int6;//прерывание от модема - пришла СМС, питание подано,
begin
//  LED_1:=True;
  IO10happened:=True;
end;


//TCOMMIDX=(ci485,ci232,ciEthernet,ciMODEM);
//Ethernet
interrupt RXRDY0;
begin
  tmPX_E:=UDR0;
  //==================================================================================
  // в режиме когда возможен мастер ETHERNET (not Switcher_2) - принимаем все данные
  // иначе только пропускаем только ожидаемые с мастера ответы
  //==================================================================================
   if Switcher_1 then
      LED_2:=True;
   endif;
   with xcomm[ciEthernet] do
        InputBuffWaitDelay:=WaitAfterLastByte;
        if (UBuff[LastUBuff].Owner=ciEthernet) and
           (UBuff[LastUBuff].State<2) then
           UBuff[LastUBuff].Buff[UBuff[LastUBuff].Count]:=tmpX_E;
           Inc(UBuff[LastUBuff].Count);
           if UBuff[LastUBuff].Count=UBufSize then
              UBuff[LastUBuff].State:=2;
              UBuff[LastUBuff].BufNum:=CurBufNum;
              Inc(CurBufNum);//для следущего буфера номер будет увеличен на 1
           endif;
        else
          //ищем свободный буфер
          tmpUBuff:=0;
          while UBuff[LastUBuff].owner<>ciFree do
                 inc(LastUBuff);
                 LastUBuff:=(LastUBuff mod UBufCount);
                 inc(tmpUBuff);
                 if tmpUBuff>=UBufCount then
                    Overflow:=True;
                    break;
                 endif;
          endwhile;
          if UBuff[LastUBuff].Owner=ciFree then
              UBuff[LastUBuff].Owner:=ciEthernet;
              UBuff[LastUBuff].State:=1;
              UBuff[LastUBuff].Count:=1;
              UBuff[LastUBuff].Buff[0]:=tmpX_E;
          endif;
        endif;
   endwith;
end;

//485
interrupt RXRDY1;
begin
  tmPX_4:=UDR1;
  if Switcher_1 then
     LED_3:=True;
  endif;
   with XCOMM[ci485] do
        InputBuffWaitDelay:=WaitAfterLastByte;
        if (UBuff[LastUBuff].Owner=ci485) and
           (UBuff[LastUBuff].State<2) then
           UBuff[LastUBuff].Buff[UBuff[LastUBuff].Count]:=tmpX_4;
           Inc(UBuff[LastUBuff].Count);
           if UBuff[LastUBuff].Count=UBufSize then
              UBuff[LastUBuff].BufNum:=CurBufNum;
              Inc(CurBufNum);//для следущего буфера номер будет увеличен на 1
              UBuff[LastUBuff].State:=2;
           endif;
        else
          //ищем свободный буфер
          tmpUBuff:=0;
          while UBuff[LastUBuff].owner<>ciFree do
                 inc(LastUBuff);
                 LastUBuff:=(LastUBuff mod UBufCount);
                 inc(tmpUBuff);
                 if tmpUBuff>=UBufCount then
                    Overflow:=True;
                    break;
                 endif;
          endwhile;
          if UBuff[LastUBuff].Owner=ciFree then
              UBuff[LastUBuff].Owner:=ci485;
              UBuff[LastUBuff].State:=1;
              UBuff[LastUBuff].Count:=1;
              UBuff[LastUBuff].Buff[0]:=tmpX_4;
          endif;
        endif;
   endwith;//with XCOMM[ci485] do
end;

//232 - CONSOLE
interrupt RXRDY2;
begin
  tmPX_2:=UDR2;
  if Switcher_1 then
     LED_4:=True;
  endif;
  with XCOMM[ci232] do
       InputBuffWaitDelay:=WaitAfterLastByte;
       if (UBuff[LastUBuff].Owner=ci232) and
          (UBuff[LastUBuff].State<2) then
          UBuff[LastUBuff].Buff[UBuff[LastUBuff].Count]:=tmpX_2;
          Inc(UBuff[LastUBuff].Count);
          if (UBuff[LastUBuff].Count=UBufSize){ or (tmpX_2=$7E)} then
             UBuff[LastUBuff].BufNum:=CurBufNum;
             Inc(CurBufNum);//для следущего буфера номер будет увеличен на 1
             UBuff[LastUBuff].State:=2;
          endif;
       else
          tmpUBuff:=0;
          while UBuff[LastUBuff].owner<>ciFree do
                 inc(LastUBuff);
                 LastUBuff:=(LastUBuff mod UBufCount);
                 inc(tmpUBuff);
                 if tmpUBuff>=UBufCount then
                    Overflow:=True;
                    break;
                 endif;
          endwhile;
          if UBuff[LastUBuff].Owner=ciFree then
              UBuff[LastUBuff].Owner:=ci232;
              UBuff[LastUBuff].State:=1;
              UBuff[LastUBuff].Count:=1;
              UBuff[LastUBuff].Buff[0]:=tmpX_2;
          endif;
       endif;
  endwith;//with XCOMM[ci232] do
end;

//MODEM - MODEM
interrupt RXRDY3;
begin
   tmPX_M:=UDR3;
   if Switcher_1 then
      LED_5:=True;
   endif;
   with XCOMM[ciMODEM] do
        InputBuffWaitDelay:=WaitAfterLastByte;
        if (UBuff[LastUBuff].Owner=ciModem) and
           (UBuff[LastUBuff].State<2) then
           UBuff[LastUBuff].Buff[UBuff[LastUBuff].Count]:=tmpX_M;
           Inc(UBuff[LastUBuff].Count);
           if UBuff[LastUBuff].Count=UBufSize then
              UBuff[LastUBuff].BufNum:=CurBufNum;
              Inc(CurBufNum);//для следущего буфера номер будет увеличен на 1
              UBuff[LastUBuff].State:=2;
           endif;
        else
          tmpUBuff:=0;
          while UBuff[LastUBuff].owner<>ciFree do
                 inc(LastUBuff);
                 LastUBuff:=(LastUBuff mod UBufCount);
                 inc(tmpUBuff);
                 if tmpUBuff>=UBufCount then
                    Overflow:=True;
                    break;
                 endif;
          endwhile;
          if UBuff[LastUBuff].Owner=ciFree then
              UBuff[LastUBuff].Owner:=ciModem;
              UBuff[LastUBuff].State:=1;
              UBuff[LastUBuff].Count:=1;
              UBuff[LastUBuff].Buff[0]:=tmpX_M;
          endif;
        endif;
   endwith;
end;


procedure RTCtickSecond;      // CallBack from RTCclock
begin
  if not PresetTime then
     DataBody[6]:=RTCGetSecond;
  endif;
end;

procedure RTCtickMinute;      // CallBack from RTCclock
begin
  if not PresetTime then
     DataBody[5]:=RTCGetMinute;
  endif;
end;

procedure RTCtickHour;        // CallBack from RTCclock
begin
  if not PresetTime then
    DataBody[4]:=RTCGetHour;
    DataBody[3]:=RTCGetDay;
    DataBody[2]:=RTCGetMonth;
    DataBody[1]:=RTCGetYear;
  endif;
end;







//
//  процедура разбирает пакет принятый с RS232
//  вызывается при наличии данных (XCOMM[ci232].IOBuffCount<>0)
//  из процедуры ChkIBuff - ответ перенапарвляется в Destination[ci232]
//
function ReassembleInputBuff_RS232(UBufNum:byte):boolean;
var MustNextStep:boolean;
begin
 MustNextStep:=True;
 RecentChange:=True;
 XCOMM[ci232].IdleCounter:=0;
 //если неизвестно куда перенаправлять ввод - перенаправляем
 if (XCOMM[ci232].EnableConsole) or
    ((Not Switcher_1) and (Not Switcher_2)) then
     MustNextStep:=not DisassembleConsoleCmd(UBufNum,ci232);
 else
     MustNextStep:=True;
 endif;
 SetRTS(not MustNextStep);
 if MustNextStep then
    if (XCOMM[ci232].Destination=ciFree) then
        XCOMM[ci232].Destination:=XCOMM[ci232].DefaultDestination;
    endif;
    //------------------------------------------------------------
    // консоль ничего не обнаружила - идем на дальнейшую обработку
    //------------------------------------------------------------
    {$IFDEF DBG}
    if (Debug and $20) = $20 then
        WritelnStr:='[RIB_232 > '+OWNERNAME[XCOMM[ci232].Destination]+'] answerslot:'
                +byteToStr(XCOMM[ci232].AnswerSlot)+' mode:'+SLOTMODENAME[Slot[XCOMM[ci232].AnswerSlot].Mode];
        WriteLnCon(V_CONSOLE);
    endif;
    {$ENDIF}

//    if (XCOMM[ci232].ResendUBuff in [0..(UBufCount-1)]) and (UBuff[XCOMM[ci232].ResendUBuff].Owner=ci232) then
       ReAddrUBuf(XCOMM[ci232].ResendUBuff,XCOMM[ci232].Destination,XCOMM[ci232].AnswerSlot);
//    endif;
 endif;
 return(MustNextStep);
end;


(*//
//  процедура разбирает пакет принятый с виртуальной консоли
//  вызывается при наличии данных (xcomm[ciV_CON].IOBuffCount<>0) и иницации шага IOBuddStep=1
//  ответ перенапарвляется в Destination[ciV_CON]
//
function ReassembleInputBuff_VCON(UBufNum:byte):boolean;
var prev:TSpeedBaud;
begin
  //если неизвестно куда перенаправлять ввод - перенаправляем
 RecentChange:=True;
{$IFDEF DBG}
 if (Debug and $40) = $40 then
      WriteLnStr:='[RIB_VCON > '+OWNERNAME[Destination[ciV_CON]]+']';
      WriteLnCon(V_CONSOLE);
 endif;
{$ENDIF}
 DisassembleConsoleCmd(UBufNum,ciV_CON);
 case Destination[ciV_CON] of
  ciMODEM:
    //01 41 63 80 E4 09 10 02 39 72 01 00 04 00 ED ED FB E5 20 E7 ED E0 9A 3E 8A C0
    //надо сформировать ответный пакет и переслат в модем
    //корректируем байт длины
    if Slot[AnswerSlot[ciV_CON]].Mode=smClient then
      //======================================
      //  Если авктивно соединение с брокером
      //  - корректируем только длину посылки в заголовке
      //  следующий шаг - 2 - на нем будем ожидать освобождения
      //
      //======================================
      if XCOMM[ciModem].cmd=$42 then
         HeaderPackage[ciModem,6]:=Lo(LenIOBuff(ciV_CON)+1);
         HeaderPackage[ciModem,7]:=Hi(LenIOBuff(ciV_CON)+1);
      else
         HeaderPackage[ciModem,6]:=Lo(LenIOBuff(ciV_CON));
         HeaderPackage[ciModem,7]:=Hi(LenIOBuff(ciV_CON));
      endif;
    endif;
  |

  ciEthernet:
    //01 41 63 80 E4 09 10 02 39 72 01 00 04 00 ED ED FB E5 20 E7 ED E0 9A 3E 8A C0
    //надо сформировать ответный пакет и переслат в модем
    //корректируем байт длины
    if EState=usSERVICE then
      //======================================
      // Если авктивно соединение с брокером
      //======================================
      if xcomm[ciEthernet].cmd=$42 then
         HeaderPackage[ciEthernet,6]:=Lo(LenIOBuff(ciV_CON)+1);
         HeaderPackage[ciEthernet,7]:=Hi(LenIOBuff(ciV_CON)+1);
      else
         HeaderPackage[ciEthernet,6]:=Lo(LenIOBuff(ciV_CON));
         HeaderPackage[ciEthernet,7]:=Hi(LenIOBuff(ciV_CON));
      endif;
    endif;
  |
 endcase;
 return(True);
end;
*)





function ReassembleInputBuff_RS485(UBufNum:byte):boolean;
var i:integer;
    MustNextStep:boolean;
begin
  RecentChange:=True;
  MustNextStep:=True;
  XCOMM[ci485].IdleCounter:=0;
  if XCOMM[ci485].EnableConsole or
    ((Not Switcher_1) and (Not Switcher_2)) then
     MustNextStep:=not DisassembleConsoleCmd(UBufNum,ci485);
  else
     MustNextStep:=True;
  endif;
  if MustNextStep then
    if (XCOMM[ci485].Destination=ciFree) then
        XCOMM[ci485].Destination:=XCOMM[ci485].DefaultDestination;
    endif;
    {$IFDEF DBG}
    if (Debug and $20) = $20 then
        WritelnStr:='[RIB_485 > '+OWNERNAME[XCOMM[ci485].Destination]+'] answerslot:'+byteToStr(XCOMM[ci485].AnswerSlot)+' mode:'+SLOTMODENAME[Slot[XCOMM[ci485].AnswerSlot].Mode];
        WriteLnCon(V_CONSOLE);
    endif;
   {$ENDIF}
//    if (XCOMM[ci485].ResendUBuff in [0..(UBufCount-1)]) and (UBuff[XCOMM[ci485].ResendUBuff].Owner=ci485) then
       ReAddrUBuf(XCOMM[ci485].ResendUBuff,XCOMM[ci485].Destination,XCOMM[ci485].AnswerSlot);
//    endif;
  endif;
  return(MustNextStep);
end;


function GetKM5CRC(ptrB:pointer to BYTE; Len:byte):word;
var CRC:word;
    aCRC[@CRC]:array[1..2]of byte;
    i:integer;
begin
  CRC:=0;
  for i := 0 to Len-1 do
    aCRC[1]:=aCRC[1] xor pByte(WORD(ptrB)+i)^;
    aCRC[2]:=aCRC[2] + pByte(WORD(ptrB)+i)^;
  endfor;
  return(CRC);
end;


procedure InitVariables;
var x:TCOMMIDX;
    i:byte;
begin
  //устаналвинваем в начальное положение все шаги
  HardwareCheckedStep:=0;
  SMSEngineMustWorkStep:=0;
  ServerMustWorkStep:=0;
  BrokerMustWorkStep:=0;
  
  RepeatCounter:=0;
  KSPDERROR:=[];
  KSPDCONTROL:=[];
  KSPDSTATE:=[];
  
  //чтобы не было отработки таймаутов
  Incl(KSPDSTATE,ks_FPM);
  Incl(KSPDSTATE,ks_FPE);
  Incl(KSPDCONTROL,kc_SMS_CHECK);

  //освобождаем буфера
  for i:=0 to UBufCount-1 do
      UBuff[i].BufNum:=0;
      UBuff[i].State:=0;
      UBuff[i].Count:=0;
      UBuff[i].Owner:=ciFree;
  endfor;
  //статичные слоты
  SLOT[0].Mode:=smServer;
  SLOT[6].Mode:=smClient;
  RecentChange:=False;
  ID2BROKRepeat:=0;
  ShortMsg:=True;
  ForceM23:=False;
  GlobalModemTimeOutCount:=0;
  tmp_Pwd:='';
  if StoredV_CONSOLE in [ci485,ci232,ciEthernet] then
     V_CONSOLE:=StoredV_CONSOLE;
  else
     V_CONSOLE:=ci232;
  endif;
  GPRSCONTENT_COUNT:=0;//счетчик получения контента
  Inet_INTERNAL_IP:='***.***.***.***';
  WatchDogTrigger;
  ModemIOBuffLastByte:=0;//индекс последнего байта данных переданного в модем
  Excl(KSPDCONTROL,kc_IGNOREOK);
  Inet_ETH_PRESENT:=False;
  EthernetConnectCount:=0;
  //необходимо проверить СМС
  LastCheckBalance:=3601;
  //необходимо перезаписать данные в пашин контроллер
  Inet_CLIENT_MUST_RECONNECTED:=True;
  

  DEBUG:=0;//-отладка отключена
  HandleMode:=False;
  SnakeOff;
  
  ETimeOutVAlCount:=0;
  IdleICQCount:=0;
  NowWorkStateTimeZone:=True;
  tmpCh2:='00';
  DateTime_Val:='00.00.00_00:00:00';
  
  M_RepeatShiftCounter:=0;
  E_RepeatShiftCounter:=0;
  RepeatCounter:=0;

  //AUTOREQ:=True;
  ERRORSIMCount:=0;
  RECONNCOUNT:=0;
  ONLINESEK:=0;                            //счетчик секунд в онлайн режиме
  ONLINEMIN:=0;                            //счетчик минут в онлайн режиме
  ONLINEhour:=0;                           //счетчик часов в онлайн режиме
  ONLINEDAYS:=0;                           //счетчик суток
  ERRORSIM:=False;

  //временно для версии

  LedStep:=0;
  OPERATOR:='';                      //оператор
  MODEM_NAME1:='';//Space10;                   //имя модема 1
  MODEM_NAME2:='';//Space10;                   //имя модема 2
  CSQ_VAL:='  ';                          //сигнал
  ParamState_VAL:='0000';                      //сухие контакты
  CSQ:=99;

  TestReset:=False;

  //подключения нет
  SMSChecked:=False;
  GSMActive:=False;
  ContentActive:=False;                    //активность контента
  GPRSActive:=False;                       //активность MODEM сессии
  SocketActive:=False;                     //активность сокетного соединения
  
  //флаг двойного пакета сбрасываем
  DoublePack:=False;
  
  //
  // взводим таймеры
  //
  SetSysTimer(HourTimer,Lo(OneSecDelay));
  SetSysTimer(StateTimer,StateSecondDelay);
  SetSysTimer(CheckImpulseTimer,CheckImpulseDelay);
  //
  // инициализация переменых для посл. портов
  //
  for x:=ciMODEM to ciEthernet do
      xcomm[x].CurBufNum:=0;//стартовый буфер начинаем нумерацию с нуля
      WatchDogTrigger;
      XCOMM[x].Destination:=ciFree;
      XCOMM[x].IdleCounter:=0;
      XCOMM[x].AnswerSlot:=0;
      XCOMM[x].Overflow:=False;                               //время ожидания ответа в тиках
      XCOMM[x].Modify:=True;                                  //время ожидания ответа в тиках
      XCOMM[x].InputBuffWaitDelay:=1;
      XCOMM[x].DestComm:=ciFree;
      XCOMM[x].Cmd:=0;
  endfor;
  //
  xcomm[ciV_CON].DestComm:=ciFree;
//  xcomm[ciV_CON].IOBuffCount:=0;                           //Количество байт необходимых для передачи в порт COM2
  //
  // часы реального времени
  //
  PresetTime:=False;
  //
  // файловая система
  //
  //
  // RS485
  //
  Sw_485:=False;
  //
  // Проверяем сигнатуру флеш на неинициализированность
  // сброс к заводским значениям только в режиме змейки
  //
  DSw_1:=False;OSw_1:=True;//включаем подтягивающий резистор
  if (Not Switcher_1) and (Not Switcher_2) and//если в режиме змейки
     ((not ISw_1) or (Stored_Inet_AP[1]=char($FF)) ) //закорочен сухой конакт 1 или не инициализированна еепром
  then
     WatchDogTrigger;
     HardwareDataToEEPROM;
  endif;
  //восстанавливаем рабочие переменные
  MessageLed:=True;
  RestoreDataFromEEPROM;

  //скорости по умолчаню
  ActualSpeed[1]:=XCOMM[ci485].DefaultBaud; //по RS485 - 9600
  ActualSpeed[2]:=XCOMM[ci232].DefaultBaud;//по RS3232 - 38400 SerBaud4
  PrevSpeed[1]:=XCOMM[ci485].DefaultBaud;   //по RS485 - 9600
  PrevSpeed[2]:=XCOMM[ci232].DefaultBaud;  //по RS3232 - 38400 SerBaud4
  XCOMM[ci485].Baud:=ActualSpeed[1];
  XCOMM[ci232].Baud:=ActualSpeed[2];

  //загоняем делители
   {$IFDEF OLDKWARZ}
  MySERBaud(1,sb38400);      //Ethernet
  MySERBaud(4,sb38400);
   {$ELSE}
//  MySERBaud(1,sb115200);      //Ethernet
  MySERBaud(1,sb38400);      //Ethernet
//  MySERBaud(4,sb115200);      //Modem
//  MySERBaud(4,sb19200);
  MySERBaud(4,sb9600);       //Modem 1.81xr
   {$ENDIF}

   
  MySERBaud(2,ActualSpeed[1]);//485
  MySERBaud(3,ActualSpeed[2]);//232

  
  Switcher_1:=SW_1;
  Switcher_2:=SW_2;
  OldSwitcher_1:=Switcher_1;
  OldSwitcher_2:=Switcher_2;

  // Начальная изициализация переменной мастер модем
  MasterMODEM:=Switcher_1 and Switcher_2;
  EthernetRewriteParam(True);
  EnableCSD:=False;          //изначально блокируем режим CSD
  SnakeOff;
  if HardNum=0 then
     Incl(KSPDSTATE,ks_ACCESS_EN);
  else
     Excl(KSPDSTATE,ks_ACCESS_EN);
  endif;
//  LightLedState(1,0);
  SetRTS(True);
end;


//
// проверяет контрольные суммы параметров и при необходимости восстанавливает их
//
procedure CheckSystemParam;
begin
  if not CheckSystemKS(False) then
     {$IFDEF DBG}
     if (debug and 1) = 1 then
        WritelnStr:='CRC SYSAREAFLASH OK!';
        WriteLnCon(V_CONSOLE);
     endif;
     {$ENDIF}
     if CheckStoredSystemKS(False) then
        {$IFDEF DBG}
        if (debug and 1) = 1 then
           WritelnStr:='CRC SYSAREARAM OK!';
           WriteLnCon(V_CONSOLE);
        endif;
        {$ENDIF}
     else
        {$IFDEF DBG}
        if (debug and 1) = 1 then
           WritelnStr:='CRC SYSAREARAM BAD!';
           WriteLnCon(V_CONSOLE);
        endif;
        {$ENDIF}
        RestoreDataFromEEPROM;
     endif;
  else
     {$IFDEF DBG}
     if (debug and 8) = 8 then
        WritelnStr:='CRC SYSAREFLASH BAD!';
        WriteLnCon(V_CONSOLE);
     endif;
     {$ENDIF}
  endif;
end;

//  EBufCnt=6
//      [0][1][2][3][4][5]
//Write
//Read
//

function GetIP(ps:byte):longword;
var tmpIP:longword;
    IPBody[@tmpIP]:array[1..4] of byte;
    j:byte;
begin
   for j:=1 to 4 do
     Inc(ps);
     tmpStr:='';
     while (ps<=Length(ResStr)) do
           if ( ResStr[ps] in ['0'..'9'] ) then
              tmpStr:=tmpStr+ResStr[ps];
           else
              break;
           endif;
           Inc(ps);
     endwhile;
     if length(tmpStr)>0 then
        IPBody[j]:=StrToInt(tmpStr);
     else
        IPBody[j]:=0;
     endif;
   endfor;
   return(tmpIP);

end;

//
// Процедура анализирует ответ модема на предемет уведомлений,
// и найдя их реагирует согласно каждого из оных
//
function MODEM_CheckNotification(UBufNum:byte):boolean;
var
  result:boolean;
  j,i,ps,psw:byte;
  SlotNum,FCh,LCh:byte;//счетчик кавычек,номер слота,первый и второй символ подтверждения
  Param2,Param3:integer;//параметр после слота
begin
  RSSNum:=0;//изначально номер слота - свободного потока
  {$IFDEF DBG}
  if Debug <>0 then
     showanswer(ciModem);
  endif;
  {$ENDIF}
  MWDog:=0;//сбрасываем счетчик неответа модема
  result:=False;//изначально уведомлений не найдено
  ps:=MFindInBuffFromPos('$NW',0);
  //while нужна для таких команд как NWCN - где в ответе идет информация по нескольким каналам
  if ps>0 then
     while ps>0 do
        //-------------------------
        // расчет слота
        //-------------------------
        inc(ps,2);//пропускаем NW
        FCh:=ord(ResStr[ps]);inc(ps);//на след
        LCh:=ord(ResStr[ps]);Inc(ps,3);//пропускаем :_ и встаем на слот
        SlotNum:=ord(ResStr[ps])-ord('0');Inc(ps,2);//перескакиваем через запятую
        if not (SlotNum in [1..5]) then
           break;
        endif;
        //-------------------------
        // расчитываем параметр 2
        //-------------------------
        //$NWCN: 2,3,0,"10.245.0.101",3560
        //CN SLOT:2 P1:0 P2:3
        tmpStr:='';
        while (ps<=Length(ResStr)) do
              if (ResStr[ps] in ['0'..'9']) then
                 tmpStr:=tmpStr+ResStr[ps];
              else
                 break;
              endif;
              Inc(ps);
        endwhile;
        if length(tmpStr)>0 then
           Param2:=StrToInt(tmpStr);
        else
           Param2:=0;
        endif;
        //-------------------------
        //мы уже перед параметром 3 -
        //     если он есть
        //- то указатель на запятой
        //-------------------------
        tmpStr:='';
        Param3:=0;
        if ps<Length(ResStr) then
           if ResStr[ps] = ',' then
              Inc(ps);//перескакивыаем через запятую
              while (ps<=Length(ResStr)) do
               if (ResStr[ps] in ['0'..'9']) then
                  tmpStr:=tmpStr+ResStr[ps];
               else
                  break;
               endif;
               Inc(ps);
              endwhile;
              if length(tmpStr)>0 then
                 Param3:=StrToInt(tmpStr);
              endif;
           endif;
        endif;
        {$IFDEF DBG}
        if (debug and 2) = 2 then
           WritelnStr:=FCh+LCh+' SLOT:'+ByteToStr(SlotNum)+' P2:'+IntToStr(Param2)+' P3:'+IntToStr(Param3);
           WriteLnCon(V_CONSOLE);
        endif;
        {$ENDIF}

        //-------------------------
        //
        // имеем тип ответа, слот, первый и второй параметр
        //
        //-------------------------
        //$NWCN: 2,3,0,"10.245.0.101",4151
        //CN SLOT:2 P1:3 P2:0
        //разбираем по типу ответа
        if (FCh=ord('C')) and (LCh=ord('N')) then
          //пришло уведомление о подключении/отключении определеного слота $NWCH
           case TSlotMode(Param2) of
           smFree:
                 Slot[SlotNum].ACTIVE:=False;
                 CmdStr:='AT$NWSO='+char(SlotNum+ord('0'))+',0';
                 Str2Modem;//закрываем слот

                //$NWCN X,0
                //произошел разрыв соединения
                //в зависимости от того, какое соединение было до этого по этому слоту
                //будет соответствующая реакция
                if Slot[SlotNum].Mode=smClient then
                   //если соединение потерял клинет
                   if NowWorkStateTimeZone then
                      //если произошел обрыв соединения в рабочее время
                      //то выставляем флаг необходимости его возобновления
                      //MState:=usACTIV_S;
                      //MWorkStepState:=0;
                      //DataClient.State:=cssMustBeRun;
                   else
                      //если произошел обрыв соединения в нерабочее время
                      //то выставляем флаг отдыха
   //                   DataClient.State:=cssSleep;
                   endif;
                elsif Slot[SlotNum].Mode=smServer then
                   //если соединение потерял сервер
                   //и номер порта отличен от 0
                   //выставляем флаг необходимости запуска сервера на шаг анализа необходимости его запуска
   //                MState:=usACTIV_S;
   //                MWorkStepState:=0;
   //                DataServer.State:=cssCheckNextStep;
                endif;
           |
           smClient:
                 Slot[SlotNum].ACTIVE:=True;
                 Slot[SlotNum].IP:=GetIP(ps+1);
                //мы подключились в режиме клиента к брокеру - ничего не делаем
   //             DataClient.State:=cssMustRegister;//выставляем флаг необходимости регистрации на брокере
                 CmdStr:='AT$NWTXT='+char(SlotNum+ord('0'))+',60';
                 Str2Modem;//устанавливаем таймаут 1 минуту


           |
           smInProgress:
                 Slot[SlotNum].ACTIVE:=False;
                //в процессе отключения - подключения
                //ничего не делаем - можно в перспективе включить таймер и ждать изменения по каналу
           |
           smServer:
                 Slot[SlotNum].ACTIVE:=True;
                 Slot[SlotNum].IP:=GetIP(ps+1);
   //             DataServer.State:=cssRun;//выставляем флаг запуска сервера
                 //$NWCN: 2,3,0,"10.245.0.101",4151
                 //CN SLOT:2 P1:3 P2:0
                 //ps указывает на ,
                 CmdStr:='AT$NWTXT='+char(SlotNum+ord('0'))+',60';
                 Str2Modem;//устанавливаем таймаут 1 минуту

           |
           endcase;
           //сохраняем новое стотояние по слоту
           Slot[SlotNum].Mode:=TSlotMode(Param2);
           result:=True;//ДАННЫЕ РАЗОБРАНЫ
        elsif (FCh=ord('D')) then
              if (LCh=ord('W')) then
                 //DW - маловероятно, но все ж сколько данных по слоту осталось на отправку - ничего не делаем
                 result:=True;//ДАННЫЕ РАЗОБРАНЫ
              elsif (LCh=ord('R')) then
                 Slot[SlotNum].ModemHasData:=Param3>0;
                 RSSNum:=SlotNum;
                 //$NWDR: 1,0
                 //$NWDR: 2,4,0,"79000000"
                 //DR - пришли сами данные с информацией об остатке
                 //     разбираем их и в зависимости от слота и режима тут же отправляем их адресату
                 //     после чего производим их дозапрос, если еще не все
                 //     все это - если есть данные Param2>0
                 if Param2>0 then
                    XCOMM[ciModem].IdleCounter:=0;//сбрасываем флаг ожидания
                    //*******************************************
                    //              РЕЖИМ СЕРВЕРА
                    //*******************************************
                    if Slot[SlotNum].Mode=smServer then
                       //для режима сервера в режиме М2М:
                       //декодируем поток:
                       //1 - декодируем поток и отправляем
                       //2 - запрашиваем данные из буфера - если есть остаток
                       //
                       psw:=0;
                       if XCOMM[ciModem].Destination=ciFree then
                          XCOMM[ciModem].Destination:=XCOMM[ciModem].DefaultDestination;
                       endif;
                       {$IFDEF DBG}
                       if (Debug and $10) = $10 then
                           WritelnStr:='[MSERVER > '+OWNERNAME[XCOMM[ciModem].Destination]+']';
                           WriteLnCon(V_CONSOLE);
                       endif;
                       {$ENDIF}
                       inc(ps);//стояли на запятой - спрыгиваем до кавычек(")
                       if ResStr[ps]='"' then
                          inc(ps);//спрыгиваем с кавычек(")
                          if XCOMM[ciModem].Destination=ci485 then
                             Sw_485:=True;
                             udelay(5);
                          endif;
                          while (ps<=Length(ResStr)) do
                             if ResStr[ps]<>'"' then
                                FCh:=ord(ResStr[ps])-$30;
                                LCh:=ord(ResStr[ps+1])-$30;
                                if (FCh in [0..22]) and (LCh in [0..22]) then
                                    LCh:=((h_tbl[FCh]) shl 4) + (h_tbl[LCh]);
                                    Inc(ps,2);
                                    UBuff[UBufNum].Buff[psw]:=LCh;Inc(psw);//копируем в буфер
                                    if XCOMM[ciModem].Destination=ciFree then
                                       XCOMM[ciModem].Destination:=XCOMM[ciModem].DefaultDestination;
                                    endif;
                                    case XCOMM[ciModem].Destination of
                                    ciEthernet:WriteToEthernet(LCh);|
                                    ci485:WriteToRS485(LCh);|
                                    ci232:WriteToRS232(LCh);|
                                    endcase;
                                endif;
                             else
                                break;
                             endif;
                          endwhile;
                          if XCOMM[ciModem].Destination=ci485 then
                             udelay(5);
                             Sw_485:=False;
                          endif;
                       endif;//if MB[ps]=ord('"') then
                       UBuff[UBufNum].Count:=integer(psw);
                       if ((XCOMM[ciModem].Destination=ciV_CON) or XCOMM[ciModem].EnableConsole) and (i>0) then
                          //есть декодированные данные в этом же буфере - и они предназначены для консоли
                          if DisassembleConsoleCmd(UBufNum,ciV_CON) then
                             //ответ разобран - необходимо его вернуть серверу
                             //порт будет освобожден на уровне выше
                             //ответ во WritelnStr - копируем его обратно в этот буфер
                             CopyBlock(@WritelnStr[1],@UBuff[UBufNum].Buff[0],Word(Length(WritelnStr)));
                             ReSendToModem(UBufNum,ciV_CON);
                          endif;
                       endif;
                       result:=True;//ДАННЫЕ РАЗОБРАНЫ И ОТОСЛАНЫ
                    //*******************************************
                    //              РЕЖИМ КЛИЕНТА (БРОКЕР)
                    //*******************************************
                    elsif Slot[SlotNum].Mode=smClient then
                       //в режиме клиента М2М предварительно помещаем их в буфер
                       inc(ps);//стояли на запятой - спрыгиваем до кавычек(")
                       psw:=0;
                       if ResStr[ps]='"' then
                          inc(ps);//спрыгиваем с кавычек(")
                          while (ps<=Length(ResStr)) do
                             if ResStr[ps]<>'"' then
                                FCh:=Ord(ResStr[ps])-$30;
                                LCh:=Ord(ResStr[ps+1])-$30;
                                if (FCh in [0..22]) and (LCh in [0..22]) then
                                    LCh:=((h_tbl[FCh]) shl 4) + (h_tbl[LCh]);
                                    ResStr[psw]:=Char(LCh);
                                    UBuff[UBufNum].Buff[psw]:=LCh;
                                    Inc(ps,2);
                                    Inc(psw);
                                endif;
                             else
                                SetLength(ResStr,psw);
                                break;
                             endif;
                          endwhile;
                          UBuff[UBufNum].Count:=integer(psw);
                          //в буфере есть декодированная посылка
                          //ее надо передать куда следует
                          if psw>0 then
                             //т.к. это клиентский слот - то это:
                             //    либо запрос с брокера,
                             //    либо пинг,
                             //    либо подтверждение регистрации
                             if (ResStr[1]='T') and (ResStr[1]='B') and (ResStr[1]='N') then
                                         if not BadTime then
                                            BadTime:=(Day<>ord(ResStr[4])) or
                                                     (Month<>ord(ResStr[5])) or
                                                     (Year<>ord(ResStr[6])) or
                                                     (Hour<>ord(ResStr[7])) or
                                                     (Minute<>ord(ResStr[8]));
                                         endif;
                                         if psw=9 then
                                           {$IFDEF DBG}
                                           if (Debug and 1) = 1 then
                                               WritelnStr:='success registration!'; WriteLnCon(V_CONSOLE);
                                           endif;
                                           {$ENDIF}
                                           if BadTime then
                                            //в новой версии возвращается время
                                            //'T'-0 'B'-1 'N'-2 'DD'-3 'MM'-4 'YY'-5 'HH'=6 'mm'-7 'ss'-8
                                            //'T'-1 'B'-2 'N'-3 'DD'-4 'MM'-5 'YY'-6 'HH'=7 'mm'-8 'ss'-9
                                            if (ResStr[6] in [9..99]) and
                                               (ResStr[4] in [1..31]) and
                                               (ResStr[5] in [1..12]) and
                                               (ResStr[7] in [0..23]) and
                                               (ResStr[8] in [0..59]) and
                                               (ResStr[9] in [0..59])
                                            then
                                               Day:=Ord(ResStr[4]);
                                               Month:=Ord(ResStr[5]);
                                               Year:=Ord(ResStr[6]);
                                               Hour:=Ord(ResStr[7]);
                                               Minute:=Ord(ResStr[8]);
                                               Second:=Ord(ResStr[9]);
                                               SetDate;
                                               SetTime;
                                               BadTime:=False;
                                             endif;
                                           endif;
                                           Incl(KSPDSTATE,ks_MBROKER);
                                           Excl(KSPDERROR,ke_BADBROKERREG);
                                           Excl(KSPDCONTROL,kc_BROKER_SHEDULE_CONNECT);
                                         else//if (XCOMM[ciMODEM].IOBuffCount=9) then
                                           if ResStr[4]=#0 then
                                              //=============================================================
                                              //   сервер отвергает наше подключение - нет в базе данных такого
                                              //   набора hardware_id + HardNum
                                              //   отключаемся от сервера и взводим время очередного подключения на час
                                              //=============================================================
                                              {$IFDEF DBG}
                                              if (Debug and 1) = 1 then
                                                 WritelnStr:='BROKER: Warning! access dinied!'; WriteLnCon(V_CONSOLE);
                                              endif;
                                             {$ENDIF}
                                             incl(KSPDERROR,ke_BADBROKERREG);
                                             Incl(KSPDCONTROL,kc_BROKER_SHEDULE_CONNECT);
                                             M_RepeatShiftCounter:=0;
                                           endif;
                                         endif;
                             elsif ks_MBROKER in KSPDSTATE then
                                DisassembleServicePackage(UBufNum,ciMODEM);
                             endif;
                             result:=True;
                          endif;
                       endif;//if MB[ps]=ord('"') then
                    endif;
                 endif;//param2>0
                 if Param3>0 then
                    SuperVisorStep:=1;
                 endif;
                 result:=True;
              endif;
        elsif (LCh=ord('X')) then
              if (FCh=ord('T')) then
                 //TX - принято уведомление об удачной передаче пакета
                 result:=True;
              elsif (FCh=ord('R')) then
                 //RX - пришло уведомление об наличии/отсутствии
                 //     данных во входящем буфере текущего слота
                 //
                 //     необходимо проверить занятость получателя на текущий момент
                 //     и если он не занят - запросить данные из буфера слота
                 //     иначе выставить флаг-команду дял супервизора,
                 //     что в данном буфере слота лежит посылка - по этому супервизор
                 //     должен сторожить канал назначения  после коего, запросить данные
                 //     из соотв. буфера слота
                 Slot[SlotNum].ModemHasData:=Param2>0;
                 if Slot[SlotNum].Mode=smServer then
                       //для режима сервера в режиме М2М:
                       //декодируем поток:
                       //1 - декодируем поток и отправляем
                       //2 - запрашиваем данные из буфера - если есть остаток
                       //
                       if XCOMM[ciModem].Destination=ciFree then
                          XCOMM[ciModem].Destination:=XCOMM[ciModem].DefaultDestination;
                       endif;
                       //если получатель свободен
                       if Param2>0 then
                          XCOMM[XCOMM[ciModem].Destination].AnswerSlot:=SlotNum;//говорим - по какому слоту отправить ответ
                          //запрашиваем
                          CmdStr:='AT$NWDR='+char(SlotNum+ord('0'))+MaxRXReqest;
                          Str2Modem;//запрашиваем не более MAxBuff байт
                       else
                          //возможно в будущем взводим таймер тишины
                          // - пока ничего не делаем
                       endif;
                 elsif Slot[SlotNum].Mode=smClient then

                 endif;
                 result:=True;
              endif;
        endif;
        ps:=MFindInBuffFromPos('$NW',ps);
     endwhile;
  endif;
  return(result);
end;


function CheckCSDAndPing(UBufNum:byte):boolean;
var result:boolean;
begin
     {$IFDEF DBG}
     if (Debug and 8) = 8 then
                WritelnStr:='[CheckCSDAndPing]';
                WriteLnCon(V_CONSOLE);
     endif;
     {$ENDIF}
     if  kc_MCR in KSPDCONTROL then
           //--------------------------------------------------------
           // если ожидаем ответа от модема
           //--------------------------------------------------------
           if (kc_IGNOREOK in KSPDCONTROL) and (MFindInBuff('OK')>0) then
             //у М33 на каждую команду идет Ок - пропускаем
             ModemTimeOut:=120;
             Excl(KSPDSTATE,ks_FPM);
             result:=True;//якобы обработали текущий ответ
             {$IFDEF DBG}
             if (Debug and 8) = 8 then
                WritelnStr:='[IOK]';
                WriteLnCon(V_CONSOLE);
             endif;
             {$ENDIF}
           else
             {$IFDEF DBG}
             if (Debug and 8) = 8 then
                WritelnStr:='[to MainWork]';
                WriteLnCon(V_CONSOLE);
             endif;
             {$ENDIF}
           endif;
     else
           //идет чистый поток с модема - мы его не ожидали
           if ks_CSD in KSPDSTATE then
                  result:=False;
                  {$IFDEF DBG}
                  if (Debug and 1) = 1 then
                     WritelnStr:='CSD';
                     WriteLnCon(V_CONSOLE);
                  endif;
                  {$ENDIF}
                  //==================================
                  //  если произошло подключение по CSD - надо распознать момент отключения
                  //==================================
                  if MFindInBuff('NO CARRIER')>0 then
                     //----------------------------------
                     // проверяем на разрыв соединения
                     //----------------------------------
                     result:=False;
                     SLOT[0].Active:=False;
                     Excl(KSPDSTATE,ks_CSD);
                     CmdStr:='AT';
                     Str2Modem;
                     ModemTimeOut:=10;
                     Excl(KSPDCONTROL,kc_MCR);
                     {$IFDEF DBG}
                     if (Debug and 1) = 1 then
                        WritelnStr:='CSD Done...';
                        WriteLnCon(V_CONSOLE);
                     endif;
                     {$ENDIF}
                  else//if FindInBuff('NO CARRIER',True)>0 then
                     result:=DisasmFreeStream(UBufNum,ciModem);
                  endif;//if FindInBuff('NO CARRIER',True)>0 then
           else
                 if  MFindInBuff('RING')>0 then
                       {$IFDEF DBG}
                       if (Debug and 8) = 8 then
                          WritelnStr:='RING...';
                          WriteLnCon(V_CONSOLE);
                       endif;
                       {$ENDIF}
                       CmdStr:='ATA';
                       Str2Modem;
                       Slot[6].Active:=True;
                       ModemTimeOut:=10;
                       Excl(KSPDCONTROL,kc_MCR);
                       Incl(KSPDSTATE,ks_CSD);
                 else
                     {$IFDEF DBG}
                     if (Debug and 8) = 8 then
                       WritelnStr:='[no MCR]';
                       WriteLnCon(V_CONSOLE);
                     endif;
                     {$ENDIF}
                     if XCOMM[ciModem].Destination=ciFree then
                        ReAddrUBuf(XCOMM[ciModem].ResendUBuff,XCOMM[ciModem].DefaultDestination,XCOMM[ciModem].AnswerSlot);
                     else
                        ReAddrUBuf(XCOMM[ciModem].ResendUBuff,XCOMM[ciModem].Destination,XCOMM[ciModem].AnswerSlot);
                     endif;
                     
                 endif;
           endif;//if ks_CSD in KSPDSTATE then
     endif;//if  kc_MCR in KSPDCONTROL then
     return(result);
end;


function ChkIBuff(ACOMM:TCOMMIDX):boolean;
var i:byte;
    BuffHasData:boolean;
    MinNum:word;//минимальный номер пакета
    MinIdx:byte;//индекс минимального номера пакета
begin
   //
   // проверка COM3
   //
   //
   // если входной буфер содержит пакет, который необходимо обработать
   //
   with XCOMM[ACOMM] do
          // если тишина достаточная
          //если в данный момент не происходит прерывания
          if InputBuffWaitDelay<>0 then
                //декрементируем ожидание
                Dec(InputBuffWaitDelay);
          else
                //================================
                // Анализ на незакрытые буфера
                //================================
                for i:=0 to UBufCount-1 do
                   if (UBuff[i].Owner=ACOMM) and (UBuff[i].State=1)  then
                             //захватываем буфер - прочитаем в следующий раз
                             UBuff[i].State:=2;
                             UBuff[i].BufNum:=xcomm[acomm].CurBufNum;
                             inc(xcomm[acomm].CurBufNum);
                   endif;
                endfor;
                 
                //======================================
                //      Поиск закрытых буферов
                //======================================
                MinNum:=$FFFF;//необходимо найти самый ранний пакет
                BuffHasData:=False;
                for i:=0 to UBufCount-1 do
                    if (UBuff[i].Owner=ACOMM) and (UBuff[i].State=2) {and UBuff[i].FromOwner} then
                            if UBuff[i].BufNum<MinNum then
                               //ищем самый ранний пакет
                               MinNum:=UBuff[i].BufNum;
                               MinIdx:=i;
                            endif;
                            BuffHasData:=True;
                    endif;
                endfor;


                //=====================================================
                // Если есть данные в закрытых буферах по прерыванию
                //=====================================================
                if BuffHasData then
                       //если на текущий момент нет передачи
                       if Switcher_1 then //если это рабочий режим - отображаем обмен
                          if (ACOMM=ciEthernet) then
                              Led_2:=False;
                          endif;
                          if (ACOMM=ci485) then
                              Led_3:=False;
                          endif;
                          if (ACOMM=ci232) then
                              Led_4:=False;
                          endif;
                          if (ACOMM=ciModem) then
                              Led_5:=False;
                          endif;
                       endif;//if Switcher_1 then

                       //запоминаем самый ранний индекс буфера и начинаем его обработку
                       ResendUBuff:=MinIdx;
                       {$IFDEF DBG}
                       if (debug and $40) = $40 then
                          WritelnStr:='UBuf['+byteToStr(XCOMM[ACOMM].ResendUBuff)+'] << '+OwnerName[ACOMM]+' №пк '+intToStr(MinNum)+' кол '+IntToStr(UBuff[MinIdx].Count);
                          WriteLnCon(V_CONSOLE);
                       endif;
                       {$ENDIF}
                       if MinIdx in [0..UBufCount-1] then
                                //================================
                                //если данный буфер от отправителя
                                //вызываем функции Reassemble, где буфер Owner.ResendUBuff
                                //должен получить новый порт назначения и сохраниться в этом порту также слот,
                                //с которого пришел запрос
                                //================================
                                case ACOMM of
                                ciModem:
                                       //копируем в буферную строку
                                       if kc_MCR in KSPDCONTROL then Incl(KSPDSTATE,ks_FPM); endif;//если был запрос -cообщаем, что есть и ответ
                                       SetLength(ResStr,Lo(UBuff[MinIdx].Count));
                                       CopyBlock(@UBuff[MinIdx].Buff[0],@ResStr[1],Word(Lo(UBuff[MinIdx].Count)));
                                       if (not (ks_M33PRESENT in KSPDSTATE)) or (not MODEM_CheckNotification(MinIdx)) then  //проверяем на предмет нотификаций M33G и RING
                                          CheckCSDAndPing(MinIdx);
                                       endif;|
                                ci232: ReassembleInputBuff_RS232(MinIdx);|
                                ci485: ReassembleInputBuff_RS485(MinIdx);|
                                ciEthernet:
                                        if kc_ECR in KSPDCONTROL then
                                           Incl(KSPDSTATE,ks_FPE);
                                           CopyBlock(@UBuff[MinIdx].Buff[0],@ResStr[1],Word(Lo(UBuff[MinIdx].Count)));
                                        else
                                           ReassembleInputBuff_Ethernet(MinIdx);
                                        endif;//если был запрос -cообщаем, что есть и ответ
                                        |
                                endcase;
                       endif;
                       FreePort(ACOMM);
                endif;

                 
                 
          endif;
   endwith;
   return(BuffHasData);
end;


{--------------------------------------------------------------}
{ Main Program }
{$IDATA}








function ModemPresent:boolean;
begin
  if Switcher_1 and Switcher_2 then //если переключатели соответствуют обязательному наличию модема
     return(True);
  else
     return(ModemTimeOutCount<15);
  endif;
end;

function EthernetPresent:boolean;
begin
  return(EthernetTimeOutCount<3);
end;

//----------------------------------------------
// процедура конролирует изменение параметров
//----------------------------------------------
procedure CheckParam;
var i:byte;
begin
    //работаем только по активным каналам
    inctoLimWrap(CheckParamTickCount,59,0);
    for i:=1 to MaxParam do
        if params[i].Active and
          (CheckParamTickCount=59) and
          (params[i].TypeOfParam in [tpI,tpA])
        then
            if params[i].TypeOfParam=tpI then
            //tpD: - обработана на уровне захвата
            //- здесь обработка отсутствует
              //обработка импульсных входов
              //- усредняем раз в минуту
              params[i].PredVal:=params[i].CurVal;
              params[i].CurVal:=params[i].iValue-params[i].iPredValue;
              if params[i].CurVal<>0 then
                 params[i].iPredValue:=params[i].iValue;
                 StoreIntegral(i);
                 ParamState_VAL[i]:='I';
              else
                 ParamState_VAL[i]:='i';
              endif;
            elsif params[i].TypeOfParam=tpA then
              //опрос далассовских датчиков - необходимо отладить
              Read_ADC(i);
              ParamState_VAL[i]:='A';
            endif;
            //если события по этому параметру не зафиксировано
            //тип датчика импульсный или далласовский
            //- но установлен флаг контроля параметра
            //а предыдущее значение не равно текущему
            if (params[i].Mode<>0) and
               (params[i].PredVal<>params[i].CurVal) then
               //проверяем режим работы
               if (((params[i].Mode and 1)=1) and (params[i].CurVal<params[i].MinVal)) or
                  (((params[i].Mode and 2)=2) and (params[i].CurVal>params[i].MaxVal))
               then
                  //если вышли за предел контролируемого параметра
                  //- выставляем флаг события и фиксируем время
                   Incl(KSPDCONTROL,kc_BROKEVENT);
                   BROKEvent[i].NotifyMustSended:=True;
                   BROKEvent[i].AlarmData:=NOWCDATA;
                   BROKEvent[i].State:=params[i].Mode;
                   BROKEvent[i].CurVal:=params[i].CurVal;

                   if Params[i].SMSMessage then
                      Incl(KSPDCONTROL,kc_SMSEVENT);
                      SMSEvent[i].State:=params[i].Mode;
                      SMSEvent[i].NotifyMustSended:=True;
                      SMSEvent[i].AlarmData:=NOWCDATA;
                      SMSEvent[i].CurVal:=params[i].CurVal;
                   endif;
               endif;
            endif;
        endif;
    endfor;
end;

procedure CheckWorkState;
var mask,resval,predresval,i:byte;
     j:TCOMMIDX;

begin
    //фиксируем системную дату
    NowCData:=DateToCDate(DataBody[3],DataBody[2],DataBody[1],DataBody[4],DataBody[5],DataBody[6]);
    //увеличиваем время чтения СМС и проверки уровня сигнала
    Inc(LastCheckBalance);
    //*******************Good idea!!!**************************
    //здесь на будущее можно проанализировать режим работы КСПД
    //и если меряем чисто сигнал - сократить константу
    //*********************************************************
    if LastCheckBalance>3600 then
       Incl(KSPDCONTROL,kc_SMS_CHECK);
       LastCheckBalance:=0;
       if (Debug and $FF) = $FF then
          WritelnStr:='Balans must checked..';WriteLnCon(V_CONSOLE);
       endif;
    endif;

    if (ks_MBROKER in KSPDSTATE) or (ks_EBROKER in KSPDSTATE) or (ks_CSD in KSPDSTATE) or (ks_MSERVER in KSPDSTATE) then
       Inc(ONLINESEK);
       if ONLINESEK>59 then
          ONLINESEK:=0;
          Inc(ONLINEmin);
          if ONLINEmin>59 then
             ONLINEmin:=0;
             Inc(ONLINEHOUR);
             if ONLINEHOUR>23 then
                ONLINEHOUR:=0;
                Inc(ONLINEDAYS);
             endif;
          endif;
       endif;
       MWDog:=0;
    endif;
    
    for j:=ciModem TO ciEthernet do
        Inc(XCOMM[j].IdleCounter);
        if (XCOMM[j].IdleCounter>255) and (xCOMM[j].CurBufNum<>0) then
           xCOMM[j].CurBufNum:=0;
           if (Debug and 1) = 1 then
              WritelnStr:='Clear CurBufNum for '+OWNERNAME[j];WriteLnCon(V_CONSOLE);
           endif;
        endif;
    endfor;
    
end;

(*
                             StartTimeZone             StopTimeZone
Режим                        Начало работы             Конец работы
Работает с 6 до 19               6                          19
Работает с 19 до 6              19                           6
Работает круглые сутки          19                          29
Не работает                     19                          19
                                29                          29
                                29                          19
*)
procedure CheckNowWorkStateTimeZone;             //текущее состояние по зоне подключения
VAR OldNowWorkStateTimeZone:boolean;
begin
 if Inet_ID_HARDWARE<>0 then
   if BadTime then
    //если время битое работаем до синхронизации
    NowWorkStateTimeZone:=True;
   else
    OldNowWorkStateTimeZone:=NowWorkStateTimeZone;
    if (StartTimeZone > 23) or  (StopTimeZone=StartTimeZone) then
      //если время начала вне диапазона или старт равен стопу - значит устройство отключено
      NowWorkStateTimeZone:=False;
    elsif StopTimeZone > 23 then
      //если время окончания вне диапазона - значит устройство включено постоянно
      NowWorkStateTimeZone:=True;
    else
      if Hour=StartTimeZone then
         NowWorkStateTimeZone:=True;
      elsif Hour=StopTimeZone then
         NowWorkStateTimeZone:=False;
      elsif StopTimeZone>StartTimeZone then
         //рабочая зона между старт и стоп с 6 до 9
         NowWorkStateTimeZone:=(Hour >=StartTimeZone) and (Hour <StopTimeZone);
      else
         //рабочая зона между старт и стоп с 9 до 6
         NowWorkStateTimeZone:= ((Hour >= StartTimeZone) and (Hour<=23)) or
                                ((Hour >= 0) and (Hour<StopTimeZone));
      endif;
    endif;
    if OldNowWorkStateTimeZone<>NowWorkStateTimeZone then
       M_RepeatShiftCounter:=0;                  //повтор подключения через x секунд
       E_RepeatShiftCounter:=0;                  //повтор подключения через x секунд
       RepeatCounter:=0;                       //повтор подключения через x секунд
       {$IFDEF DBG}
       if (Debug and 1) = 1 then
          if NowWorkStateTimeZone then
             WritelnStr:='UNIT in work...';
          else
             WritelnStr:='UNIT relaxed...';
          endif;
          WriteLnCon(V_CONSOLE);
       endif;
       {$ENDIF}
    endif;
   endif;
  else
   NowWorkStateTimeZone:=False;
  endif;
end;



function HardwareChecked:boolean;
var result:boolean;
    j,ps:byte;
    Ch:Char;
begin
    if ks_HARDWARECHECKED in KSPDSTATE then
       result:=True;
    else
       result:=False;
       case HardwareCheckedStep of
       0:
           Inc(RepeatCounter);
           {$IFDEF DBG}
           if (Debug and 1) = 1 then
                WritelnStr:='check modem presence - repeat '+bytetoStr(RepeatCounter);
                WriteLnCon(V_CONSOLE);
           endif;
           {$ENDIF}
           //проверка на ответ АТE0 команды
           CmdStr:='ATE0';
           Str2Modem;
           Inc(HardwareCheckedStep);
       |
       1:  //анализируем ответ - и при неудаче передергиваем питание
           if ks_FPM in KSPDSTATE then
              if ModemTimeOut<>0 then
                 if MFindInBuff('OK')>0 then
                    Incl(KSPDSTATE,ks_ATCOMMAND);
                    Incl(KSPDSTATE,ks_MPRESENT);
                    Incl(KSPDSTATE,ks_MPOWER);
                    RepeatCounter:=0;
                    HardwareCheckedStep:=3;
                 else
                    {$IFDEF DBG}
                    WritelnStr:='Modem answer but <OK> not found!';WriteLnCon(V_CONSOLE);
                    {$ENDIF}
                    HardwareCheckedStep:=0;
                 endif;
              else
                 //ответа не было - возможно модем выключен - идем на шаг включения модема
                 SetSysTimer(M_MinuteTimer,HalfMinuteDelay+HalfHalfMinuteDelay);//взводим на 45 сек - ВКЛЮЧЕНИЕ МОДЕМА
                 HardwareCheckedStep:=2;
                 if not (ks_MPOWER in KSPDSTATE) then
                    Pow_On;
                 else
                    Pow_Off;
                    if RepeatCounter>10 then
                       //считаем - что модема нет
                       //идем на проверку EPORT
                       {$IFDEF DBG}
                       if (Debug and 1) = 1 then
                            WritelnStr:='modem not present!';
                            WriteLnCon(V_CONSOLE);
                       endif;
                       {$ENDIF}
                       Excl(KSPDSTATE,ks_MPRESENT);
                       RepeatCounter:=0;
                       HardwareCheckedStep:=19;//на проверку сухих контактов
                    else
                       //передергиваем питание модема
                       mdelay(100);
                       Pow_On;
                    endif;
                 endif;
              endif;
           endif;
       |
       2: //выжидаем время на вкючение модема
          if isSysTimerZero(M_MinuteTimer) then
             HardwareCheckedStep:=0;//пробуем еще раз - после подачи питания
          endif;
       |

       3: //отключаем режим экономии энергии
          RepeatCounter:=0;//сбросили счетчик повторов
          CmdStr:='AT$NOSLEEP=1';
          Str2Modem;
          inc(HardwareCheckedStep);
       |
       4: //по ходу проверяем ответ еще раз
          if ks_FPM in KSPDSTATE then
             if (ModemTimeOut<>0) and (MFindInBuff('OK')>0) then
                Inc(HardwareCheckedStep);
             else
                HardwareCheckedStep:=0;
                {$IFDEF DBG}
                WritelnStr:=cHCMdmTimeOut+'4';
                WriteLnCon(V_CONSOLE);
                {$ENDIF}
             endif;
          endif;
       |
       
       5://проверяем модель модема
          CmdStr:='AT+CGMI';
          Str2Modem;//имя 1
          inc(HardwareCheckedStep);
       |
       
       6: //разбираем ответ на запрос модели модема
          if ks_FPM in KSPDSTATE then
             if ModemTimeOut<>0 then
                j:=0;
                MODEM_NAME1:='';
                for i:=1 to Length(ResStr) do
                   if ord(ResStr[i])=13 then
                     if j<>0 then
                        j:=0;
                        break;
                     else
                        j:=1;
                     endif;
                   else
                     if (j>0) and (j<10) then
                       Ch:=ResStr[i];
                       if not (Ch in [13,10]) then
                         MODEM_NAME1:=MODEM_NAME1+Ch;
                       endif;
                       Inc(j);
                     endif;
                   endif;
                endfor;
                {$IFDEF DBG}
                if (Debug and 1) = 1 then
                   WritelnStr:='model '+MODEM_NAME1;
                   WriteLnCon(V_CONSOLE);
                endif;
                {$ENDIF}
                CmdStr:='AT+CGMM';
                Str2Modem;//запрашиваем подмодель устройства
                Inc(HardwareCheckedStep);//ожидание ответа всегда проводим на следующем шаге
             else
                {$IFDEF DBG}
                WritelnStr:=cHCMdmTimeOut+'6';
                WriteLnCon(V_CONSOLE);
                {$ENDIF}
                HardwareCheckedStep:=0;
             endif;
          endif;
       |

       7://разбираем ответ на запрос модели модема
          if ks_FPM in KSPDSTATE then
            if ModemTimeOut<>0 then
               //-----------------------------------
               // ПРИШЕЛ ОТВЕТ НА ПРЕДЫДУЩИЙ ЗАПРОС
               //-----------------------------------
                j:=0;
                MODEM_NAME2:='';
                for i:=1 to Length(ResStr) do
                   if ResStr[i]=13 then
                     if j<>0 then
                        j:=0;
                        break;
                     else
                        j:=1;
                     endif;
                   else
                     if (j>0) and (j<10) then
                       Ch:=ResStr[i];
                       if not (Ch in [13,10]) then
                         MODEM_NAME2:=MODEM_NAME2+Ch;
                       endif;
                       Inc(j);
                     endif;
                   endif;
                endfor;
                {$IFDEF DBG}
                if (Debug and 1) = 1 then
                    WritelnStr:='SubModel: '+MODEM_NAME2;
                    WriteLnCon(V_CONSOLE);
                endif;
                {$ENDIF}
                if CompareStr(MODEM_NAME2,'M33G') then
                   Incl(KSPDSTATE,ks_M33PRESENT);
                else
                   Excl(KSPDSTATE,ks_M33PRESENT);
                endif;
                CmdStr:='AT+CGMR';//идем на проверку версии модема
                Str2Modem;
                Inc(HardwareCheckedStep);
            else
                {$IFDEF DBG}
                WritelnStr:=cHCMdmTimeOut+'7';
                WriteLnCon(V_CONSOLE);
                {$ENDIF}
                HardwareCheckedStep:=0;
            endif;
          endif;
       |

       8:
          if ks_FPM in KSPDSTATE then
             //SW ver: 1.05
             if ModemTimeOut<>0 then
                //SW ver: 1.05
                ps:=MFindInBuff('SW ver:');
                if ps<>0 then
                   Modem_REVIS:='';
                   for i:=7 to 13 do
                     j:=ord(ResStr[ps+lo(i)]);
                     if j in [10,13] then
                        break;
                     else
                        Modem_REVIS:=Modem_REVIS+j;
                     endif;
                   endfor;
                   M33GSubVer:=0;
                   if (ks_M33PRESENT in KSPDSTATE) then
                      ps:=MFindInBuff('1.');
                      if (ps<>0) and
                         (ResStr[ps+1] in ['0'..'9']) and
                         (ResStr[ps+2] in ['0'..'9'])
                      then
                         M33GSubVer:=byte((ord(ResStr[ps+1])-ord('0'))*10);
                         M33GSubVer:=M33GSubVer+(ord(ResStr[ps+2])-ord('0'));
                      endif;
                      if M33GSubVer<10 then
                         Excl(KSPDSTATE,ks_M33PRESENT);
                      endif;
                   endif;
                endif;
                CmdStr:='AT+CGSN';//считываем IMEI
                Str2Modem;
                Inc(HardwareCheckedStep);
             else
                {$IFDEF DBG}
                WritelnStr:=cHCMdmTimeOut+'8';
                WriteLnCon(V_CONSOLE);
                {$ENDIF}
                HardwareCheckedStep:=0;
             endif;
          endif;
       |
       
       9:
          if ks_FPM in KSPDSTATE then
             if ModemTimeOut<>0 then
                j:=0;
                MODEM_IMEI:='';
                for i:=1 to 30 do
                  ps:=ord(ResStr[i]);
                  if ps in [$30..$39] then
                     Inc(j);
                     MODEM_IMEI:=MODEM_IMEI+ps;
                     if j=15 then break; endif;
                  endif;
                endfor;
             else
                {$IFDEF DBG}
                WritelnStr:=cHCMdmTimeOut+'9';
                WriteLnCon(V_CONSOLE);
                {$ENDIF}
                HardwareCheckedStep:=0;
             endif;
             CmdStr:='AT+CPIN?';//идем на проверку пинкода
             Str2Modem;//запрашиваем пинкод - и проверяем готовность СИМ
             RepeatCounter:=0;
             Inc(HardwareCheckedStep);//ожидание ответа всегда проводим на следующем шаге
          endif;
       |

       10:
       if ks_FPM in KSPDSTATE then
          //'+CPIN: SIM PIN'
          //
          if MFindInBuff('READY')>0 then
              {$IFDEF DBG}
              if (Debug and 1) = 1 then
                WritelnStr:='Modem ready to work...';
                WriteLnCon(V_CONSOLE);
              endif;
              {$ENDIF}
              
              excl(KSPDERROR,ke_BADPINCODE);
              HardwareCheckedStep:=11;//продолжаем инициализацию
          elsif MFindInBuff('ERROR')>0 then
              incl(KSPDERROR,ke_BADPINCODE);
              HardwareCheckedStep:=19;//на проверку сухих контактов
          elsif MFindInBuff('SIM PIN')>0 then
            //если симка c пином - вводим пин
             {$IFDEF DBG}
             if (Debug and 1) = 1 then
               WritelnStr:='PINCODE';
               WriteLnCon(V_CONSOLE);
             endif;
             {$ENDIF}
             //запрашиваем пинкод - и проверяем готовность СИМ только один раз после пуска
             CmdStr:='AT+CPIN="'+PINCODE+'"';//задаем режим подключения к MODEM контенту
             Str2Modem;//запрашиваем пинкод - и проверяем готовность СИМ
             Inc(RepeatCounter);
          else
              {$IFDEF DBG}
              WritelnStr:=cHCMdmTimeOut+'10';
              WriteLnCon(V_CONSOLE);
              {$ENDIF}
              HardwareCheckedStep:=0;
          endif;
       endif;
       |
       
       11:
          CmdStr:='AT+CFUN=1'; //активизация режима модема - Full functionality
          Str2Modem;
          Inc(HardwareCheckedStep);//ожидание ответа всегда проводим на следующем шаге
       |

       12:
          if ks_FPM in KSPDSTATE then
             CmdStr:='AT+CSNS=4';//задаем режим CSD подключения -  4-Data
             Str2Modem;
             Inc(HardwareCheckedStep);//ожидание ответа всегда проводим на следующем шаге
          endif;
       |
       
       13:
          if ks_FPM in KSPDSTATE then
             if ks_M33PRESENT in KSPDSTATE then
                CmdStr:='AT+CMGF=1';//синтаксис команд (Text&PDU) 1-Text
             else
                CmdStr:='AT$HRST=1';//разрешение аппаратного перезапуска (резет) модема
             endif;
             Str2Modem;
             RepeatCounter:=0;//на всякий - т.к. дальше цикл
             Inc(HardwareCheckedStep);//ожидание ответа всегда проводим на следующем шаге
          endif;
       |

       14:
          if ks_FPM in KSPDSTATE then
             CmdStr:='AT+CREG?';//задаем режим подключения к MODEM контенту
             Inc(RepeatCounter);
             Str2Modem;//регистрация в сети
             Inc(HardwareCheckedStep);//ожидание ответа всегда проводим на следующем шаге
          endif;
       |

       15:
          if ks_FPM in KSPDSTATE then
             if MFindInBuff('+CREG: 0, 1')>0 then
                 CmdStr:='AT+COPS?';//задаем режим подключения к MODEM контенту
                 Str2Modem;//имя оператора
                 Inc(HardwareCheckedStep);
                 HardwareCheckedStep:=17;
             else
                 if RepeatCounter<10 then
                    SetSysTimer(M_MinuteTimer,HalfMinuteDelay);//взводим на 30 сек
                    Inc(HardwareCheckedStep);
                 else
                    HardwareCheckedStep:=17;
                    incl(KSPDERROR,ke_BADGSMREG);
                 endif;
             endif;
          endif;
       |

       16:
          //попали сюда - т.к. модем не смог зарегистрироваться в сети
          //выжидаем 30 секунд и возвращаемся
          if isSysTimerZero(M_MinuteTimer) then
             Incl(KSPDSTATE,ks_FPM);
             HardwareCheckedStep:=14;//ожидание ответа всегда проводим на следующем шаге
          endif;
       |



       17:
          if ks_FPM in KSPDSTATE then
             j:=0;
             OPERATOR:='';
             for i:=1 to Length(ResStr) do
                if ResStr[i]='"' then
                  if j<>0 then
                     j:=0;
                     break;
                  else
                     j:=1;
                  endif;
                else
                  if (j>0) and (j<20) then
                    OPERATOR:=OPERATOR+ResStr[i];
                    Inc(j);
                  endif;
                endif;
             endfor;
             {$IFDEF DBG}
             if (Debug and 1) = 1 then
                WritelnStr:='Operator is '+OPERATOR;WriteLnCon(V_CONSOLE);
             endif;
             {$ENDIF}
             CmdStr:='AT+CGATT=1';//подключаемся к Packet Domain Service
             Str2Modem;//register GPRS network
             Inc(HardwareCheckedStep);//ожидание ответа всегда проводим на следующем шаге
          endif;
       |
       18:
          if ks_FPM in KSPDSTATE then
             HardwareCheckedStep:=19;
          endif;
        |

        19:
        //проверка конфигурации активных сухих контактов
        //для tpD - ничего
        //для tpI - восстановить интеграотры из часиков
        //для tpA - проверить на КЗ - аварийные отключить
        for j:=1 to MaxParam do
            if Params[j].Active then
               if Params[j].TypeOfParam = tpI then
                  //восстановить интеграторы из часиков
                  Params[j].lValue:=ReStoreIntegral(j);
               elsif Params[j].TypeOfParam = tpA then
                  //проверить на КЗ - аварийные отключить
                  if not Read_Ov_Level(j) then
                     //порт сконфигурирован как далласовский - но на выходе 0 - короткое
                     //опрос датчика невозможен - генерим Event и отключаем канал
                     Incl(KSPDCONTROL,kc_BROKEVENT);
                     BROKEvent[i].NotifyMustSended:=True;
                     BROKEvent[i].AlarmData:=NOWCDATA;
                     BROKEvent[i].State:=4;//АВАРИЯ ДАТЧИКА
                     if Params[i].SMSMessage then
                        Incl(KSPDCONTROL,kc_SMSEVENT);
                        SMSEvent[i].State:=4;//АВАРИЯ ДАТЧИКА
                        SMSEvent[i].NotifyMustSended:=True;
                        SMSEvent[i].AlarmData:=NOWCDATA;
                     endif;
                  endif;
               endif;
            endif;
        endfor;
        Inc(HardwareCheckedStep);
       |

       20:
           if ETH_CONTROL then
              excl(KSPDSTATE,ks_ECOMMAND);
              ETH_CONTROL:=False;//отключаем командный режим -
           endif;
           mdelay(100);
           if ETH_PRESENT then
              Incl(KSPDSTATE,ks_EPRESENT);
           else
              Excl(KSPDSTATE,ks_EPRESENT);
           endif;
           //
           //
           //
(*           if ETH_PRESENT then
              Incl(KSPDSTATE,ks_ECOMMAND);
              ETH_CONTROL:=True;//включаем командный режим -позднее
           endif;*)
           //
           // анализируем переключатели и дополнительные настройки
           //
           if Switcher_1 then
              //возможны два варианта для брокера основной модем
              //либо основной епорт с подстраховкой модема
              if (ks_MPRESENT in KSPDSTATE) and
                 (not (ke_BADPINCODE in KSPDERROR)) and
                 (not (ke_BADGSMREG in KSPDERROR)) and
                 (Inet_ID_HARDWARE<>0)
              then
                 Incl(KSPDCONTROL,kc_MBROKER_EN);
              else
                 Excl(KSPDCONTROL,kc_MBROKER_EN);
              endif;
              if not Switcher_2 then
                 if (ks_EPRESENT in KSPDSTATE) and
                   (Inet_ID_HARDWARE<>0)
                 then
                   Incl(KSPDCONTROL,kc_EBROKER_EN);
                   Excl(KSPDCONTROL,kc_MBROKER_EN);
                 else
                   Excl(KSPDCONTROL,kc_EBROKER_EN);
                 endif;
              endif;
              
              if (ks_MPRESENT in KSPDSTATE) and
                 (ks_M33PRESENT in KSPDSTATE) and
                 (not (ke_BADPINCODE in KSPDERROR)) and
                 (not (ke_BADGSMREG in KSPDERROR)) and
                 (Inet_SERVER_PORT<>0)
              then
                Incl(KSPDCONTROL,kc_MSERVER_EN);
              else
                Excl(KSPDCONTROL,kc_MSERVER_EN);
              endif;

           else
              //возможны два варианта для брокера основной модем
              //либо основной епорт с подстраховкой модема
              Excl(KSPDCONTROL,kc_MBROKER_EN);
              Excl(KSPDCONTROL,kc_MSERVER_EN);
              Excl(KSPDCONTROL,kc_EBROKER_EN);
              if Switcher_2 then
                 //опрос уровня сигнала
                 if (ks_MPRESENT in KSPDSTATE) and
                 (not (ke_BADPINCODE in KSPDERROR)) and
                 (not (ke_BADGSMREG in KSPDERROR)) then
                    Incl(KSPDCONTROL,kc_MCSQ_EN);//выделенный запрос уровня сигнала
                 else
                    Excl(KSPDCONTROL,kc_MCSQ_EN);
                 endif;
              else
                 //просто бегущая змейка
              endif;
           endif;
           if (ks_MPRESENT in KSPDSTATE) and
              (not (ke_BADPINCODE in KSPDERROR)) and
              (not (ke_BADGSMREG in KSPDERROR)) and
              (not (kc_MBROKER_EN in KSPDCONTROL)) and
              (not (kc_MSERVER_EN in KSPDCONTROL)) and
              (not (kc_EBROKER_EN in KSPDCONTROL))
           then
             Incl(KSPDCONTROL,kc_CSD_EN);
           else
             Excl(KSPDCONTROL,kc_CSD_EN);
           endif;

           if (ks_MPRESENT in KSPDSTATE) and
              (not (ke_BADPINCODE in KSPDERROR)) and
              (not (ke_BADGSMREG in KSPDERROR)) then
               Incl(KSPDCONTROL,kc_SMS_CHECK);
           else
               Excl(KSPDCONTROL,kc_SMS_CHECK);
           endif;

           {$IFDEF DBG}
           if (Debug and 1) = 1 then
                if ks_MPRESENT in KSPDSTATE then
                   if ks_M33PRESENT in KSPDSTATE then
                      WritelnStr:='Modem work in M2M mode';WriteLnCon(V_CONSOLE);
                   else
                      WritelnStr:='Modem work in simple stream mode';WriteLnCon(V_CONSOLE);
                   endif;
                   if ke_BADPINCODE in KSPDERROR then
                      WritelnStr:='Warning!!! Pincode not the true!; The modem will be disconnected';WriteLnCon(V_CONSOLE);
                   endif;
                   if ke_BADGSMREG in KSPDERROR then
                      WritelnStr:='Warning!!! No find GSM Network!';WriteLnCon(V_CONSOLE);
                   endif;
                else//if ks_MPRESENT in KSPDSTATE then
                   WritelnStr:='Modem not found';WriteLnCon(V_CONSOLE);
                endif;//if not ks_MPRESENT in KSPDSTATE then
                if ks_EPRESENT in KSPDSTATE then
                   WritelnStr:='EPORT found';WriteLnCon(V_CONSOLE);
                   ETH_CONTROL:=False;//переводим в режим данных
                else
                   WritelnStr:='EPORT not found';WriteLnCon(V_CONSOLE);
                endif;
           endif;
           {$ENDIF}


           Incl(KSPDSTATE,ks_HARDWARECHECKED);//проверка оборудования завершена
           result:=True;
       |
       endcase;
    endif;
    return(result);
end;


//----------------------------------------------------
// функция производит запуск сервера
//----------------------------------------------------
function ServerMustWork:boolean;
var result:boolean;
    ps:byte;
begin
   result:=False;
   case ServerMustWorkStep of
   0:
    RepeatCounter:=0;
    Inc(ServerMustWorkStep);
   |
   
   1://проверяем активность контента
     if ks_M33PRESENT in KSPDSTATE then
       CmdStr:='AT$NWACT?';//задаем режим подключения к MODEM контенту
     else
       CmdStr:='AT+CGDCONT?';//задаем режим подключения к MODEM контенту
     endif;
     Str2Modem;//активация контента
     Inc(ServerMustWorkStep);
   |
   2:
     if ks_FPM in KSPDSTATE then
        if MFindInBuff(Inet_AP)>0 then
            {$IFDEF DBG}
            if (Debug and $1) = 1 then
               WritelnStr:='content registrated!'; WriteLnCon(V_CONSOLE);
            endif;
           {$ENDIF}
           ServerMustWorkStep:=7;
        else
           {$IFDEF DBG}
           if (Debug and $1) = $1 then
               WritelnStr:='content must registrated!'; WriteLnCon(V_CONSOLE);
           endif;
           {$ENDIF}
           Inc(ServerMustWorkStep);
        endif;
     endif;
   |

   3:
     if RepeatCounter<10 then
        Inc(RepeatCounter);
        if ks_M33PRESENT in KSPDSTATE then
          CmdStr:='AT$NWACT=1,"'+Inet_AP+'","'+Inet_Login+'","'+Inet_Password+'"';
        else
          CmdStr:='AT+CGDCONT=1,"IP","'+Trim(Inet_AP)+'"';//строка инициализации модема - заполянем PDP
        endif;
        Str2Modem;
        ModemTimeOut:=220;//контент долго регистрируется
        Inc(ServerMustWorkStep);
     else
        incl(KSPDERROR,ke_BADGPRSREG); //- пока будет тут 15 мин
        SetSysTimer(M_MinuteTimer,ThenMinuteDelay);//взводим на 10 мин
       {$IFDEF DBG}
       WritelnStr:=cSMWMdmTimeOut+'3';
       WriteLnCon(V_CONSOLE);
       {$ENDIF}
        ServerMustWorkStep:=13;
     endif;
   |

   4:
     if ks_FPM in KSPDSTATE then
       if ModemTimeOut<>0 then
          if (MFindInBuff('OK')>0) or (MFindInBuff('already activated')>0) then
             excl(KSPDERROR,ke_BADGPRSREG);
             ServerMustWorkStep:=7;
          elsif (MFindInBuff('ERROR')>0) or (MFindInBuff('GPRS not ready')>0) then
             incl(KSPDERROR,ke_BADGPRSREG);
             Inc(ServerMustWorkStep);
          else
            {$IFDEF DBG}
            WritelnStr:=cSMWMdmTimeOut+'4!';
            WriteLnCon(V_CONSOLE);
            {$ENDIF}
             SetSysTimer(M_MinuteTimer,OneMinuteDelay);//взводим на 1 мин
             ServerMustWorkStep:=13;
          endif;
       else
          {$IFDEF DBG}
          WritelnStr:=cSMWMdmTimeOut+'4';
          WriteLnCon(V_CONSOLE);
          {$ENDIF}
          ServerMustWorkStep:=3;
       endif;
     endif;
     
     
   |
   5:
       if ks_M33PRESENT in KSPDSTATE then
         CmdStr:='AT$NWACT=0';//строка инициализации модема - заполянем PDP
       else
         CmdStr:='AT+CGDCONT=0';//строка инициализации модема - заполянем PDP
       endif;
       Str2Modem;//деактивация контента
       Inc(ServerMustWorkStep);
   |
   6:
       if ks_FPM in KSPDSTATE then
          ServerMustWorkStep:=1;//повторяем
       endif;
   |
   
   7:
       Excl(KSPDERROR,ke_BADGPRSREG);//сбрасываем флаг плохой регистрации GPRS
       CmdStr:='AT+CGPADDR';//запрашиваем назначенный IP
       Str2Modem;//активация контента
       Inc(ServerMustWorkStep);
   |
   8:
       if ks_FPM in KSPDSTATE then
          ps:=MFindInBuff('+CGPADDR:');
          if ps<>0 then
             //провайдер выделил IP для нашего контента
             Inet_INTERNAL_IP:='';
             j:=0;
             for i:=ps to Length(ResStr) do
                //копируем IP между ""
                if ResStr[i]='"' then
                   if j=0 then
                      j:=1;
                   else
                      break;
                   endif;
                else
                  if j>0 then
                     //сохраняем IP
                     Inet_INTERNAL_IP:=Inet_INTERNAL_IP+ResStr[i];
                  endif;
                endif;
             endfor;
             Inc(ServerMustWorkStep);
          else
             //IP для нашего контента не существует - какие то проблемы с провайдером
             //(нет денег - нет связи)
             {$IFDEF DBG}
             WritelnStr:=cSMWMdmTimeOut+'8';
             WriteLnCon(V_CONSOLE);
             {$ENDIF}
             SetSysTimer(M_MinuteTimer,ThenMinuteDelay);//взводим на 10 мин
             HardwareCheckedStep:=13;
          endif;
       endif;
   |

   9:
       CmdStr:='AT$NWTCPSER?';//проверяем наличие модема
       Str2Modem;//уровень сигнала
       Inc(ServerMustWorkStep);
   |
   10:
       if ks_FPM in KSPDSTATE then
          tmpStr:=IntToStr(Inet_SERVER_PORT);
          if MFindInBuff(tmpStr)>0 then
             RepeatCounter:=0;
             {$IFDEF DBG}
             if (Debug and 1) = 1 then
                 WritelnStr:='SERVER in work';
                 WriteLnCon(V_CONSOLE);
             endif;
             {$ENDIF}
             Incl(KSPDSTATE,ks_MSERVER);
             ServerMustWorkStep:=0;
             result:=True;
          else
            Excl(KSPDSTATE,ks_MSERVER);
            Inc(ServerMustWorkStep);
          endif;
       endif;
   |
   
   11:
       if RepeatCounter<10 then
         Inc(RepeatCounter);
         tmpStr:=IntToStr(Inet_SERVER_PORT);
         CmdStr:='AT$NWTCPSER=1,'+tmpStr;//проверяем наличие модема
         Str2Modem;//уровень сигнала
         ModemTimeOut:=10;
         Inc(ServerMustWorkStep);
       else
         {$IFDEF DBG}
         WritelnStr:=cSMWMdmTimeOut+'11';
         WriteLnCon(V_CONSOLE);
         {$ENDIF}
         SetSysTimer(M_MinuteTimer,ThenMinuteDelay);//взводим на 10 мин
         HardwareCheckedStep:=13;
       endif;
   |
   
   12:
       if ks_FPM in KSPDSTATE then
          ServerMustWorkStep:=9;
       endif;
   |

   13:
       if isSysTimerZero(M_MinuteTimer) then
           HardwareCheckedStep:=0;//повторим регистрацию контента
       else
           MessageLed:=not MessageLed;
       endif;
   |
   
   endcase;
   return(result);
end;


//----------------------------------------------------
// процедура производит чтение смс и проверку уровня сигнала
//----------------------------------------------------
function BrokerMustWork(M33PRESENT:boolean):boolean;
var result:boolean;
begin
   return(result);
end;


//----------------------------------------------------
// функция производит отправку СМС адресатам
//----------------------------------------------------
function SMSEngineMustWork(M33PRESENT:boolean):boolean;
var result:boolean;
    ps,i,j:byte;
begin
   result:=False;
   case SMSEngineMustWorkStep of
   0:
     //проверяем - находится ли модем в режиме команд
     if ks_ATCOMMAND in KSPDSTATE then
        SMSEngineMustWorkStep:=4;//если кспд уже находится в режиме АТ-команд - уходим далее
     else
        CmdStr:='+++';
        Str2ModemX;
        Inc(SMSEngineMustWorkStep);
     endif;
   |
   1..3:
     if ks_FPM in KSPDSTATE then
        if MFindInBuff('OK')>0 then
           Incl(KSPDSTATE,ks_ATCOMMAND);
           SMSEngineMustWorkStep:=4;
        else
           //повторяем запрос
           CmdStr:='+++';
           Str2ModemX;
           Inc(SMSEngineMustWorkStep);
        endif;
     endif;
   |

   4:
     CmdStr:='AT+CSQ';//задаем режим подключения к MODEM контенту
     Str2Modem;//уровень сигнала
     Inc(SMSEngineMustWorkStep);//ожидание ответа всегда проводим на следующем шаге
   |

   5:
     if ks_FPM in KSPDSTATE then
      if ModemTimeOut<>0 then
        //'+CSQ: 17,0'
        ps:=MFindInBuff('+CSQ:');
        if ps>0 then
            if ResStr[ps+6]=ord(',') then
              CSQ_VAL[1]:='0';
              CSQ_VAL[2]:=char(ResStr[ps+5]);
            else
              CSQ_VAL[1]:=char(ResStr[ps+5]);
              CSQ_VAL[2]:=char(ResStr[ps+6]);
            endif;
         endif;
         CSQ:=StrToint(CSQ_VAL);
         if kc_MCSQ_EN in KSPDCONTROL then
            CSQ2Led;
         endif;
      else
        //таймаут однако - модем не ответил
        //пока никакой реакции
        {$IFDEF DBG}
        if (debug and 1) = 1 then
            WritelnStr:='Модем не ответил - пока реакция отсутствует';
            WriteLnCon(V_CONSOLE);
        endif;
        {$ENDIF}
      endif;
       Inc(SMSEngineMustWorkStep);
     endif;
   |
   
   
   
   
   //===============================================
   //     проверяем необходимость чтения СМС
   //===============================================
   6:
     //проверим необходимость
     if kc_SMS_CHECK in KSPDCONTROL then
        Inc(SMSEngineMustWorkStep);
     else
        SMSEngineMustWorkStep:=20;//пока на 20
     endif;
   |

   7:
     //запрашиваем баланс
     CmdStr:='AT+CUSD=1,"'+CUSD_BALANCE+'",15';
     Str2Modem;//уровень сигнала
     if M33PRESENT then
        Incl(KSPDCONTROL,kc_IGNOREOK);
     else
        Excl(KSPDCONTROL,kc_IGNOREOK);
     endif;
     Inc(SMSEngineMustWorkStep);
   |
   
   8:
     //ожидаем ответ на баланс
     if ks_FPM in KSPDSTATE then
        if ModemTimeOut<>0 then
          {$IFDEF DBG}
          if (Debug and 1) = 1 then
              WritelnStr:='Received balance..';WriteLnCon(V_CONSOLE);
          endif;
          {$ENDIF}

          ps:=MFindInBuff('+CUSD: 0,"');
          if ps>0 then
             DecodeSMS(PS-3);
             BALANCE:='';
             j:=0;
             i:=0;
             ps:=MFindFirstDigitInBuff;
             if ps>0 then
              for i:=0 to 14 do
                  if ResStr[ps+i]=$ff then break;endif;
                  if ResStr[ps+i] in [$2C..$39] then
                     BALANCE:=BALANCE+ResStr[ps+i];
                  else
                     break;
                  endif;
              endfor;
              if length(Balance)<=13 then
                   Balance:=Balance+'руб';
              else
                   Balance:='***руб';
              endif;
             else
                Balance:='???руб';
             endif;
          endif;//if ps>0 then
        endif;//if ModemTimeOut<>0 then
        Inc(SMSEngineMustWorkStep);
        RepeatCounter:=0;
     endif;//if ks_FPM in KSPDSTATE then
   |
   
   9:
     Inc(RepeatCounter);
     if RepeatCounter>3 then
        SMSEngineMustWorkStep:=12;
     else
        CmdStr:='AT+CMGR='+ByteToStr(RepeatCounter);
        Str2Modem;//строка инициализации модема
        Inc(SMSEngineMustWorkStep);
     endif;
   |
   
   10:
     if ks_FPM in KSPDSTATE then
        if ModemTimeOut<>0 then
           ps:=MFindInBuff('ERROR');
           if ps>0 then
              SMSEngineMustWorkStep:=12;
           else
              SMSMustDeleted:=True;
              if Length(ResStr)>0 then
                 //
                 // Если СМС есть
                 //
                 Incl(KSPDCONTROL,kc_SMSMUSTDEL);//взводим флаг необходимости удаления текущей СМС
                 ps:=MFindInBuff('05000');
                 if ps>0 then
                    DecodeSMS(PS-1);
                 endif;
                 ps:=MFindInBuff('tbn g ');
                 if ps<>0 then
                    //============================================
                    //    проверяем на конфигурационную СМС
                    //============================================
                    if DisassembleSMS(PS-1) then
                       {$IFDEF DBG}
                       if (Debug and 1) = 1 then
                          WritelnStr:='Digital signature agree - save data...';WriteLnCon(V_CONSOLE);
                       endif;
                       {$ENDIF}
                       Inet_AP:=tmp_Inet_AP;//='internet.mts.ru ';//точка подключения к интернет
                       Inet_Login:=tmp_Inet_Login;//='mts       ';   //точка подключения к интернет
                       Inet_Password:=tmp_Inet_Password;//='mts       ';//точка подключения к интернет
                       Inet_BROKER_IP:=tmp_Inet_BROKER_IP;                //IP брокера
                       Inet_BROKER_PORT:=tmp_Inet_BROKER_PORT;                    //Port брокера
                       Inet_ID_HARDWARE:=tmp_Inet_ID_HARDWARE;                //ID клиента
                    else
                       {$IFDEF DBG}
                       if (Debug and 1) = 1 then
                          WritelnStr:='Digital signature not agree - aborted data...';WriteLnCon(V_CONSOLE);
                       endif;
                       {$ENDIF}
                    endif;
                 else//еси не нашли сигнатуру "tbn"
                    //============================================
                    //    проверяем на СМС c запросом состояния
                    //============================================
                    ps:=MFindInBuff('tbn r +79');
                    if ps<>0 then
                       //если обнаружили номер - временно сохраняем его
                       for i:=1 to 12 do
                           TMP_TEL_NUM[i]:=ResStr[PS+4+i];
                       endfor;
                       ps:=MFindInBuff('CONSOLE:');
                       if ps<>0 then
                       
                       else
                       
                       endif;
                       Incl(KSPDCONTROL,kc_SMS_SEND);//выставляем флаг необходимости посылки сообщения о состоянии системы
                    else
                       //============================================
                       //    проверяем на СМС c запросом состояния для номера по умолчанию
                       //============================================
                       //tbn z startzone=08 stopzone=25
                       ps:=MFindInBuff('tbn z ');
                       //============================================
                       //    проверяем на конфигурационную СМС рабочих зон
                       //============================================
                       if ps<>0 then
                         //пришла СМС с заданием зон
                         ps:=MFindInBuff('startzone=');
                         if ps<>0 then
                            tmpCh2[1]:=ResStr[ps+11];
                            tmpCh2[2]:=ResStr[ps+12];
                            StartTimeZone:=strtoint(tmpCh2);
                            Stored_StartTimeZone:=StartTimeZone;
                            CheckStoredSystemKS(True);
                            CheckSystemKS(True);
                         endif;
                         //пришла СМС с заданием зон
                         ps:=MFindInBuff('stopzone=');
                         if ps<>0 then
                            tmpCh2[1]:=ResStr[ps+10];
                            tmpCh2[2]:=ResStr[ps+11];
                            StopTimeZone:=strtoint(tmpCh2);
                            Stored_StopTimeZone:=StopTimeZone;
                            CheckStoredSystemKS(True);
                            CheckSystemKS(True);
                         endif;
                       else
                         ps:=MFindInBuff('KSPD-RESET');
                         //============================================
                         //    проверяем на СМС для перезагрузки КСПД5
                         //============================================
                         if ps<>0 then
                            if ks_ACCESS_EN in KSPDSTATE then
                              {$IFDEF DBG}
                              if (Debug and 1) = 1 then
                                WritelnStr:='SMS RESET...';WriteLnCon(V_CONSOLE);
                              endif;
                              {$ENDIF}
                            endif;
                         endif;
                       endif;
                    endif;//ps:=MFindInBuff('tbn r +79');
                 endif;
              endif;
           endif;//if ps=0
           Inc(SMSEngineMustWorkStep);
        endif;//if ModemTimeOut<>0 then
     endif;//if ks_FPM in KSPDSTATE then
   |

   11:
     //удаляем СМС
      if SMSMustDeleted then
        //удаляем текущую СМС
        CmdStr:='AT+CMGD='+ByteToStr(RepeatCounter);                      //бросаем трубку
        Str2Modem;//строка инициализации модема
      endif;

   |

   20:
     //проверим необходимость отправки СМС
     if kc_SMS_SEND in KSPDCONTROL then
        Inc(SMSEngineMustWorkStep);
       SendStateSMS;
     else
        SMSEngineMustWorkStep:=40;//пока на 40
     endif;
   |
   
   40:
     if kc_SMSEVENT in KSPDCONTROL then
        Inc(SMSEngineMustWorkStep);
     else
        SMSEngineMustWorkStep:=60;//пока на 60
     endif;
   |
   
   //===============================================
   //проверяем необходимость возврата в режим данных
   //===============================================
   60:
     if (not M33PRESENT) and (KSPDSTATE in [ks_CSD,ks_MBROKER]) then
        Inc(SMSEngineMustWorkStep);
     else
        SMSEngineMustWorkStep:=100;
     endif;
   |

   61:
     //возвращаемся в режим данных
     CmdStr:='ATO';                      //бросаем трубку
     Str2Modem;
     Excl(KSPDSTATE,ks_ATCOMMAND);
     SMSEngineMustWorkStep:=100;
   |

   //===============================================
   //         уходим и сбрасываем все флаги
   //===============================================
   100:
     result:=True;
     SMSEngineMustWorkStep:=0;
     Excl(KSPDCONTROL,[kc_SMS_SEND,kc_SMSEVENT,kc_SMS_CHECK]);//события обработаны
   |
   
   endcase;
   return(result);
end;



//----------------------------------------------------
//  Инициализирует Modem и выводит на запуск сервера
//  и в дальнейшем на подключение к брокеру
//----------------------------------------------------
function ModemWork(M33PRESENT:boolean):boolean;
var result:boolean;
begin
  //при необходимости отправляем СМС
  if KSPDCONTROL in [kc_SMS_SEND,kc_SMSEVENT,kc_SMS_CHECK,kc_MCSQ_EN] then
     result:=SMSEngineMustWork(M33PRESENT);
  else
     result:=True;
  endif;
  
  //если CSD отключен
  if result and (not (kc_CSD_EN in KSPDCONTROL)) then
     //если необходимо запустить сервер
     if (kc_MSERVER_EN in KSPDCONTROL) and (not (ks_MSERVER in KSPDSTATE)) then
        result:=ServerMustWork;
     endif;
     //если необходимо соединение с брокером
     if result and (kc_MBROKER_EN in KSPDCONTROL) and (not (ks_MBROKER in KSPDSTATE)) then
        result:=BrokerMustWork(M33Present);
     endif;
     
     if (kc_MCR in KSPDCONTROL) and (ks_FPM in KSPDSTATE) then
        //если рабочий цикл не обработал флаг запроса - сбрасываем его
        Excl(KSPDCONTROL,kc_MCR);
     endif;
     
  endif;
  return(result);
end;

//----------------------------------------------------
//  Инициализирует EPORT и выводит на подключение к брокеру
//----------------------------------------------------
procedure EthernetWork;
begin
end;


procedure MainWork;
var result:boolean;
begin
    if HardwareChecked then
       if (ks_MPRESENT in KSPDSTATE) then
          result:=ModemWork((ks_M33PRESENT in KSPDSTATE));
       else
          result:=True;
       endif;
       if (ks_EPRESENT in KSPDSTATE) and result then
          EthernetWork;
       endif;
    endif;//if HardwareChecked then
end;


function GetDestComm(BuffID:TCOMMIDX):TCOMMIDX;
begin
  if XCOMM[BuffID].Destination=ciFree then
     if BuffID=ciEthernet then
        return(xcomm[ciEthernet].DestComm);
     elsif BuffID=ciV_CON then
        return(xcomm[ciV_CON].DestComm);
     elsif BuffID=ciFree then
        return(ciFree);
     else
        return(XCOMM[BuffID].DestComm);
     endif;
  else
     return(XCOMM[BuffID].Destination);
  endif;
end;







//-----------------------------------------
// функция выполняет особо сложные операции
//-----------------------------------------
function SuperVisor:boolean;
var i:byte;
    BuffHasData:boolean;
    result:boolean;
begin
    case SuperVisorStep of
    0:
      result:=False;
      for i:=1 to 5 do
          if Slot[i].ModemHasData then
               SuperVisorStep:=1;
               break;
          endif;
      endfor;
    |
    1:
     //проверяем буфера слотов
      result:=True;
      for i:=1 to 5 do
            if Slot[i].ModemHasData then
               CmdStr:='AT$NWDR='+Char(ord('0')+i)+MaxRXReqest;
               Str2Modem;//запрашиваем по 500 байт - более в наш буфер не поместится
               ModemTimeOut:=3;
               Slot[i].ModemHasData:=False;
               Excl(KSPDCONTROL,kc_MCR);
               result:=True;
               Inc(SuperVisorStep);
               SetSysTimer(M2_MinuteTimer,20);
               break;
            endif;
     endfor;
    |
    2:
      if isSysTimerZero(M2_MinuteTimer) then
         SuperVisorStep:=0;
      else
         result:=True;
      endif;
    |
    endcase;
    return(result);
end;

//-----------------------------------------------------------
// Сборка различных функций выполняющаяся один раз в секунду
//-----------------------------------------------------------
procedure  OneSecondProc;
begin
  if KSPDERROR=[] then
     Excl(KSPDSTATE,ks_HASERROR);
     TimeCounterErrorKSPD:=0;
  else
     Incl(KSPDSTATE,ks_HASERROR);
     if Switcher_1 and Switcher_2 and (KSPDERROR in [ke_BADGSMREG,ke_BADGPRSREG]) then
       Inc(TimeCounterErrorKSPD);//если есть критические ошибки
       //если ктритические ошибки более 15 мин - перезагружаем модем
       if TimeCounterErrorKSPD>900 then
          {$IFDEF DBG}
          if (Debug and 1) = 1 then
             WritelnStr:='Critical Error more 15 min. Restart...';WriteLnCon(V_CONSOLE);
          endif;
          {$ENDIF}
          TestReset:=True;
          TimeCounterErrorKSPD:=0;
       endif;
     endif;
  endif;
  //временно - пока не реализовали систему подсвета - нехай моргает
  if Slot[1].Active or
     Slot[2].Active or
     Slot[3].Active or
     Slot[4].Active or
     Slot[5].Active or
     Slot[6].Active or
     Slot[0].Active then
     MessageLed:=not MessageLed;
  else
     if ks_MSERVER in KSPDSTATE then
        if (Second and 7) = 7 then
            MessageLed:=True;
        else
            MessageLed:=False;
        endif;
     else
        MessageLed:=False;
     endif;
  endif;
  Switcher_1:=SW_1;
  Switcher_2:=SW_2;

  if (Switcher_1<>OldSwitcher_1) or
      (Switcher_2<>OldSwitcher_2)
  then
      TestReset:=True;//перезагружаем прибор
  endif;
  //
  // таймер отсчета времени ожидания ответа от модема
  //
  if (kc_MCR in KSPDCONTROL) and (not (ks_FPM in KSPDSTATE)) then
     if ModemTimeOut>0 then
        Dec(ModemTimeOut);
     else
        {$IFDEF DBG}
        if (debug and 1) = 1 then
            WritelnStr:='Modem TimeOut...';WriteLnCon(V_CONSOLE);
        endif;
        {$ENDIF}
        Incl(KSPDSTATE,ks_FPM);
     endif;
  endif;
  //
  // таймер отсчета времени ожидания ответа от EPORT
  //
  if (kc_ECR in KSPDCONTROL) and (not (ks_FPE in KSPDSTATE)) then
     if ModemTimeOut>0 then
        Dec(EthernetTimeOut);
     else
        {$IFDEF DBG}
        if (debug and 1) = 1 then
            WritelnStr:='EPORT TimeOut...';WriteLnCon(V_CONSOLE);
        endif;
        {$ENDIF}
        Incl(KSPDSTATE,ks_FPE);
     endif;
  endif;
  CheckNowWorkStateTimeZone;
  CheckWorkState;//расчитывает текущее время
  CheckParam;    //производим перерасчет активных параметров
  DecToLim(M_RepeatShiftCounter,0,1);
  DecToLim(E_RepeatShiftCounter,0,1);
end;

procedure CheckImpulse;
var i:byte;
begin
   for i:=1 to MaxParam do
       if Params[i].Active and
         (Params[i].TypeOfParam in [tpD,tpI])
       then
          case Params[i].NumParam of
          1:Params[i].CurState:=ISw_1;|
          2:Params[i].CurState:=ISw_2;|
          3:Params[i].CurState:=ISw_3;|
          4:Params[i].CurState:=ISw_4;|
          endcase;
          //если текущий 1 а предыдущий 0
          if Params[i].CurState<>Params[i].PredState then
             //если датчик событийный и включен режим контроля и события еще не было
             if Params[i].TypeOfParam=tpD then
                Params[i].CurVal:=ord(Params[i].CurState);
                if Params[i].CurState then
                   ParamState_VAL[i]:='1';
                else
                   ParamState_VAL[i]:='0';
                endif;
                if (Params[i].Mode<>0) then
                    //для датчиков tpD выставляем флаг события и фиксируем дату
                    if (((Params[i].Mode and 1)=1) and (Params[i].CurState>Params[i].PredState)) or
                        (((Params[i].Mode and 2)=2) and (Params[i].PredState>Params[i].CurState))
                    then
                       //если событие сверху вниз \ или снизу вверх и подходит под Mode
                       Incl(KSPDCONTROL,kc_BROKEVENT);
                       BROKEvent[i].NotifyMustSended:=True;
                       BROKEvent[i].AlarmData:=NOWCDATA;
                       BROKEvent[i].CurVal:=params[i].CurVal;

                       if Params[i].SMSMessage then
                          Incl(KSPDCONTROL,kc_SMSEVENT);
                          SMSEvent[i].NotifyMustSended:=True;
                          SMSEvent[i].AlarmData:=NOWCDATA;
                          SMSEvent[i].CurVal:=params[i].CurVal;
                       endif;
                    endif;
                endif;
                Params[i].PredState:=Params[i].CurState;
             else
                inc(Params[i].iDlit);
                if Params[i].iDlit>3 then
                   if Params[i].CurState then//засчитываем только в верхнем уровне
                       inc(Params[i].lValue);
                   endif;
                endif;
             endif;
         endif;//Cur<>Pred
       endif;
   endfor;
end;
//---------------
// Тело программы
//---------------
begin
  InitPorts;
  WDT_Prescaler_Change;
  WatchDogTrigger;
  InitVariables;
  MessageLed:=True;
  EnableInts;
  if GetDateTime then
    SetLocalRTC;
  else
    WritelnStr:='RTC not ready...';
    WriteLnCon(V_CONSOLE);
  endif;
  WatchDogTrigger;
  Signon(False,V_CONSOLE);
  SetSysTimer(checkIOTimer,200);
  WatchDogTrigger;
  BadTime:=Year<8;
  SetSysTimer(CheckIOTimer,IOBuffTimerDelay);
  SetSysTimer(CheckInpBuffTimer,InpBuffTimerDelay);
  SetSysTimer(HourTimer,Lo(OneSecDelay));
  SetSysTimer(M_MinuteTimer,word(OneSecDelay));//взводим на 1 сек
  SetSysTimer(E_MinuteTimer,word(OneSecDelay));//взводим на 1 сек
  MessageLed:=False;
  WatchDogTrigger;
  if debug <>0 then
     WritelnStr:='Lets Go!';
     WriteLnCon(V_CONSOLE);
  endif;
  //---------------
  // Основной цикл
  //---------------
  loop
      if isSysTimerZero(CheckImpulseTimer) then
           SetSysTimer(CheckImpulseTimer,CheckImpulseDelay);
           CheckImpulse;
      endif;

      if isSysTimerZero(CheckInpBuffTimer) then
           SetSysTimer(CheckInpBuffTimer,InpBuffTimerDelay);
           //---------------------------------------------------
           //       контролируем сухие контакты
           //---------------------------------------------------
           if CurXCOMM=ci232 then
              CurXCOMM:=ci485;
           elsif CurXCOMM=ci485 then
              CurXCOMM:=ciMODEM;
           elsif CurXCOMM=ciMODEM then
              CurXCOMM:=ciEthernet;
           else
              CurXCOMM:=ci232;
           endif;
           ChkIBuff(CurXCOMM);
      endif;

      if isSysTimerZero(CheckIOTimer) then
           SetSysTimer(CheckIOTimer,IOBuffTimerDelay);
           //---------------------------------------------------
           // прверяем - есть ли входящие пакеты с интерфейсов
           //---------------------------------------------------
           if (not SuperVisor) and (not HandleMode) then
              MainWork;
           endif;
      endif;

      if isSysTimerZero(HourTimer) then
           SetSysTimer(HourTimer,Lo(OneSecDelay));
           WatchDogTrigger;
           OneSecondProc;
      endif;
      
      
      
  endloop;
  
end gprs_1.




